# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Expo assessor for CVE-2025-55182."""

from typing import Any

from ...models.poc import PocStatus
from ...rsc.payloads import RscReference, build_multipart_decode_payload, build_random_safe_prop
from ...rsc.runner import run_rsc_action_probes
from ...rsc.send import send_rsc_request
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_ids
from ...utils.context import scan_context
from ..interpreters.expo_interpreter import ExpoInterpreter
from ..journal import PocJournal, get_current_journal
from .base import BaseAssessor


class ExpoAssessor(BaseAssessor):
    framework_name = "expo"

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        journal = get_current_journal() or PocJournal()
        signals = (detect_context or {}).get("signals", {}) or {}
        tags = (detect_context or {}).get("tags", []) or []
        invocation_signal = signals.get("invocation_enabled")
        has_server_actions_tag = "expo-server-actions" in tags
        if invocation_signal is None and has_server_actions_tag:
            invocation_signal = True
        has_rsc_surface = bool(signals.get("rsc_endpoint_found") or ("expo-rsc" in tags) or ("rsc" in tags))

        # For CVE-2025-55182, the relevant surface is RSC Flight protocol payload deserialization (decodeReply),
        # not RSC Flight-only generation endpoints.
        is_rsc_framework = bool(invocation_signal is True or has_server_actions_tag)
        react_major_confidence = (detect_context or {}).get("react_major_confidence") or self.get_version_confidence("react_version", detected_versions, detect_context)

        if invocation_signal is not True:
            if invocation_signal is False:
                reason = "Expo detected; Server Functions not enabled"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason, rule="server_functions_disabled")
                return self.build_missing_surface_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    journal=journal,
                    confidence=signals.get("invocation_confidence") or signals.get("detection_confidence_level") or "medium",
                )

            if not has_rsc_surface:
                reason = "Expo detected but no RSC Flight markers and no evidence of reachable Flight protocol payload deserialization"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason, rule="no_rsc_surface")
                return self.build_missing_surface_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    journal=journal,
                    confidence=signals.get("detection_confidence_level") or "medium",
                )

            reason = "Expo detected; Server Functions endpoint discovery failed, so Flight protocol payload deserialization reachability is unknown"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="endpoint_discovery_failed")
            return self.build_inconclusive_result(
                reason,
                detected_versions,
                journal=journal,
                confidence=signals.get("invocation_confidence") or signals.get("detection_confidence_level") or "low",
                surface_detected=is_rsc_framework,
            )

        action_ids = generate_action_ids(3)
        control_action_id: str | None = None
        action_urls = (detect_context or {}).get("invocation_endpoints") if detect_context else None

        request_config = RscRequestConfig(
            method="POST",
            base_headers={
                "Accept": "text/x-component",
                "expo-platform": "web",
            },
            action_id_header=None,
        )

        # Expo Router Server Functions use React's encodeReply(), which can emit different server-reference
        # marker families depending on the bundled RSC runtime. Empirically:
        # - patched builds tend to accept `$h…` references and reject invalid ones quickly ("Invalid reference.")
        # - older builds accept `$F…` references and may hang on `$h…` inputs.
        #
        # Pick the marker by trying a bounded control probe with a safe property.
        def _select_server_ref_marker(endpoint: str) -> str:
            safe_prop = build_random_safe_prop(prefix="z")

            def _probe(marker: str) -> dict[str, Any]:
                payload = build_multipart_decode_payload(RscReference(slot=1, root="x", prop=safe_prop, marker=marker))
                # Keep this bounded: we only need to know which marker yields an actual HTTP response.
                with scan_context(timeout=3.0):
                    return send_rsc_request(endpoint, request_config, payload)

            first = _probe("h")
            first_body = str(first.get("body") or first.get("body_snippet") or "")
            first_result = dict(first)
            first_result.setdefault("endpoint", endpoint)
            journal.add_probe_result("marker-select-h", first_result)
            if first.get("ok") and first.get("status_code") is not None:
                # Patched Expo Router runtimes often return a stable "Invalid reference." error for `$h…`.
                if "invalid reference" in first_body.lower():
                    journal.add_event(
                        "expo-marker-select",
                        "Selected `$h` server reference marker based on 'Invalid reference' baseline",
                        data={"endpoint": endpoint, "marker": "h"},
                    )
                    return "h"

            second = _probe("F")
            second_result = dict(second)
            second_result.setdefault("endpoint", endpoint)
            journal.add_probe_result("marker-select-F", second_result)
            if second.get("ok") and second.get("status_code") is not None:
                journal.add_event(
                    "expo-marker-select",
                    "Selected `$F` server reference marker because `$F` probe returned an HTTP response",
                    data={"endpoint": endpoint, "marker": "F"},
                )
                return "F"

            if first.get("ok") and first.get("status_code") is not None:
                journal.add_event(
                    "expo-marker-select",
                    "Selected `$h` server reference marker because `$h` probe returned an HTTP response",
                    data={"endpoint": endpoint, "marker": "h"},
                )
                return "h"

            # Fallback to the more modern marker; downstream analysis will likely be inconclusive.
            journal.add_event(
                "expo-marker-select",
                "Falling back to `$h` server reference marker (no bounded marker probe yielded an HTTP response)",
                data={"endpoint": endpoint, "marker": "h"},
            )
            return "h"

        if not action_urls or not isinstance(action_urls, list):
            reason = "Expo detected; Server Functions enabled but no endpoints discovered (cannot probe Flight protocol payload deserialization)"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="missing_action_endpoints")
            return self.build_inconclusive_result(
                reason,
                detected_versions,
                journal=journal,
                confidence=signals.get("invocation_confidence") or signals.get("detection_confidence_level") or "low",
                surface_detected=is_rsc_framework,
            )

        primary_endpoint = str(action_urls[0])
        server_ref_marker = _select_server_ref_marker(primary_endpoint)

        def _wrap_payload(payload, *, kind: str, marker: str):
            meta = dict(payload.meta or {})
            meta.update({"probe_kind": kind, "probe_strategy": "expo_multipart_decode", "server_ref_marker": marker})
            return type(payload)(wire_format=payload.wire_format, headers=payload.headers, body=payload.body, meta=meta)

        def _proto_payload(_action_id: str):
            payload = build_multipart_decode_payload(RscReference(slot=1, root="x", prop="__proto__", marker=server_ref_marker))
            return _wrap_payload(payload, kind="proto", marker=server_ref_marker)

        def _control_payload(_action_id: str):
            safe_prop = build_random_safe_prop(prefix="z")
            payload = build_multipart_decode_payload(RscReference(slot=1, root="x", prop=safe_prop, marker=server_ref_marker))
            return _wrap_payload(payload, kind="control", marker=server_ref_marker)

        probe_results, control_result = run_rsc_action_probes(
            base_url,
            action_ids,
            request_config=request_config,
            proto_payload=_proto_payload,
            control_payload=_control_payload,
            action_urls=[str(u) for u in action_urls],
            control_url=primary_endpoint,
            control_action_id=control_action_id,
        )

        analyzer = ExpoInterpreter(
            is_rsc_framework=is_rsc_framework,
            react_major=self.get_react_major(detected_versions, detect_context),
            react_version=detected_versions.get("rsc_runtime_version") or detected_versions.get("react_version"),
            react_major_confidence=react_major_confidence,
            react_major_conflict=(detect_context or {}).get("react_major_conflict"),
            react_major_conflict_confidence=(detect_context or {}).get("react_major_conflict_confidence"),
            react_major_conflict_majors=(detect_context or {}).get("react_major_conflict_majors"),
            invocation_expected=invocation_signal,
            invocation_confidence=signals.get("invocation_confidence"),
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = detected_versions
        return analysis
