# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Expo assessor for CVE-2025-55182."""

from typing import Any

from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_INVOCATION_CONFIDENCE,
    SIG_INVOCATION_ENABLED,
    SIG_RSC_ENDPOINT_FOUND,
    TAG_EXPO_RSC,
    TAG_EXPO_SERVER_ACTIONS,
    TAG_RSC,
)
from ...models.poc import PocStatus
from ...rsc.probes import probe_server_reference_markers
from ...rsc.runner import build_request_config, run_decode_action_probes
from ...utils import normalize_version_map
from ...utils.actions import generate_action_ids
from ..interpreters.expo_interpreter import ExpoInterpreter
from ..journal import PocJournal, get_current_journal
from ..resolvers.expo import normalize_expo_action_endpoints
from ..surface import surface_from_detect_context
from ..snapshots import DetectContext
from .base import BaseAssessor


class ExpoAssessor(BaseAssessor):
    framework_name = "expo"

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: DetectContext | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        normalized_versions = normalize_version_map(detected_versions)
        journal = get_current_journal() or PocJournal()
        signals = self._context_signals(detect_context)
        tags = self._context_tags(detect_context)
        surface = surface_from_detect_context(detect_context)
        invocation_signal = surface.invocation_surface
        has_server_actions_tag = TAG_EXPO_SERVER_ACTIONS in tags
        has_rsc_surface = bool(surface.rsc_surface is True or signals.get(SIG_RSC_ENDPOINT_FOUND) or (TAG_EXPO_RSC in tags) or (TAG_RSC in tags))

        # For CVE-2025-55182, the relevant surface is RSC Flight protocol payload deserialization (decodeReply),
        # not RSC Flight-only generation endpoints.
        is_rsc_framework = bool(invocation_signal is True or has_server_actions_tag)
        react_major_confidence = (detect_context.react_major_confidence if detect_context else None) or self.get_version_confidence("react_version", normalized_versions, detect_context)

        if invocation_signal is not True:
            if invocation_signal is False:
                reason = "Expo detected; Server Functions not enabled"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason, rule="server_functions_disabled")
                confidence = signals.get(SIG_INVOCATION_CONFIDENCE) or signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "medium"
                if confidence == "low":
                    confidence = "medium"
                return self.build_missing_surface_result(
                    reason,
                    normalized_versions,
                    surface_detected=False,
                    journal=journal,
                    confidence=confidence,
                )

            if not has_rsc_surface:
                reason = "Expo detected but no RSC Flight markers and no evidence of reachable Flight protocol payload deserialization"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason, rule="no_rsc_surface")
                confidence = signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "medium"
                if confidence == "low":
                    confidence = "medium"
                return self.build_missing_surface_result(
                    reason,
                    normalized_versions,
                    surface_detected=False,
                    journal=journal,
                    confidence=confidence,
                )

            reason = "Expo detected; Server Functions endpoint discovery failed, so Flight protocol payload deserialization reachability is unknown"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="endpoint_discovery_failed")
            return self.build_inconclusive_result(
                reason,
                normalized_versions,
                journal=journal,
                confidence=signals.get(SIG_INVOCATION_CONFIDENCE) or signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "low",
                surface_detected=is_rsc_framework,
            )

        action_ids = generate_action_ids(3)
        control_action_id: str | None = None
        action_urls = self._context_invocation_endpoints(detect_context) or None

        request_config = build_request_config(
            action_id_header=None,
            base_headers={"expo-platform": "web"},
        )

        # Expo Router Server Functions use React's encodeReply(), which can emit different server-reference
        # marker families depending on the bundled RSC runtime. Empirically:
        # - patched builds tend to accept `$h…` references and reject invalid ones quickly ("Invalid reference.")
        # - older builds accept `$F…` references and may hang on `$h…` inputs.
        #
        # Pick the marker by trying a bounded control probe with a safe property.
        def _select_server_ref_marker(endpoint: str) -> str:
            results = probe_server_reference_markers(
                endpoint,
                request_config=request_config,
                markers=("h", "F"),
                timeout=3.0,
            )

            first = results.get("h")
            if first is not None:
                journal.add_probe_result("marker-select-h", first)
                first_body = str(first.text or first.body_snippet or "")
                if first.ok and first.status_code is not None:
                    # Patched Expo Router runtimes often return a stable "Invalid reference." error for `$h…`.
                    if "invalid reference" in first_body.lower():
                        journal.add_event(
                            "expo-marker-select",
                            "Selected `$h` server reference marker based on 'Invalid reference' baseline",
                            data={"endpoint": endpoint, "marker": "h"},
                        )
                        return "h"

            second = results.get("F")
            if second is not None:
                journal.add_probe_result("marker-select-F", second)
                if second.ok and second.status_code is not None:
                    journal.add_event(
                        "expo-marker-select",
                        "Selected `$F` server reference marker because `$F` probe returned an HTTP response",
                        data={"endpoint": endpoint, "marker": "F"},
                    )
                    return "F"

            if first is not None and first.ok and first.status_code is not None:
                journal.add_event(
                    "expo-marker-select",
                    "Selected `$h` server reference marker because `$h` probe returned an HTTP response",
                    data={"endpoint": endpoint, "marker": "h"},
                )
                return "h"

            # Fallback to the more modern marker; downstream analysis will likely be inconclusive.
            journal.add_event(
                "expo-marker-select",
                "Falling back to `$h` server reference marker (no bounded marker probe yielded an HTTP response)",
                data={"endpoint": endpoint, "marker": "h"},
            )
            return "h"

        if not action_urls or not isinstance(action_urls, list):
            reason = "Expo detected; Server Functions enabled but no endpoints discovered (cannot probe Flight protocol payload deserialization)"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="missing_action_endpoints")
            return self.build_inconclusive_result(
                reason,
                normalized_versions,
                journal=journal,
                confidence=signals.get(SIG_INVOCATION_CONFIDENCE) or signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "low",
                surface_detected=is_rsc_framework,
            )

        normalized_endpoints = normalize_expo_action_endpoints([str(u) for u in action_urls if u])
        if not normalized_endpoints:
            reason = "Expo detected; Server Functions enabled but no usable action endpoints were discovered"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="missing_action_endpoints")
            return self.build_inconclusive_result(
                reason,
                normalized_versions,
                journal=journal,
                confidence=signals.get(SIG_INVOCATION_CONFIDENCE) or signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "low",
                surface_detected=is_rsc_framework,
            )

        primary_endpoint = str(normalized_endpoints[0])
        server_ref_marker = _select_server_ref_marker(primary_endpoint)

        proto_meta = {"probe_kind": "proto", "probe_strategy": "expo_multipart_decode", "server_ref_marker": server_ref_marker}
        control_meta = {"probe_kind": "control", "probe_strategy": "expo_multipart_decode", "server_ref_marker": server_ref_marker}

        probe_results, control_result = run_decode_action_probes(
            base_url,
            action_ids,
            request_config=request_config,
            marker=server_ref_marker,
            proto_meta=proto_meta,
            control_meta=control_meta,
            action_urls=list(normalized_endpoints),
            control_url=primary_endpoint,
            control_action_id=control_action_id,
        )

        analyzer = ExpoInterpreter(
            is_rsc_framework=is_rsc_framework,
            react_major=self.get_react_major(normalized_versions, detect_context),
            react_version=(
                str(normalized_versions.get("rsc_runtime_version").value)
                if normalized_versions.get("rsc_runtime_version")
                else (str(normalized_versions.get("react_version").value) if normalized_versions.get("react_version") else None)
            ),
            react_major_confidence=react_major_confidence,
            react_major_conflict=(detect_context.react_major_conflict if detect_context else None),
            react_major_conflict_confidence=(detect_context.react_major_conflict_confidence if detect_context else None),
            react_major_conflict_majors=(detect_context.react_major_conflict_majors if detect_context else None),
            invocation_expected=invocation_signal,
            invocation_confidence=signals.get(SIG_INVOCATION_CONFIDENCE),
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = self._version_values_for_output(normalized_versions)
        return analysis
