"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Expo assessor for CVE-2025-55182."""

import json
import secrets
from typing import Any
from urllib.parse import urlsplit, urlunsplit

from ...models.poc import PocStatus
from ...rsc.payloads import RscReference, build_plaintext_payload
from ...rsc.runner import run_rsc_action_probes
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_ids
from ..interpreters.expo_interpreter import ExpoInterpreter
from ..journal import PocJournal, get_current_journal
from .base import BaseAssessor


class ExpoAssessor(BaseAssessor):
    framework_name = "expo"

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        journal = get_current_journal() or PocJournal()
        signals = (detect_context or {}).get("signals", {}) or {}
        tags = (detect_context or {}).get("tags", []) or []
        server_actions_signal = signals.get("server_actions_enabled")
        has_server_actions_tag = "expo-server-actions" in tags
        if server_actions_signal is None and has_server_actions_tag:
            server_actions_signal = True
        has_rsc_surface = bool(signals.get("rsc_endpoint_found") or ("expo-rsc" in tags) or ("rsc" in tags))

        # For CVE-2025-55182, the relevant surface is Server Actions/Functions decoding (decodeReply),
        # not RSC-only generation endpoints.
        is_rsc_framework = bool(server_actions_signal is True or has_server_actions_tag)
        react_major_confidence = (detect_context or {}).get("react_major_confidence") or self.get_version_confidence("react_version", detected_versions, detect_context)

        if server_actions_signal is not True:
            if server_actions_signal is False:
                reason = "Expo detected but no framework-native Server Actions surface detected"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason)
                return self.build_not_applicable_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=signals.get("server_actions_confidence") or signals.get("detection_confidence_level") or "medium",
                )

            if not has_rsc_surface:
                reason = "Expo detected but no RSC / Server Functions surface detected"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason)
                return self.build_not_applicable_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=signals.get("detection_confidence_level") or "medium",
                )

            reason = "Expo detected but Server Actions reachability is unknown (no action endpoints discovered)"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason)
            return self.build_inconclusive_result(
                reason,
                detected_versions,
                journal=journal,
                confidence=signals.get("server_actions_confidence") or signals.get("detection_confidence_level") or "low",
                surface_detected=is_rsc_framework,
            )

        action_ids = generate_action_ids(3)
        control_action_id: str | None = None
        action_urls = (detect_context or {}).get("server_action_endpoints") if detect_context else None

        request_config = RscRequestConfig(
            method="POST",
            base_headers={
                "Accept": "text/x-component",
                "expo-platform": "web",
            },
            action_id_header=None,
        )

        def _randomize_action_url(url: str) -> str:
            """
            Expo Router Server Functions encode the target in the URL path (ACTION_...).
            Use a random, non-existent action target so we never invoke unknown app code, while still
            exercising decodeReply() before the router attempts module resolution.
            """
            parts = urlsplit(url)
            marker = "/ACTION_"
            if marker not in parts.path:
                return url
            base_path, _ = parts.path.split(marker, 1)
            token = secrets.token_hex(8)
            # Preserve the ACTION_<file>/<export>.txt shape to maximize the chance that the request
            # reaches Server Functions decoding, while still guaranteeing the module target is missing.
            new_path = f"{base_path}{marker}./reactguard_probe_{token}.ts/probe.txt"
            return urlunsplit((parts.scheme, parts.netloc, new_path, parts.query, parts.fragment))

        randomized_action_url = _randomize_action_url(str(action_urls[0])) if action_urls else base_url

        def _proto_payload(_action_id: str):
            # Native Expo Router Server Functions use text/plain bodies (JSON array args).
            # Use `$F0` references to avoid deadlock paths observed on some Metro responses.
            ref = RscReference(slot=0, root="x", prop="__proto__", marker="F").render()
            body = json.dumps([ref], separators=(",", ":"))
            return build_plaintext_payload(body, meta={"probe_kind": "proto", "reference": ref, "probe_strategy": "expo_random_action_url"})

        def _control_payload(_action_id: str):
            body = json.dumps([], separators=(",", ":"))
            return build_plaintext_payload(body, meta={"probe_kind": "control", "probe_strategy": "expo_random_action_url"})

        probe_results, control_result = run_rsc_action_probes(
            base_url,
            action_ids,
            request_config=request_config,
            proto_payload=_proto_payload,
            control_payload=_control_payload,
            control_url=randomized_action_url,
            action_urls=[randomized_action_url],
            control_action_id=control_action_id,
        )

        analyzer = ExpoInterpreter(
            is_rsc_framework=is_rsc_framework,
            react_major=self.get_react_major(detected_versions, detect_context),
            react_version=detected_versions.get("rsc_runtime_version") or detected_versions.get("react_version"),
            react_major_confidence=react_major_confidence,
            server_actions_expected=server_actions_signal,
            server_actions_confidence=signals.get("server_actions_confidence"),
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = detected_versions
        return analysis
