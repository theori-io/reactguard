# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Evidence scoring helpers for Dec 2025 RSC patch fingerprinting."""

from __future__ import annotations

from collections.abc import Mapping
from typing import Any

from ...http.models import HttpResponse
from ...rsc.heuristics import is_action_not_found_response, is_rsc_content_type
from .rsc_dec2025_signatures import (
    extract_digest,
    infer_react_major_from_result,
    looks_like_connection_closed,
    looks_like_cycle_thenables_error,
    looks_like_temporary_reference_error,
)

_DEC2025_CHAIN_NON_RSC_STATUS_CODES = {401, 403, 404, 405, 413, 415}


def normalize_signature(sig: str) -> str:
    if not sig:
        return ""
    if sig.startswith("digest:"):
        return "digest"
    return sig


def is_status_only_signature(sig: str) -> bool:
    return bool(sig) and sig.startswith("status:")


def matches_connection_closed(sig: str, conn_sig: str) -> bool:
    if not sig:
        return False
    if sig == "connection_closed":
        return True
    return bool(conn_sig and sig == conn_sig)


def is_chain_signature_uninterpretable(sig: str) -> bool:
    if not sig:
        return True
    if sig in {"timeout", "next_action_not_found", "html"}:
        return True
    return is_status_only_signature(sig)


def chain_has_decode_evidence(chain_sigs: dict[int, str], baseline_sigs: list[str] | tuple[str, ...]) -> bool:
    normalized_chain = {normalize_signature(s) for s in chain_sigs.values() if s}
    if not normalized_chain:
        return False

    # Treat these as standalone evidence that the request reached RSC decode/Flight plumbing.
    if normalized_chain & {"digest", "connection_closed", "cycle_thenables"}:
        return True

    normalized_baseline = {normalize_signature(s) for s in baseline_sigs if s}
    return bool(normalized_chain & normalized_baseline)


def pr35345_evidence_strength(label_to_result: dict[str, Mapping[str, Any] | HttpResponse | None], sigs: list[str]) -> str:
    """
    Estimate how likely it is that marker probes reached the RSC/Flight deserializer.

    Returned levels are used to down-weight PR#35345 patch fingerprints that could be explained by
    generic infra behavior (WAF/proxy/routing) rather than React decode paths.
    """
    for result in label_to_result.values():
        if not result:
            continue
        if isinstance(result, HttpResponse):
            headers = result.headers
        else:
            headers = result.get("headers")
        if is_rsc_content_type(headers):
            return "strong"
        if extract_digest(result):
            return "strong"
        if looks_like_cycle_thenables_error(result):
            return "strong"
        if looks_like_temporary_reference_error(result):
            return "strong"
        if infer_react_major_from_result(result) is not None:
            return "strong"

    normalized = {normalize_signature(s) for s in sigs if s}
    normalized.discard("timeout")
    normalized.discard("html")
    normalized.discard("next_action_not_found")
    if not normalized or all(is_status_only_signature(s) for s in sigs if s):
        return "none"
    if "connection_closed" in normalized:
        return "medium"
    if "digest" in normalized or "cycle_thenables" in normalized:
        return "strong"
    return "weak"


def pr35345_stability_score(primary: dict[str, str], retest: dict[str, str]) -> tuple[int, dict[str, bool]]:
    """
    Compare marker signatures from a retest to detect unstable/non-deterministic infrastructure behavior.

    Returns:
    - score: count of matching markers (0..2)
    - per_marker: {"h": bool, "F": bool}
    """
    stable_h = normalize_signature(retest.get("h", "")) == normalize_signature(primary.get("h", ""))
    stable_f = normalize_signature(retest.get("F", "")) == normalize_signature(primary.get("F", ""))
    return int(stable_h) + int(stable_f), {"h": stable_h, "F": stable_f}


def looks_like_non_rsc_transport_error(result: Mapping[str, Any] | HttpResponse | None) -> bool:
    if not result:
        return True
    status_code = result.status_code if isinstance(result, HttpResponse) else result.get("status_code")
    if isinstance(status_code, int) and status_code in _DEC2025_CHAIN_NON_RSC_STATUS_CODES:
        # Allow known decode-time patterns even if the HTTP status is unexpected.
        if is_action_not_found_response(result):
            return False
        if looks_like_cycle_thenables_error(result) or looks_like_connection_closed(result) or extract_digest(result):
            return False
        return True
    return False


__all__ = [
    "chain_has_decode_evidence",
    "is_chain_signature_uninterpretable",
    "is_status_only_signature",
    "looks_like_non_rsc_transport_error",
    "matches_connection_closed",
    "normalize_signature",
    "pr35345_evidence_strength",
    "pr35345_stability_score",
]
