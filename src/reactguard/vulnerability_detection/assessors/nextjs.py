"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Next.js assessor for CVE-2025-55182."""

import logging
import re
from dataclasses import replace
from typing import Any

from ...framework_detection.signals.server_actions import detect_server_actions
from ...http import scan_with_retry
from ...models.poc import PocStatus
from ..interpreters.multi_action import MultiActionAnalyzer
from ..journal import PocJournal, get_current_journal
from ..payloads import (
    ActionProbeRunner,
    generate_action_ids,
    send_control_probe,
    send_proto_probe,
)
from .base import BaseAssessor


class NextJSAssessor(BaseAssessor):
    framework_name = "nextjs"

    logger = logging.getLogger(__name__)

    # RSC Flight patterns to infer React major from HTML payloads
    RSC_FLIGHT_PATTERNS_V18 = (
        re.compile(r'^\s*0:\["\$","\$L', re.MULTILINE),
        re.compile(r'^\s*0:\[\\"\\$\\",\\"\$L', re.MULTILINE),
        re.compile(r'^\s*0:"\$L', re.MULTILINE),
        re.compile(r'^\s*0:\\"\\$L', re.MULTILINE),
    )
    RSC_FLIGHT_PATTERNS_V19 = (
        '0:[null,["$"',
        '0:[null,[\\"$\\"',
        '0:{"a":"$@',
        '0:{\\"a\\":\\"$@',
    )

    @staticmethod
    def is_next_version_out_of_scope(next_version: str | None) -> bool:
        """Return True if the Next.js version predates App Router (13.4+)."""
        parsed = BaseAssessor.parse_semver(next_version)
        if not parsed:
            return False
        major, minor, *_ = parsed
        return major < 13 or (major == 13 and minor < 4)

    def _detect_rsc_page_signals(
        self,
        base_url: str,
    ) -> tuple[bool, int | None]:
        """Fetch base page to infer RSC markers and React major from Flight payloads."""
        try:
            scan = scan_with_retry(
                base_url,
            )
        except Exception as exc:  # noqa: BLE001
            if isinstance(exc, (KeyboardInterrupt, SystemExit)):
                raise
            self.logger.debug("Failed to fetch base page for RSC markers at %s: %s", base_url, exc, exc_info=True)
            return False, None

        if not scan.get("ok"):
            return False, None

        body = scan.get("body") or scan.get("body_snippet") or ""
        is_rsc_framework = any(marker in body for marker in ("self.__next_f", "__next_f.push", '0:{"a":"$'))

        react_major = None
        if any(pattern in body for pattern in self.RSC_FLIGHT_PATTERNS_V19):
            react_major = 19
        elif any(pattern.search(body) for pattern in self.RSC_FLIGHT_PATTERNS_V18):
            react_major = 18

        return is_rsc_framework, react_major

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        react_major = self.get_react_major(detected_versions, detect_context)
        next_version = detected_versions.get("next_version")
        parsed_next = self.parse_semver(next_version) if next_version else None
        signals = (detect_context or {}).get("signals", {}) or {}
        tags = (detect_context or {}).get("tags", []) or []
        has_server_actions = signals.get("server_actions_enabled")
        react_version = detected_versions.get("react_version")
        react_version_confidence = self.get_version_confidence("react_version", detected_versions, detect_context)
        react_major_confidence = (detect_context or {}).get("react_major_confidence")
        next_version_confidence = self.get_version_confidence("next_version", detected_versions, detect_context)

        explicit_react_18 = False
        if react_version and react_version.startswith("18"):
            react_major = 18
            explicit_react_18 = True
            react_major_confidence = react_major_confidence or react_version_confidence or "high"
        elif parsed_next and parsed_next[0] == 13 and parsed_next[1] <= 4:
            # Next.js 13.4.x dev builds ship with React 18; avoid misclassifying as React 19
            if self.confidence_at_least(next_version_confidence, "medium"):
                react_major = 18
                explicit_react_18 = True
                react_major_confidence = react_major_confidence or next_version_confidence or "medium"
        elif parsed_next and parsed_next[0] <= 14:
            # Next.js 14.x uses React 18 in these lab fixtures; prefer safety over false negatives
            if self.confidence_at_least(next_version_confidence, "medium"):
                react_major = 18
                explicit_react_18 = True
                react_major_confidence = react_major_confidence or next_version_confidence or "medium"

        journal = get_current_journal() or PocJournal()
        journal.add_event(
            "context",
            "Starting Next.js evaluation",
            data={
                "react_major": react_major,
                "next_version": next_version,
                "server_actions_signal": has_server_actions,
                "detected_versions": detected_versions,
                "tags": tags,
            },
        )

        version_out_of_scope = self.is_next_version_out_of_scope(next_version)
        if version_out_of_scope:
            if self.confidence_at_least(next_version_confidence, "high"):
                reason = "Next.js version predates App Router (no RSC surface)"
                journal.add_decision(PocStatus.NOT_APPLICABLE, reason)
                return self.build_not_applicable_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=next_version_confidence or "high",
                )
            journal.add_event(
                "version-out-of-scope",
                "Low-confidence version match; running behavioral probes despite pre-App Router version hint",
                data={"next_version": next_version, "confidence": next_version_confidence},
            )

        # Infer RSC surface and React major from base page if not already known
        is_rsc_framework = bool(signals.get("rsc_endpoint_found") or signals.get("rsc_content_type") or signals.get("rsc_flight_payload"))
        if not is_rsc_framework and "nextjs-app-router" in tags:
            is_rsc_framework = True
        if react_major is None and parsed_next and parsed_next[0] < 15:
            if self.confidence_at_least(next_version_confidence, "medium"):
                react_major = 18
                react_major_confidence = react_major_confidence or next_version_confidence or "medium"

        if explicit_react_18 and self.confidence_at_least(react_major_confidence, "high"):
            journal.add_event(
                "react18-detected",
                "React 18 detected with high confidence - proceeding with probes to validate behavior",
                data={"react_major_confidence": react_major_confidence},
            )

        action_urls = (detect_context or {}).get("server_action_endpoints") if detect_context else None
        page_rsc_framework, react_major_from_flight = self._detect_rsc_page_signals(base_url)
        is_rsc_framework = is_rsc_framework or page_rsc_framework
        if react_major is None and react_major_from_flight is not None:
            react_major = react_major_from_flight
            react_major_confidence = react_major_confidence or "medium"
            signals["react_major_from_page"] = react_major_from_flight
            signals.setdefault("detected_react_major", react_major_from_flight)
            signals.setdefault("detected_react_major_confidence", "medium")
        journal.add_event(
            "page-scan",
            "Detected RSC markers from base page",
            data={
                "is_rsc_framework": is_rsc_framework,
                "react_major_from_flight": react_major_from_flight,
            },
        )

        if "nextjs-pages-router" in tags and "nextjs-app-router" not in tags:
            # Only short-circuit when we have a confident "no actions" signal.
            if has_server_actions is False:
                reason = "Next.js Pages Router detected (no RSC/Server Actions surface)"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason)
                return self.build_not_applicable_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=signals.get("server_actions_confidence") or signals.get("detection_confidence_level") or "medium",
                )

        # Actively probe server actions when unknown
        if has_server_actions is None:
            sa_probe = detect_server_actions(
                base_url,
            )
            if sa_probe.get("supported"):
                has_server_actions = True
            elif sa_probe.get("status_code") in (404, 405):
                has_server_actions = False
            journal.add_event(
                "server-actions-probe",
                "Probed for server action support because detection was unknown",
                data={
                    "supported": sa_probe.get("supported"),
                    "probe_confidence": sa_probe.get("confidence"),
                    "reason": sa_probe.get("reason"),
                },
            )

        # For Next.js, we assume an action surface whenever we see an RSC surface; probes
        # can validate behavior even if the framework responded with "action not found".
        if is_rsc_framework and has_server_actions is False:
            # Respect explicit 404/405 probes that said "no actions".
            has_server_actions = False

        # If we heuristically inferred React 18 but Next.js version is 16+ and no explicit
        # React version was detected, clear the inference to avoid false negatives.
        if react_major == 18 and parsed_next and parsed_next[0] >= 16 and not detected_versions.get("react_version"):
            react_major = None

        action_ids = generate_action_ids(3)
        probe_runner = ActionProbeRunner(
            base_url=base_url,
            action_probe=send_proto_probe,
            control_probe=send_control_probe,
            action_urls=list(action_urls) if action_urls else None,
            control_url=action_urls[0] if action_urls else None,
        )
        probe_results, control_result = probe_runner.run(action_ids)

        server_actions_expected = has_server_actions if has_server_actions is not None else is_rsc_framework

        analyzer = MultiActionAnalyzer(
            framework=self.framework_name,
            is_rsc_framework=is_rsc_framework,
            react_major=react_major,
            react_version=detected_versions.get("react_version"),
            server_actions_expected=server_actions_expected,
            server_actions_confidence=signals.get("server_actions_confidence"),
            react_major_confidence=react_major_confidence,
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = detected_versions
        if analysis["status"] in (PocStatus.VULNERABLE, PocStatus.LIKELY_VULNERABLE):
            confirmation = self._run_confirmation_round(
                base_url,
                analyzer=analyzer,
                action_urls=action_urls,
            )
            if confirmation:
                analysis.setdefault("raw_data", {})["confirmation"] = confirmation.get("raw_data")
                analysis["details"]["confirmation"] = {
                    "status": confirmation["status"],
                    "confidence": confirmation["details"].get("confidence"),
                }
                if confirmation["status"] == analysis["status"]:
                    analysis["details"]["confirmed"] = True
                    analysis["details"]["confidence"] = self._raise_confidence(analysis["details"].get("confidence"))
                else:
                    analysis["details"]["confirmed"] = False
                    analysis["details"]["confidence"] = self._lower_confidence(analysis["details"].get("confidence"))
                    analysis["status"] = PocStatus.LIKELY_VULNERABLE
                    analysis["details"]["reason"] = analysis["details"].get("reason") or "Vulnerability signal not consistent across confirmation round"
        return analysis

    def _run_confirmation_round(
        self,
        base_url: str,
        *,
        analyzer: MultiActionAnalyzer,
        action_urls: list[str] | None,
    ) -> dict[str, Any] | None:
        confirm_ids = generate_action_ids(2)
        try:
            probe_runner = ActionProbeRunner(
                base_url=base_url,
                action_probe=send_proto_probe,
                control_probe=send_control_probe,
                action_urls=list(action_urls) if action_urls else None,
                control_url=action_urls[0] if action_urls else None,
            )
            probe_results, control_result = probe_runner.run(confirm_ids)
        except Exception:
            return None

        confirm_journal = PocJournal()
        confirm_analyzer = replace(analyzer, journal=confirm_journal)
        return confirm_analyzer.analyze(
            probe_results,
            action_ids=confirm_ids,
            control_results=[control_result],
        )
