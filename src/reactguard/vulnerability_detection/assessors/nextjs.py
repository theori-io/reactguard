# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Next.js assessor for CVE-2025-55182."""

import logging
from dataclasses import replace
from typing import Any

from ...rsc.nextjs import infer_nextjs_rsc_signals_from_html
from ...framework_detection.signals.server_actions import detect_server_actions
from ...framework_detection.keys import (
    SIG_DETECTED_VERSIONS,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_INVOCATION_CONFIDENCE,
    SIG_REACT_MAJOR_FROM_PAGE,
    TAG_NEXTJS_APP_ROUTER,
    TAG_NEXTJS_PAGES_ROUTER,
)
from ...http import request_with_retries
from ...http.headers import normalize_headers
from ...http.heuristics import looks_like_html
from ...models.poc import PocStatus
from ...rsc.payloads import build_decode_payload_factories, build_nextjs_action_payload_factories
from ...rsc.heuristics import extract_error_digest, response_looks_like_flight
from ...rsc.runner import build_request_config, run_rsc_action_probes
from ...rsc.types import RscResponse
from ...utils import flatten_version_map, normalize_version_map, version_values
from ...utils.actions import generate_action_ids
from ...utils.version import update_version_pick
from ..interpreters.nextjs_interpreter import NextjsInterpreter
from ..journal import PocJournal, get_current_journal
from ..resolvers.nextjs import discover_nextjs_action_entrypoint_cached, nextjs_needs_valid_action_id
from ..snapshots import DetectContext
from ..surface import surface_from_detect_context
from .base import BaseAssessor


class NextJSAssessor(BaseAssessor):
    framework_name = "nextjs"

    logger = logging.getLogger(__name__)

    @staticmethod
    def is_next_version_out_of_scope(next_version: str | None) -> bool:
        """Return True if the Next.js version predates App Router (13.4+)."""
        parsed = BaseAssessor.parse_semver(next_version)
        if not parsed:
            return False
        major, minor, *_ = parsed
        return major < 13 or (major == 13 and minor < 4)

    def _detect_rsc_page_signals(
        self,
        base_url: str,
    ) -> tuple[bool, int | None]:
        """Fetch base page to infer RSC markers and React major from Flight payloads."""
        try:
            scan = request_with_retries(
                base_url,
            )
        except Exception as exc:  # noqa: BLE001
            if isinstance(exc, (KeyboardInterrupt, SystemExit)):
                raise
            self.logger.debug("Failed to fetch base page for RSC markers at %s: %s", base_url, exc, exc_info=True)
            return False, None

        if not scan.ok:
            return False, None

        body = scan.text or scan.body_snippet or ""
        return infer_nextjs_rsc_signals_from_html(body)

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: DetectContext | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        surface = surface_from_detect_context(detect_context)
        normalized_versions = normalize_version_map(detected_versions)
        react_major = self.get_react_major(normalized_versions, detect_context)
        next_pick = normalized_versions.get("next_version")
        next_version = str(next_pick.value) if next_pick else None
        signals = self._context_signals(detect_context)
        tags = self._context_tags(detect_context)
        has_server_actions = surface.invocation_surface
        react_pick = normalized_versions.get("react_version")
        react_version = str(react_pick.value) if react_pick else None
        react_version_confidence = self.get_version_confidence("react_version", normalized_versions, detect_context)
        react_major_confidence = detect_context.react_major_confidence if detect_context else None
        next_version_confidence = self.get_version_confidence("next_version", normalized_versions, detect_context)

        explicit_react_18 = False
        inferred_react_from_next = False
        parsed_next = self.parse_semver(next_version) if next_version else None
        if react_version and react_version.startswith("18"):
            react_major = 18
            explicit_react_18 = True
            react_major_confidence = react_major_confidence or react_version_confidence or "high"
        elif react_major is None and parsed_next and parsed_next[0] <= 14 and self.confidence_at_least(next_version_confidence, "medium"):
            # Low-confidence fallback: Next 13.4-14.x generally ship with React 18.
            react_major = 18
            inferred_react_from_next = True
            react_major_confidence = react_major_confidence or "low"
        # Prefer explicit React version detection and/or Flight payload markers; avoid high-confidence
        # assumptions solely from Next.js version.

        journal = get_current_journal() or PocJournal()
        if inferred_react_from_next:
            journal.add_event(
                "react-major-inferred",
                "Inferred React 18 from Next.js version (low confidence)",
                data={"next_version": next_version, "confidence": react_major_confidence},
            )
        journal.add_event(
            "context",
            "Starting Next.js evaluation",
            data={
                "react_major": react_major,
                "next_version": next_version,
                "invocation_signal": has_server_actions,
                "detected_versions": version_values(normalized_versions),
                "tags": tags,
            },
        )

        version_out_of_scope = self.is_next_version_out_of_scope(next_version)
        if version_out_of_scope:
            if self.confidence_at_least(next_version_confidence, "high"):
                reason = "Next.js version predates App Router (no RSC Flight / Server Actions)"
                journal.add_decision(PocStatus.NOT_APPLICABLE, reason, rule="next_version_out_of_scope")
                return self.build_not_applicable_result(
                    reason,
                    normalized_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=next_version_confidence or "high",
                )
            journal.add_event(
                "version-out-of-scope",
                "Low-confidence version match; running behavioral probes despite pre-App Router version hint",
                data={"next_version": next_version, "confidence": next_version_confidence},
            )

        # Infer RSC surface and React major from base page if not already known
        is_rsc_framework = surface.rsc_surface is True

        if explicit_react_18 and self.confidence_at_least(react_major_confidence, "high"):
            journal.add_event(
                "react18-detected",
                "React 18 detected with high confidence - proceeding with probes to validate behavior",
                data={"react_major_confidence": react_major_confidence},
            )

        action_urls = self._context_invocation_endpoints(detect_context) or None
        page_rsc_framework, react_major_from_flight = self._detect_rsc_page_signals(base_url)
        is_rsc_framework = is_rsc_framework or page_rsc_framework
        if react_major is None and react_major_from_flight is not None:
            react_major = react_major_from_flight
            react_major_confidence = react_major_confidence or "medium"
            signals[SIG_REACT_MAJOR_FROM_PAGE] = react_major_from_flight
            update_version_pick(
                normalized_versions,
                "react_major",
                react_major_from_flight,
                source="flight:page_html",
                confidence=react_major_confidence or "medium",
                prefer_semver=False,
            )
            signals[SIG_DETECTED_VERSIONS] = {key: pick.to_mapping() for key, pick in normalized_versions.items()}
            signals.update(flatten_version_map(normalized_versions, prefix="detected_"))
        journal.add_event(
            "page-scan",
            "Detected RSC markers from base page",
            data={
                "is_rsc_framework": is_rsc_framework,
                "react_major_from_flight": react_major_from_flight,
            },
        )

        if TAG_NEXTJS_PAGES_ROUTER in tags and TAG_NEXTJS_APP_ROUTER not in tags:
            # Only short-circuit when we have a confident "no actions" signal.
            if has_server_actions is False:
                reason = "Next.js Pages Router detected (no RSC Flight / Server Actions)"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason, rule="pages_router_no_actions")
                confidence = signals.get(SIG_INVOCATION_CONFIDENCE) or signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "medium"
                if confidence == "low":
                    confidence = "medium"
                return self.build_missing_surface_result(
                    reason,
                    normalized_versions,
                    surface_detected=False,
                    journal=journal,
                    confidence=confidence,
                )

        # Actively probe server actions when unknown
        if has_server_actions is None:
            sa_probe = detect_server_actions(
                base_url,
            )
            if sa_probe.supported and (
                bool(sa_probe.has_rsc_format) or self.confidence_at_least(str(sa_probe.confidence or ""), "medium")
            ):
                has_server_actions = True
            journal.add_event(
                "server-actions-probe",
                "Probed for server action support because detection was unknown",
                data={
                    "supported": sa_probe.supported,
                    "probe_confidence": sa_probe.confidence,
                    "reason": sa_probe.reason,
                    "has_rsc_format": sa_probe.has_rsc_format,
                },
            )

        # For Next.js, RSC markers are sufficient to *attempt* probing for Server Actions (endpoints that reach Flight protocol payload deserialization),
        # but RSC alone is not proof that Server Actions are enabled/reachable.
        # Preserve any explicit "no actions" signal; the probe results below will determine reachability.

        next_entrypoint = None
        wire_action_id: str | None = None

        # First pass: try random action IDs (cheap) on the candidate URL(s). Only escalate to bounded
        # crawl-based entrypoint discovery when results indicate Server Actions exist but require a valid
        # `Next-Action` header and/or a different page route.
        action_ids = generate_action_ids(3)
        control_action_id = action_ids[0] if action_ids else None

        probe_base_url = base_url
        effective_action_urls = list(action_urls) if action_urls else None
        effective_control_url = action_urls[0] if action_urls else None

        request_config = build_request_config(
            action_id_header="Next-Action",
        )

        proto_payload, control_payload = build_decode_payload_factories(marker="F")
        probe_results, control_result = run_rsc_action_probes(
            probe_base_url,
            action_ids,
            request_config=request_config,
            proto_payload=proto_payload,
            control_payload=control_payload,
            control_action_id=control_action_id,
            action_urls=effective_action_urls,
            control_url=effective_control_url,
        )

        def _looks_like_action_decode_surface(res: RscResponse) -> bool:
            headers_lower = normalize_headers(res.headers or {})
            content_type = headers_lower.get("content-type", "").lower()
            body = (res.text or res.body_snippet or "").lstrip()
            if response_looks_like_flight(headers_lower, body):
                return True
            if "application/json" in content_type:
                return True
            return bool(extract_error_digest(body))

        decode_surface_hit = any(_looks_like_action_decode_surface(r) for r in [*probe_results, control_result])
        def _looks_like_html_response(res: RscResponse) -> bool:
            headers_lower = normalize_headers(res.headers or {})
            body = (res.text or res.body_snippet or "")
            return looks_like_html(headers_lower, body)

        detection_confidence = signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)

        def _should_attempt_entrypoint_discovery(results: list[RscResponse]) -> bool:
            if not results:
                return False
            if not self.confidence_at_least(str(detection_confidence or ""), "medium"):
                return False
            for res in results:
                status = res.status_code
                if not _looks_like_html_response(res) and not (status and status >= 400):
                    return False
            return True

        probe_results_all = [*probe_results, control_result]
        should_discover = False
        if not decode_surface_hit and has_server_actions is not False:
            should_discover = bool(
                has_server_actions is True
                or nextjs_needs_valid_action_id(probe_results_all)
                or (is_rsc_framework and has_server_actions is None and _should_attempt_entrypoint_discovery(probe_results_all))
            )

        if should_discover:
            next_entrypoint = discover_nextjs_action_entrypoint_cached(base_url, journal=journal)
            if next_entrypoint:
                wire_action_id = next_entrypoint.action_id
                if has_server_actions is None:
                    has_server_actions = True
                journal.add_event(
                    "entrypoint-discovery",
                    "Resolved Next.js Server Actions entrypoint after initial random-ID probes",
                    data={
                        "entrypoint_url": next_entrypoint.entrypoint_url,
                        "wire_action_id_present": bool(wire_action_id),
                    },
                )

                action_ids = [wire_action_id] * 3
                control_action_id = wire_action_id
                probe_base_url = next_entrypoint.entrypoint_url or probe_base_url
                effective_action_urls = None
                effective_control_url = None

                probe_results, control_result = run_rsc_action_probes(
                    probe_base_url,
                    action_ids,
                    request_config=request_config,
                    proto_payload=proto_payload,
                    control_payload=control_payload,
                    control_action_id=control_action_id,
                    action_urls=effective_action_urls,
                    control_url=effective_control_url,
                )

        inferred_expected: bool | None = has_server_actions
        if inferred_expected is None:
            if wire_action_id:
                inferred_expected = True
            elif any(_looks_like_action_decode_surface(r) for r in [*probe_results, control_result]):
                inferred_expected = True
            else:
                inferred_expected = False

        invocation_expected = inferred_expected

        analyzer = NextjsInterpreter(
            is_rsc_framework=is_rsc_framework,
            react_major=react_major,
            react_version=react_version,
            invocation_expected=invocation_expected,
            invocation_confidence=signals.get(SIG_INVOCATION_CONFIDENCE),
            react_major_confidence=react_major_confidence,
            react_major_conflict=(detect_context.react_major_conflict if detect_context else None),
            react_major_conflict_confidence=(detect_context.react_major_conflict_confidence if detect_context else None),
            react_major_conflict_majors=(detect_context.react_major_conflict_majors if detect_context else None),
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = self._version_values_for_output(normalized_versions)
        if next_entrypoint:
            analysis["details"]["action_entrypoint_url"] = next_entrypoint.entrypoint_url
        if analysis["status"] in (PocStatus.VULNERABLE, PocStatus.LIKELY_VULNERABLE):
            confirmation = self._run_confirmation_round(
                probe_base_url,
                analyzer=analyzer,
                action_urls=effective_action_urls,
                action_id=None,
            )
            self.apply_confirmation(analysis, confirmation)
        return analysis

    def _run_confirmation_round(
        self,
        base_url: str,
        *,
        analyzer: NextjsInterpreter,
        action_urls: list[str] | None,
        action_id: str | None = None,
    ) -> dict[str, Any] | None:
        confirm_ids = [action_id] * 2 if action_id else generate_action_ids(2)
        try:
            request_config = build_request_config(
                action_id_header="Next-Action",
            )

            if action_id:
                server_ref_marker = "F"
                proto_payload, control_payload = build_nextjs_action_payload_factories(
                    server_ref_marker=server_ref_marker,
                )
                probe_results, control_result = run_rsc_action_probes(
                    base_url,
                    confirm_ids,
                    request_config=request_config,
                    proto_payload=proto_payload,
                    control_payload=control_payload,
                    action_urls=list(action_urls) if action_urls else None,
                    control_url=action_urls[0] if action_urls else None,
                    control_action_id=action_id,
                )
            else:
                proto_payload, control_payload = build_decode_payload_factories(marker="F")
                probe_results, control_result = run_rsc_action_probes(
                    base_url,
                    confirm_ids,
                    request_config=request_config,
                    proto_payload=proto_payload,
                    control_payload=control_payload,
                    action_urls=list(action_urls) if action_urls else None,
                    control_url=action_urls[0] if action_urls else None,
                    control_action_id=action_id,
                )
        except Exception as exc:
            if analyzer.journal is not None:
                analyzer.journal.add_event(
                    "confirmation-error",
                    "Confirmation probe round failed; proceeding without confirmation",
                    data={"error_type": exc.__class__.__name__, "error_message": str(exc)},
                )
            return None

        confirm_journal = PocJournal()
        confirm_analyzer = replace(analyzer, journal=confirm_journal)
        return confirm_analyzer.analyze(
            probe_results,
            action_ids=confirm_ids,
            control_results=[control_result],
        )
