"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Next.js assessor for CVE-2025-55182."""

import logging
import re
from dataclasses import replace
from typing import Any

from ...framework_detection.signals.server_actions import detect_server_actions
from ...http import request_with_retries
from ...models.poc import PocStatus
from ..interpreters.multi_action import MultiActionAnalyzer
from ..journal import PocJournal, get_current_journal
from ..probes import (
    ActionProbeRunner,
    discover_nextjs_action_entrypoint,
    generate_action_ids,
    send_control_probe,
    send_nextjs_control_probe,
    send_nextjs_proto_probe,
    send_nextjs_synthetic_control_probe,
    send_nextjs_synthetic_proto_probe,
    send_proto_probe,
)
from .base import BaseAssessor


class NextJSAssessor(BaseAssessor):
    framework_name = "nextjs"

    logger = logging.getLogger(__name__)

    # RSC Flight patterns to infer React major from HTML payloads
    RSC_FLIGHT_PATTERNS_V18 = (
        re.compile(r'^\s*0:\["\$","\$L', re.MULTILINE),
        re.compile(r'^\s*0:\[\\"\\$\\",\\"\$L', re.MULTILINE),
        re.compile(r'^\s*0:"\$L', re.MULTILINE),
        re.compile(r'^\s*0:\\"\\$L', re.MULTILINE),
    )
    RSC_FLIGHT_PATTERNS_V19 = (
        '0:[null,["$"',
        '0:[null,[\\"$\\"',
        '0:{"a":"$@',
        '0:{\\"a\\":\\"$@',
    )

    @staticmethod
    def is_next_version_out_of_scope(next_version: str | None) -> bool:
        """Return True if the Next.js version predates App Router (13.4+)."""
        parsed = BaseAssessor.parse_semver(next_version)
        if not parsed:
            return False
        major, minor, *_ = parsed
        return major < 13 or (major == 13 and minor < 4)

    def _detect_rsc_page_signals(
        self,
        base_url: str,
    ) -> tuple[bool, int | None]:
        """Fetch base page to infer RSC markers and React major from Flight payloads."""
        try:
            scan = request_with_retries(
                base_url,
            )
        except Exception as exc:  # noqa: BLE001
            if isinstance(exc, (KeyboardInterrupt, SystemExit)):
                raise
            self.logger.debug("Failed to fetch base page for RSC markers at %s: %s", base_url, exc, exc_info=True)
            return False, None

        if not scan.get("ok"):
            return False, None

        body = scan.get("body") or scan.get("body_snippet") or ""
        is_rsc_framework = any(marker in body for marker in ("self.__next_f", "__next_f.push", '0:{"a":"$'))

        react_major = None
        if any(pattern in body for pattern in self.RSC_FLIGHT_PATTERNS_V19):
            react_major = 19
        elif any(pattern.search(body) for pattern in self.RSC_FLIGHT_PATTERNS_V18):
            react_major = 18

        return is_rsc_framework, react_major

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        react_major = self.get_react_major(detected_versions, detect_context)
        next_version = detected_versions.get("next_version")
        signals = (detect_context or {}).get("signals", {}) or {}
        tags = (detect_context or {}).get("tags", []) or []
        has_server_actions = signals.get("server_actions_enabled")
        react_version = detected_versions.get("react_version")
        react_version_confidence = self.get_version_confidence("react_version", detected_versions, detect_context)
        react_major_confidence = (detect_context or {}).get("react_major_confidence")
        next_version_confidence = self.get_version_confidence("next_version", detected_versions, detect_context)

        explicit_react_18 = False
        if react_version and react_version.startswith("18"):
            react_major = 18
            explicit_react_18 = True
            react_major_confidence = react_major_confidence or react_version_confidence or "high"
        # Avoid inferring React major solely from Next.js version; use explicit React version
        # detection and/or Flight payload markers instead to prevent lab-tuned false negatives.

        journal = get_current_journal() or PocJournal()
        journal.add_event(
            "context",
            "Starting Next.js evaluation",
            data={
                "react_major": react_major,
                "next_version": next_version,
                "server_actions_signal": has_server_actions,
                "detected_versions": detected_versions,
                "tags": tags,
            },
        )

        version_out_of_scope = self.is_next_version_out_of_scope(next_version)
        if version_out_of_scope:
            if self.confidence_at_least(next_version_confidence, "high"):
                reason = "Next.js version predates App Router (no RSC surface)"
                journal.add_decision(PocStatus.NOT_APPLICABLE, reason)
                return self.build_not_applicable_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=next_version_confidence or "high",
                )
            journal.add_event(
                "version-out-of-scope",
                "Low-confidence version match; running behavioral probes despite pre-App Router version hint",
                data={"next_version": next_version, "confidence": next_version_confidence},
            )

        # Infer RSC surface and React major from base page if not already known
        is_rsc_framework = bool(signals.get("rsc_endpoint_found") or signals.get("rsc_content_type") or signals.get("rsc_flight_payload"))
        if not is_rsc_framework and "nextjs-app-router" in tags:
            is_rsc_framework = True

        if explicit_react_18 and self.confidence_at_least(react_major_confidence, "high"):
            journal.add_event(
                "react18-detected",
                "React 18 detected with high confidence - proceeding with probes to validate behavior",
                data={"react_major_confidence": react_major_confidence},
            )

        action_urls = (detect_context or {}).get("server_action_endpoints") if detect_context else None
        page_rsc_framework, react_major_from_flight = self._detect_rsc_page_signals(base_url)
        is_rsc_framework = is_rsc_framework or page_rsc_framework
        if react_major is None and react_major_from_flight is not None:
            react_major = react_major_from_flight
            react_major_confidence = react_major_confidence or "medium"
            signals["react_major_from_page"] = react_major_from_flight
            signals.setdefault("detected_react_major", react_major_from_flight)
            signals.setdefault("detected_react_major_confidence", "medium")
        journal.add_event(
            "page-scan",
            "Detected RSC markers from base page",
            data={
                "is_rsc_framework": is_rsc_framework,
                "react_major_from_flight": react_major_from_flight,
            },
        )

        if "nextjs-pages-router" in tags and "nextjs-app-router" not in tags:
            # Only short-circuit when we have a confident "no actions" signal.
            if has_server_actions is False:
                reason = "Next.js Pages Router detected (no RSC/Server Actions surface)"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason)
                return self.build_not_applicable_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=signals.get("server_actions_confidence") or signals.get("detection_confidence_level") or "medium",
                )

        # Actively probe server actions when unknown
        if has_server_actions is None:
            sa_probe = detect_server_actions(
                base_url,
            )
            if sa_probe.get("supported"):
                has_server_actions = True
            elif sa_probe.get("status_code") in (404, 405):
                has_server_actions = False
            journal.add_event(
                "server-actions-probe",
                "Probed for server action support because detection was unknown",
                data={
                    "supported": sa_probe.get("supported"),
                    "probe_confidence": sa_probe.get("confidence"),
                    "reason": sa_probe.get("reason"),
                },
            )

        # For Next.js, we assume an action surface whenever we see an RSC surface; probes
        # can validate behavior even if the framework responded with "action not found".
        if is_rsc_framework and has_server_actions is False:
            # Respect explicit 404/405 probes that said "no actions".
            has_server_actions = False

        next_entrypoint = None
        if is_rsc_framework or has_server_actions is True:
            try:
                next_entrypoint = discover_nextjs_action_entrypoint(
                    base_url,
                    timeout=2.0,
                    max_pages=6,
                    max_depth=2,
                )
            except Exception:
                next_entrypoint = None

        probe_base_url = next_entrypoint[0] if next_entrypoint else base_url
        probe_action_id = next_entrypoint[1] if next_entrypoint else None

        if probe_action_id:
            action_ids = [probe_action_id] * 3
            control_action_id = probe_action_id
        else:
            # Next.js action ids observed in the wild (and in our fixtures) are 42-hex tokens that
            # consistently start with "60". Using the wrong prefix causes Next.js to ignore the request
            # and return the normal HTML document (no decode surface reached).
            action_ids = generate_action_ids(3, prefix="60")
            control_action_id = action_ids[0] if action_ids else None

        effective_action_urls = None if probe_action_id else (list(action_urls) if action_urls else None)
        effective_control_url = None if probe_action_id else (action_urls[0] if action_urls else None)

        probe_func = send_proto_probe
        control_func = send_control_probe
        probe_kwargs: dict[str, Any] | None = None
        control_kwargs: dict[str, Any] | None = None

        if probe_action_id:
            # Prefer Next.js-compatible probes that keep typical two-arg actions successful so we can
            # attribute failures to decode behavior rather than app-level argument shape errors.
            # NOTE: Next.js' server-action decode surfaces are not reliably fingerprintable via the `$h`
            # marker probe across builds (prod often returns digest-only errors), and choosing `$h` here
            # causes false "safe" results on known-vulnerable fixtures. Use `$F` for the React2Shell probes.
            server_ref_marker = "F"
            http_client = (detect_context or {}).get("http_client")

            probe_func = send_nextjs_proto_probe
            control_func = send_nextjs_control_probe
            probe_kwargs = {"server_ref_marker": server_ref_marker}
            control_kwargs = {"server_ref_marker": server_ref_marker}
        elif is_rsc_framework:
            # RSC-only Next.js pages may still be exploitable even without a discoverable action id.
            # Use a synthetic probe variant that forces Next.js into the Server Actions request path
            # via `$ACTION_*` fields, so we can observe decode behavior without invoking real actions.
            server_ref_marker = "F"
            probe_func = send_nextjs_synthetic_proto_probe
            control_func = send_nextjs_synthetic_control_probe
            probe_kwargs = {"server_ref_marker": server_ref_marker}
            control_kwargs = {"server_ref_marker": server_ref_marker}
            effective_action_urls = None
            effective_control_url = None

        probe_runner = ActionProbeRunner(
            base_url=probe_base_url,
            action_probe=probe_func,
            control_probe=control_func,
            action_urls=effective_action_urls,
            control_url=effective_control_url,
            probe_kwargs=probe_kwargs,
            control_kwargs=control_kwargs,
        )
        probe_results, control_result = probe_runner.run(action_ids, control_action_id=control_action_id)

        server_actions_expected = True if probe_action_id else (has_server_actions if has_server_actions is not None else is_rsc_framework)

        analyzer = MultiActionAnalyzer(
            framework=self.framework_name,
            is_rsc_framework=is_rsc_framework,
            react_major=react_major,
            react_version=detected_versions.get("react_version"),
            server_actions_expected=server_actions_expected,
            server_actions_confidence=signals.get("server_actions_confidence"),
            react_major_confidence=react_major_confidence,
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = detected_versions
        if probe_action_id:
            analysis["details"]["action_entrypoint_url"] = probe_base_url
            analysis["details"]["action_id"] = probe_action_id
        if analysis["status"] in (PocStatus.VULNERABLE, PocStatus.LIKELY_VULNERABLE):
            confirmation = self._run_confirmation_round(
                probe_base_url,
                analyzer=analyzer,
                action_urls=effective_action_urls,
                action_id=probe_action_id,
            )
            if confirmation:
                analysis.setdefault("raw_data", {})["confirmation"] = confirmation.get("raw_data")
                analysis["details"]["confirmation"] = {
                    "status": confirmation["status"],
                    "confidence": confirmation["details"].get("confidence"),
                }
                if confirmation["status"] == analysis["status"]:
                    analysis["details"]["confirmed"] = True
                    analysis["details"]["confidence"] = self._raise_confidence(analysis["details"].get("confidence"))
                else:
                    analysis["details"]["confirmed"] = False
                    analysis["details"]["confidence"] = self._lower_confidence(analysis["details"].get("confidence"))
                    analysis["status"] = PocStatus.LIKELY_VULNERABLE
                    analysis["details"]["reason"] = analysis["details"].get("reason") or "Vulnerability signal not consistent across confirmation round"
        return analysis

    def _run_confirmation_round(
        self,
        base_url: str,
        *,
        analyzer: MultiActionAnalyzer,
        action_urls: list[str] | None,
        action_id: str | None = None,
    ) -> dict[str, Any] | None:
        confirm_ids = [action_id] * 2 if action_id else generate_action_ids(2, prefix="60" if analyzer.is_rsc_framework else "40")
        confirm_control_id = action_id or (confirm_ids[0] if confirm_ids else None)
        try:
            probe_func = send_proto_probe
            control_func = send_control_probe
            probe_kwargs: dict[str, Any] | None = None
            control_kwargs: dict[str, Any] | None = None

            if action_id:
                server_ref_marker = "F"

                probe_func = send_nextjs_proto_probe
                control_func = send_nextjs_control_probe
                probe_kwargs = {"server_ref_marker": server_ref_marker}
                control_kwargs = {"server_ref_marker": server_ref_marker}
            elif analyzer.is_rsc_framework:
                server_ref_marker = "F"
                probe_func = send_nextjs_synthetic_proto_probe
                control_func = send_nextjs_synthetic_control_probe
                probe_kwargs = {"server_ref_marker": server_ref_marker}
                control_kwargs = {"server_ref_marker": server_ref_marker}
                action_urls = None

            probe_runner = ActionProbeRunner(
                base_url=base_url,
                action_probe=probe_func,
                control_probe=control_func,
                action_urls=list(action_urls) if action_urls else None,
                control_url=action_urls[0] if action_urls else None,
                probe_kwargs=probe_kwargs,
                control_kwargs=control_kwargs,
            )
            probe_results, control_result = probe_runner.run(confirm_ids, control_action_id=confirm_control_id)
        except Exception:
            return None

        confirm_journal = PocJournal()
        confirm_analyzer = replace(analyzer, journal=confirm_journal)
        return confirm_analyzer.analyze(
            probe_results,
            action_ids=confirm_ids,
            control_results=[control_result],
        )
