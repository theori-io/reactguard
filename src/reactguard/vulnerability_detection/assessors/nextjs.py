"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Next.js assessor for CVE-2025-55182."""

import logging
from dataclasses import replace
from typing import Any

from ...framework_detection.constants import (
    NEXTJS_RSC_FLIGHT_PATTERN_V18_HTML,
    NEXTJS_RSC_FLIGHT_PATTERN_V18_HTML_ESCAPED,
    NEXTJS_RSC_FLIGHT_PATTERN_V18_SIMPLE,
    NEXTJS_RSC_FLIGHT_PATTERN_V18_SIMPLE_ESCAPED,
    NEXTJS_RSC_FLIGHT_PATTERN_V19_HTML,
    NEXTJS_RSC_FLIGHT_PATTERN_V19_HTML_ESCAPED,
    NEXTJS_RSC_FLIGHT_PATTERN_V19_OBJECT,
    NEXTJS_RSC_FLIGHT_PATTERN_V19_OBJECT_ESCAPED,
)
from ...framework_detection.signals.server_actions import detect_server_actions
from ...http import request_with_retries
from ...models.poc import PocStatus
from ...rsc.payloads import RscReference, build_multipart_decode_payload, build_nextjs_action_multipart_payload, build_random_safe_prop
from ...rsc.runner import run_rsc_action_probes
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_ids
from ..interpreters.nextjs_interpreter import NextjsInterpreter
from ..journal import PocJournal, get_current_journal
from ..probes.rsc_patch_fingerprint_probe import discover_nextjs_action_entrypoint
from .base import BaseAssessor


class NextJSAssessor(BaseAssessor):
    framework_name = "nextjs"

    logger = logging.getLogger(__name__)

    # RSC Flight patterns to infer React major from HTML payloads
    RSC_FLIGHT_PATTERNS_V18 = (
        NEXTJS_RSC_FLIGHT_PATTERN_V18_HTML,
        NEXTJS_RSC_FLIGHT_PATTERN_V18_HTML_ESCAPED,
        NEXTJS_RSC_FLIGHT_PATTERN_V18_SIMPLE,
        NEXTJS_RSC_FLIGHT_PATTERN_V18_SIMPLE_ESCAPED,
    )
    RSC_FLIGHT_PATTERNS_V19 = (
        NEXTJS_RSC_FLIGHT_PATTERN_V19_HTML,
        NEXTJS_RSC_FLIGHT_PATTERN_V19_HTML_ESCAPED,
        NEXTJS_RSC_FLIGHT_PATTERN_V19_OBJECT,
        NEXTJS_RSC_FLIGHT_PATTERN_V19_OBJECT_ESCAPED,
    )

    @staticmethod
    def is_next_version_out_of_scope(next_version: str | None) -> bool:
        """Return True if the Next.js version predates App Router (13.4+)."""
        parsed = BaseAssessor.parse_semver(next_version)
        if not parsed:
            return False
        major, minor, *_ = parsed
        return major < 13 or (major == 13 and minor < 4)

    def _detect_rsc_page_signals(
        self,
        base_url: str,
    ) -> tuple[bool, int | None]:
        """Fetch base page to infer RSC markers and React major from Flight payloads."""
        try:
            scan = request_with_retries(
                base_url,
            )
        except Exception as exc:  # noqa: BLE001
            if isinstance(exc, (KeyboardInterrupt, SystemExit)):
                raise
            self.logger.debug("Failed to fetch base page for RSC markers at %s: %s", base_url, exc, exc_info=True)
            return False, None

        if not scan.get("ok"):
            return False, None

        body = scan.get("body") or scan.get("body_snippet") or ""
        is_rsc_framework = any(marker in body for marker in ("self.__next_f", "__next_f.push", '0:{"a":"$'))

        react_major = None
        if any(pattern in body for pattern in self.RSC_FLIGHT_PATTERNS_V19):
            react_major = 19
        elif any(pattern.search(body) for pattern in self.RSC_FLIGHT_PATTERNS_V18):
            react_major = 18

        return is_rsc_framework, react_major

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        react_major = self.get_react_major(detected_versions, detect_context)
        next_version = detected_versions.get("next_version")
        signals = (detect_context or {}).get("signals", {}) or {}
        tags = (detect_context or {}).get("tags", []) or []
        has_server_actions = signals.get("server_actions_enabled")
        react_version = detected_versions.get("react_version")
        react_version_confidence = self.get_version_confidence("react_version", detected_versions, detect_context)
        react_major_confidence = (detect_context or {}).get("react_major_confidence")
        next_version_confidence = self.get_version_confidence("next_version", detected_versions, detect_context)

        explicit_react_18 = False
        if react_version and react_version.startswith("18"):
            react_major = 18
            explicit_react_18 = True
            react_major_confidence = react_major_confidence or react_version_confidence or "high"
        # Avoid inferring React major solely from Next.js version; prefer explicit React version
        # detection and/or Flight payload markers to reduce false negatives.

        journal = get_current_journal() or PocJournal()
        journal.add_event(
            "context",
            "Starting Next.js evaluation",
            data={
                "react_major": react_major,
                "next_version": next_version,
                "server_actions_signal": has_server_actions,
                "detected_versions": detected_versions,
                "tags": tags,
            },
        )

        version_out_of_scope = self.is_next_version_out_of_scope(next_version)
        if version_out_of_scope:
            if self.confidence_at_least(next_version_confidence, "high"):
                reason = "Next.js version predates App Router (no RSC or Server Actions surface)"
                journal.add_decision(PocStatus.NOT_APPLICABLE, reason)
                return self.build_not_applicable_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    not_affected=True,
                    journal=journal,
                    confidence=next_version_confidence or "high",
                )
            journal.add_event(
                "version-out-of-scope",
                "Low-confidence version match; running behavioral probes despite pre-App Router version hint",
                data={"next_version": next_version, "confidence": next_version_confidence},
            )

        # Infer RSC surface and React major from base page if not already known
        is_rsc_framework = bool(signals.get("rsc_endpoint_found") or signals.get("rsc_content_type") or signals.get("rsc_flight_payload"))
        if not is_rsc_framework and "nextjs-app-router" in tags:
            is_rsc_framework = True

        if explicit_react_18 and self.confidence_at_least(react_major_confidence, "high"):
            journal.add_event(
                "react18-detected",
                "React 18 detected with high confidence - proceeding with probes to validate behavior",
                data={"react_major_confidence": react_major_confidence},
            )

        action_urls = (detect_context or {}).get("server_action_endpoints") if detect_context else None
        page_rsc_framework, react_major_from_flight = self._detect_rsc_page_signals(base_url)
        is_rsc_framework = is_rsc_framework or page_rsc_framework
        if react_major is None and react_major_from_flight is not None:
            react_major = react_major_from_flight
            react_major_confidence = react_major_confidence or "medium"
            signals["react_major_from_page"] = react_major_from_flight
            signals.setdefault("detected_react_major", react_major_from_flight)
            signals.setdefault("detected_react_major_confidence", "medium")
        journal.add_event(
            "page-scan",
            "Detected RSC markers from base page",
            data={
                "is_rsc_framework": is_rsc_framework,
                "react_major_from_flight": react_major_from_flight,
            },
        )

        if "nextjs-pages-router" in tags and "nextjs-app-router" not in tags:
            # Only short-circuit when we have a confident "no actions" signal.
            if has_server_actions is False:
                reason = "Next.js Pages Router detected (no RSC or Server Actions surface)"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason)
                return self.build_missing_surface_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    journal=journal,
                    confidence=signals.get("server_actions_confidence") or signals.get("detection_confidence_level") or "medium",
                )

        # Actively probe server actions when unknown
        if has_server_actions is None:
            sa_probe = detect_server_actions(
                base_url,
            )
            if sa_probe.get("supported") and (
                bool(sa_probe.get("has_rsc_format")) or self.confidence_at_least(str(sa_probe.get("confidence") or ""), "medium")
            ):
                has_server_actions = True
            journal.add_event(
                "server-actions-probe",
                "Probed for server action support because detection was unknown",
                data={
                    "supported": sa_probe.get("supported"),
                    "probe_confidence": sa_probe.get("confidence"),
                    "reason": sa_probe.get("reason"),
                    "has_rsc_format": sa_probe.get("has_rsc_format"),
                },
            )

        # For Next.js, we assume an action surface whenever we see an RSC surface; probes
        # can validate behavior even if the framework responded with "action not found".
        if is_rsc_framework and has_server_actions is False:
            # Respect explicit 404/405 probes that said "no actions".
            has_server_actions = False

        next_entrypoint = None
        if is_rsc_framework or has_server_actions is True:
            try:
                next_entrypoint = discover_nextjs_action_entrypoint(base_url)
            except Exception:
                next_entrypoint = None

        wire_action_id = next_entrypoint[1] if next_entrypoint else None
        if wire_action_id and has_server_actions is None:
            # A concrete action ID in the app HTML/JS is strong evidence that Server Actions are enabled.
            has_server_actions = True

        # Use a discovered, valid action ID for all probes to ensure we reach the Server Actions surface.
        action_ids = [wire_action_id] * 3 if wire_action_id else generate_action_ids(3)
        control_action_id = wire_action_id or (action_ids[0] if action_ids else None)

        probe_base_url = next_entrypoint[0] if next_entrypoint else base_url
        effective_action_urls = None if next_entrypoint else (list(action_urls) if action_urls else None)
        effective_control_url = None if next_entrypoint else (action_urls[0] if action_urls else None)

        request_config = RscRequestConfig(
            method="POST",
            base_headers={"Accept": "text/x-component"},
            action_id_header="Next-Action",
        )

        def _proto_payload(_action_id: str):
            return build_multipart_decode_payload(RscReference(slot=1, root="x", prop="__proto__", marker="F"))

        def _control_payload(_action_id: str):
            safe_prop = build_random_safe_prop()
            return build_multipart_decode_payload(RscReference(slot=1, root="x", prop=safe_prop, marker="F"))

        probe_results, control_result = run_rsc_action_probes(
            probe_base_url,
            action_ids,
            request_config=request_config,
            proto_payload=_proto_payload,
            control_payload=_control_payload,
            control_action_id=control_action_id,
            action_urls=effective_action_urls,
            control_url=effective_control_url,
        )

        def _looks_like_action_decode_surface(res: dict[str, Any]) -> bool:
            headers_lower = {str(k).lower(): str(v) for k, v in (res.get("headers") or {}).items()}
            content_type = headers_lower.get("content-type", "").lower()
            if "text/x-component" in content_type or "application/json" in content_type:
                return True
            body = (res.get("body") or res.get("body_snippet") or "").lstrip()
            return bool(body.startswith("0:") or '"digest"' in body.lower())

        inferred_expected: bool | None = has_server_actions
        if inferred_expected is None:
            if wire_action_id:
                inferred_expected = True
            elif any(_looks_like_action_decode_surface(r) for r in [*probe_results, control_result]):
                inferred_expected = True
            else:
                inferred_expected = False

        server_actions_expected = inferred_expected

        analyzer = NextjsInterpreter(
            is_rsc_framework=is_rsc_framework,
            react_major=react_major,
            react_version=detected_versions.get("react_version"),
            server_actions_expected=server_actions_expected,
            server_actions_confidence=signals.get("server_actions_confidence"),
            react_major_confidence=react_major_confidence,
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = detected_versions
        if next_entrypoint:
            analysis["details"]["action_entrypoint_url"] = probe_base_url
        if analysis["status"] in (PocStatus.VULNERABLE, PocStatus.LIKELY_VULNERABLE):
            confirmation = self._run_confirmation_round(
                probe_base_url,
                analyzer=analyzer,
                action_urls=effective_action_urls,
                action_id=None,
            )
            self.apply_confirmation(analysis, confirmation)
        return analysis

    def _run_confirmation_round(
        self,
        base_url: str,
        *,
        analyzer: NextjsInterpreter,
        action_urls: list[str] | None,
        action_id: str | None = None,
    ) -> dict[str, Any] | None:
        confirm_ids = [action_id] * 2 if action_id else generate_action_ids(2)
        try:
            request_config = RscRequestConfig(
                method="POST",
                base_headers={"Accept": "text/x-component"},
                action_id_header="Next-Action",
            )

            if action_id:
                server_ref_marker = "F"

                def _proto_payload(_action_id: str):
                    return build_nextjs_action_multipart_payload(
                        target_prop="__proto__",
                        server_ref_marker=server_ref_marker,
                    )

                def _control_payload(_action_id: str):
                    safe_prop = build_random_safe_prop()
                    return build_nextjs_action_multipart_payload(
                        target_prop=safe_prop,
                        server_ref_marker=server_ref_marker,
                    )

            else:

                def _proto_payload(_action_id: str):
                    return build_multipart_decode_payload(RscReference(slot=1, root="x", prop="__proto__", marker="F"))

                def _control_payload(_action_id: str):
                    safe_prop = build_random_safe_prop()
                    return build_multipart_decode_payload(RscReference(slot=1, root="x", prop=safe_prop, marker="F"))

            probe_results, control_result = run_rsc_action_probes(
                base_url,
                confirm_ids,
                request_config=request_config,
                proto_payload=_proto_payload,
                control_payload=_control_payload,
                action_urls=list(action_urls) if action_urls else None,
                control_url=action_urls[0] if action_urls else None,
                control_action_id=action_id,
            )
        except Exception:
            return None

        confirm_journal = PocJournal()
        confirm_analyzer = replace(analyzer, journal=confirm_journal)
        return confirm_analyzer.analyze(
            probe_results,
            action_ids=confirm_ids,
            control_results=[control_result],
        )
