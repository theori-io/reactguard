# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Base assessor with shared helpers."""

from abc import ABC, abstractmethod
from typing import Any

from ...models.poc import PocStatus
from ...utils.confidence import confidence_at_least as _confidence_at_least
from ...utils.confidence import lower_confidence as _lower_confidence
from ...utils.confidence import raise_confidence as _raise_confidence
from ...utils.context import get_scan_context
from ...utils.version import compare_semver as _compare_semver
from ...utils.version import parse_semver as _parse_semver
from ..journal import PocJournal, get_current_journal

CVE_ID = "CVE-2025-55182"


class BaseAssessor(ABC):
    framework_name: str = "base"
    cve_id: str = CVE_ID

    @staticmethod
    def parse_semver(version: str | None) -> tuple[int, int, int, str] | None:
        parsed = _parse_semver(version)
        return parsed.to_tuple() if parsed else None

    @staticmethod
    def compare_semver(a: str | None, b: str | None) -> int | None:
        return _compare_semver(a, b)

    @staticmethod
    def _ambient_detect_context() -> dict | None:
        """Fetch ambient detect_context from ScanContext.extra when available."""
        extra = get_scan_context().extra or {}
        ambient = extra.get("detect_context")
        return ambient if isinstance(ambient, dict) else None

    def _resolve_detect_context(self, detect_context: dict | None) -> dict | None:
        return detect_context or self._ambient_detect_context()

    def get_react_major(self, detected_versions: dict[str, Any], detect_context: dict | None = None) -> int | None:
        detect_context = self._resolve_detect_context(detect_context)
        react_major = None
        if detect_context and detect_context.get("react_major") is not None:
            react_major = detect_context.get("react_major")
        elif detected_versions.get("react_major") is not None:
            react_major = detected_versions.get("react_major")
        elif detected_versions.get("rsc_runtime_version"):
            parsed = self.parse_semver(str(detected_versions.get("rsc_runtime_version")))
            if parsed:
                react_major = parsed[0]
        elif detected_versions.get("react_version"):
            parsed = self.parse_semver(detected_versions.get("react_version"))
            if parsed:
                react_major = parsed[0]
        return react_major

    def get_version_confidence(
        self,
        version_key: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> str | None:
        """
        Resolve the best confidence label for a given version key (e.g., ``react_version``).
        """
        detect_context = self._resolve_detect_context(detect_context)
        signals = (detect_context or {}).get("signals", {}) or {}
        if detect_context and detect_context.get(f"{version_key}_confidence"):
            return detect_context.get(f"{version_key}_confidence")
        if signals.get(f"detected_{version_key}_confidence"):
            return signals.get(f"detected_{version_key}_confidence")
        if detected_versions.get(f"{version_key}_confidence"):
            return detected_versions.get(f"{version_key}_confidence")
        return None

    def confidence_at_least(self, confidence: str | None, threshold: str) -> bool:
        """Helper to compare confidence labels."""
        return _confidence_at_least(confidence, threshold)

    def _raise_confidence(self, confidence: str | None) -> str:
        """Increment confidence label by one step, capping at high."""
        return _raise_confidence(confidence)

    def _lower_confidence(self, confidence: str | None) -> str:
        """Decrement confidence label by one step, bottoming out at none."""
        return _lower_confidence(confidence)

    def apply_confirmation(
        self,
        analysis: dict[str, Any],
        confirmation: dict[str, Any] | None,
        *,
        mismatch_status: PocStatus = PocStatus.LIKELY_VULNERABLE,
    ) -> dict[str, Any]:
        """
        Merge a confirmation-round analysis into the primary analysis dict.

        This standardizes the "confirmed" bookkeeping used by multi-action assessors.
        """
        if not confirmation:
            return analysis

        analysis.setdefault("raw_data", {})["confirmation"] = confirmation.get("raw_data")
        details = analysis.setdefault("details", {})
        confirmation_details = confirmation.get("details") or {}
        if not isinstance(confirmation_details, dict):
            confirmation_details = {}

        details["confirmation"] = {
            "status": confirmation.get("status"),
            "confidence": confirmation_details.get("confidence"),
        }

        if confirmation.get("status") == analysis.get("status"):
            details["confirmed"] = True
            details["confidence"] = self._raise_confidence(details.get("confidence"))
        else:
            details["confirmed"] = False
            details["confidence"] = self._lower_confidence(details.get("confidence"))
            analysis["status"] = mismatch_status
            details["reason"] = details.get("reason") or "Vulnerability signal not consistent between initial and confirmation probes"

        return analysis

    def build_not_applicable_result(
        self,
        reason: str,
        detected_versions: dict[str, Any],
        surface_detected: bool = False,
        not_affected: bool = False,
        journal: PocJournal | None = None,
        confidence: str = "high",
        **extra_details,
    ) -> dict[str, Any]:
        effective_journal = journal or get_current_journal() or PocJournal()
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "surface_detected": surface_detected,
            "not_affected": not_affected,
            "detected_versions": detected_versions,
        }
        details.update(extra_details)
        return {
            # Mapping contract:
            # - "not affected" is represented via NOT_APPLICABLE (+ not_affected=True)
            # - "missing surface" uses NOT_VULNERABLE (see build_missing_surface_result)
            "status": PocStatus.NOT_APPLICABLE,
            "details": details,
            "raw_data": {"journal": effective_journal.to_list()},
        }

    def build_missing_surface_result(
        self,
        reason: str,
        detected_versions: dict[str, Any],
        *,
        surface_detected: bool = False,
        journal: PocJournal | None = None,
        confidence: str = "medium",
        **extra_details,
    ) -> dict[str, Any]:
        """
        Build a standardized NOT_VULNERABLE result for "missing attack surface" conclusions.

        This is distinct from "not affected" (which maps to NOT_APPLICABLE).
        """
        effective_journal = journal or get_current_journal() or PocJournal()
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "surface_detected": surface_detected,
            "detected_versions": detected_versions,
        }
        details.update(extra_details)
        return {
            "status": PocStatus.NOT_VULNERABLE,
            "details": details,
            "raw_data": {"journal": effective_journal.to_list()},
        }

    def build_inconclusive_result(
        self,
        reason: str,
        detected_versions: dict[str, Any],
        error_message: str | None = None,
        error_type: str | None = None,
        journal: PocJournal | None = None,
        confidence: str = "low",
        **extra_details,
    ) -> dict[str, Any]:
        effective_journal = journal or get_current_journal() or PocJournal()
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "error_message": error_message,
            "error_type": error_type,
            "detected_versions": detected_versions,
        }
        details.update(extra_details)
        return {
            "status": PocStatus.INCONCLUSIVE,
            "details": details,
            "raw_data": {"journal": effective_journal.to_list()},
        }

    @abstractmethod
    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]: ...
