# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Base assessor with shared helpers."""

from abc import ABC, abstractmethod
from collections.abc import Mapping
from typing import Any

from ...models.poc import PocStatus
from ...utils.confidence import confidence_at_least as _confidence_at_least
from ...utils.confidence import lower_confidence as _lower_confidence
from ...utils.confidence import raise_confidence as _raise_confidence
from ...utils.context import get_scan_context
from ...utils.version import compare_semver as _compare_semver
from ...utils.version import normalize_version_map, parse_semver as _parse_semver, version_values
from ..journal import PocJournal, get_current_journal
from ..surface import missing_surface_status
from ..snapshots import DetectContext

CVE_ID = "CVE-2025-55182"


class BaseAssessor(ABC):
    framework_name: str = "base"
    cve_id: str = CVE_ID

    @staticmethod
    def parse_semver(version: str | None) -> tuple[int, int, int, str] | None:
        parsed = _parse_semver(version)
        return parsed.to_tuple() if parsed else None

    @staticmethod
    def compare_semver(a: str | None, b: str | None) -> int | None:
        return _compare_semver(a, b)

    @staticmethod
    def _ambient_detect_context() -> DetectContext | None:
        """Fetch ambient detect_context from ScanContext.extra when available."""
        extra = get_scan_context().extra
        if not isinstance(extra, Mapping):
            return None
        ambient = extra.get("detect_context")
        return ambient if isinstance(ambient, DetectContext) else None

    def _resolve_detect_context(self, detect_context: DetectContext | None) -> DetectContext | None:
        return detect_context or self._ambient_detect_context()

    @staticmethod
    def _context_signals(detect_context: DetectContext | None) -> dict[str, Any]:
        if not detect_context:
            return {}
        return detect_context.signals if isinstance(detect_context.signals, dict) else {}

    @staticmethod
    def _context_tags(detect_context: DetectContext | None) -> list[str]:
        if not detect_context:
            return []
        return detect_context.tags if isinstance(detect_context.tags, list) else []

    @staticmethod
    def _context_invocation_endpoints(detect_context: DetectContext | None) -> list[str]:
        if not detect_context:
            return []
        return detect_context.invocation_endpoints if isinstance(detect_context.invocation_endpoints, list) else []

    def get_react_major(self, detected_versions: Mapping[str, Any], detect_context: DetectContext | None = None) -> int | None:
        detect_context = self._resolve_detect_context(detect_context)
        react_major = None
        if detect_context and detect_context.react_major is not None:
            react_major = detect_context.react_major
        else:
            normalized_versions = normalize_version_map(detected_versions)
            major_pick = normalized_versions.get("react_major")
            if major_pick is not None:
                try:
                    react_major = int(major_pick.value)
                except (TypeError, ValueError):
                    react_major = None
            elif normalized_versions.get("rsc_runtime_version"):
                parsed = self.parse_semver(str(normalized_versions.get("rsc_runtime_version").value))
                if parsed:
                    react_major = parsed[0]
            elif normalized_versions.get("react_version"):
                parsed = self.parse_semver(str(normalized_versions.get("react_version").value))
                if parsed:
                    react_major = parsed[0]
        return react_major

    def get_version_confidence(
        self,
        version_key: str,
        detected_versions: Mapping[str, Any],
        detect_context: DetectContext | None = None,
    ) -> str | None:
        """
        Resolve the best confidence label for a given version key (e.g., ``react_version``).
        """
        detect_context = self._resolve_detect_context(detect_context)
        if detect_context:
            context_pick = detect_context.detected_versions.get(version_key)
            if context_pick and context_pick.confidence:
                return context_pick.confidence
        normalized_versions = normalize_version_map(detected_versions)
        pick = normalized_versions.get(version_key)
        if pick and pick.confidence:
            return pick.confidence
        return None

    @staticmethod
    def _version_values_for_output(detected_versions: Mapping[str, Any]) -> dict[str, Any]:
        return version_values(normalize_version_map(detected_versions))

    def confidence_at_least(self, confidence: str | None, threshold: str) -> bool:
        """Helper to compare confidence labels."""
        return _confidence_at_least(confidence, threshold)

    def _raise_confidence(self, confidence: str | None) -> str:
        """Increment confidence label by one step, capping at high."""
        return _raise_confidence(confidence)

    def _lower_confidence(self, confidence: str | None) -> str:
        """Decrement confidence label by one step, bottoming out at none."""
        return _lower_confidence(confidence)

    def apply_confirmation(
        self,
        analysis: dict[str, Any],
        confirmation: dict[str, Any] | None,
        *,
        mismatch_status: PocStatus = PocStatus.LIKELY_VULNERABLE,
    ) -> dict[str, Any]:
        """
        Merge a confirmation-round analysis into the primary analysis dict.

        This standardizes the "confirmed" bookkeeping used by multi-action assessors.
        """
        if not confirmation:
            return analysis

        analysis.setdefault("raw_data", {})["confirmation"] = confirmation.get("raw_data")
        details = analysis.setdefault("details", {})
        confirmation_details = confirmation.get("details") or {}
        if not isinstance(confirmation_details, dict):
            confirmation_details = {}

        details["confirmation"] = {
            "status": confirmation.get("status"),
            "confidence": confirmation_details.get("confidence"),
        }

        if confirmation.get("status") == analysis.get("status"):
            details["confirmed"] = True
            details["confidence"] = self._raise_confidence(details.get("confidence"))
        else:
            details["confirmed"] = False
            details["confidence"] = self._lower_confidence(details.get("confidence"))
            analysis["status"] = mismatch_status
            details["reason"] = details.get("reason") or "Vulnerability signal not consistent between initial and confirmation probes"

        return analysis

    def build_not_applicable_result(
        self,
        reason: str,
        detected_versions: Mapping[str, Any],
        surface_detected: bool = False,
        not_affected: bool = False,
        journal: PocJournal | None = None,
        confidence: str = "high",
        **extra_details,
    ) -> dict[str, Any]:
        effective_journal = journal or get_current_journal() or PocJournal()
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "surface_detected": surface_detected,
            "not_affected": not_affected,
            "detected_versions": self._version_values_for_output(detected_versions),
        }
        details.update(extra_details)
        return {
            # Mapping contract:
            # - "not affected" is represented via NOT_APPLICABLE (+ not_affected=True)
            # - "missing surface" uses NOT_VULNERABLE (see build_missing_surface_result)
            "status": PocStatus.NOT_APPLICABLE,
            "details": details,
            "raw_data": {"journal": effective_journal.to_list()},
        }

    def build_missing_surface_result(
        self,
        reason: str,
        detected_versions: Mapping[str, Any],
        *,
        surface_detected: bool = False,
        journal: PocJournal | None = None,
        confidence: str = "medium",
        **extra_details,
    ) -> dict[str, Any]:
        """
        Build a standardized NOT_VULNERABLE result for "missing attack surface" conclusions.

        This is distinct from "not affected" (which maps to NOT_APPLICABLE).
        """
        effective_journal = journal or get_current_journal() or PocJournal()
        status = missing_surface_status(confidence)
        if status == PocStatus.INCONCLUSIVE:
            confidence = "low"
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "surface_detected": surface_detected,
            "detected_versions": self._version_values_for_output(detected_versions),
        }
        details.update(extra_details)
        return {
            "status": status,
            "details": details,
            "raw_data": {"journal": effective_journal.to_list()},
        }

    def build_inconclusive_result(
        self,
        reason: str,
        detected_versions: Mapping[str, Any],
        error_message: str | None = None,
        error_type: str | None = None,
        journal: PocJournal | None = None,
        confidence: str = "low",
        **extra_details,
    ) -> dict[str, Any]:
        effective_journal = journal or get_current_journal() or PocJournal()
        confidence = "low"
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "error_message": error_message,
            "error_type": error_type,
            "detected_versions": self._version_values_for_output(detected_versions),
        }
        details.update(extra_details)
        return {
            "status": PocStatus.INCONCLUSIVE,
            "details": details,
            "raw_data": {"journal": effective_journal.to_list()},
        }

    @abstractmethod
    def evaluate(
        self,
        base_url: str,
        detected_versions: Mapping[str, Any],
        detect_context: DetectContext | None = None,
    ) -> dict[str, Any]: ...
