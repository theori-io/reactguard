# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""React Router assessor for CVE-2025-55182."""

import json
from typing import Any

from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_SERVER_ACTION_ENDPOINTS,
    SIG_SERVER_ACTIONS_CONFIDENCE,
    SIG_SERVER_ACTIONS_ENABLED,
    TAG_REACT_ROUTER_V6,
    TAG_REACT_ROUTER_V7_RSC,
    TAG_REACT_ROUTER_V7_SERVER_ACTIONS,
)
from ...models.poc import PocStatus
from ...rsc.payloads import SAFE_ARGS_STRATEGY, RscReference, build_multipart_form_payload, build_no_invoke_args_container, build_random_safe_prop
from ...rsc.runner import run_rsc_action_probes
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_ids
from ..interpreters.react_router_interpreter import ReactRouterInterpreter
from ..journal import PocJournal, get_current_journal
from .base import BaseAssessor


class ReactRouterAssessor(BaseAssessor):
    framework_name = "react-router"

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        journal = get_current_journal() or PocJournal()
        signals = (detect_context or {}).get("signals", {}) or {}
        tags = (detect_context or {}).get("tags", []) or []
        tag_set = set(tags or [])
        has_server_actions_signal = signals.get(SIG_SERVER_ACTIONS_ENABLED)
        has_server_actions_tag = TAG_REACT_ROUTER_V7_SERVER_ACTIONS in tag_set
        has_server_actions = bool(has_server_actions_signal is True or has_server_actions_tag)
        has_rsc_surface = bool(TAG_REACT_ROUTER_V7_RSC in tag_set)
        react_version = detected_versions.get("react_version")
        # CVE-2025-55182 is governed by the react-server-dom-* runtime (decodeReply), not the React core package.
        rsc_runtime_version = detected_versions.get("rsc_runtime_version") or react_version

        journal.add_event(
            "context",
            "React Router detection context",
            data={
                "signals": signals,
                "tags": tags,
                "has_server_actions_signal": has_server_actions_signal,
                "has_rsc_surface": has_rsc_surface,
            },
        )

        if not has_server_actions:
            if TAG_REACT_ROUTER_V6 in tag_set:
                reason = "React Router v6 detected; Server Actions are v7-only"
                journal.add_decision(PocStatus.NOT_VULNERABLE, reason)
                return self.build_missing_surface_result(
                    reason,
                    detected_versions,
                    surface_detected=False,
                    journal=journal,
                    confidence=signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "high",
                )

            reason = "React Router detected but no Server Actions surface; React2Shell requires Server Actions (RSC Server Functions decoding)"
            journal.add_decision(PocStatus.NOT_VULNERABLE, reason)
            return self.build_missing_surface_result(
                reason,
                detected_versions,
                surface_detected=False,
                journal=journal,
                confidence=signals.get(SIG_SERVER_ACTIONS_CONFIDENCE) or signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "medium",
            )

        is_rsc_framework = bool(has_server_actions)
        proto_props = ["__proto__", "constructor", "prototype"]
        action_ids = generate_action_ids(len(proto_props))
        wire_action_id: str | None = None
        discovered_action_ids = signals.get("react_router_server_action_ids")
        if isinstance(discovered_action_ids, list) and discovered_action_ids:
            first = str(discovered_action_ids[0])
            if first:
                wire_action_id = first
        action_urls = (detect_context or {}).get(SIG_SERVER_ACTION_ENDPOINTS) if detect_context else None
        if not action_urls:
            action_urls = signals.get(SIG_SERVER_ACTION_ENDPOINTS) if isinstance(signals.get(SIG_SERVER_ACTION_ENDPOINTS), list) else None

        if wire_action_id is None and action_ids:
            wire_action_id = action_ids[0]

        request_config = RscRequestConfig(
            method="POST",
            base_headers={"Accept": "text/x-component", "rsc-action-id": str(wire_action_id or "")},
            action_id_header=None,
        )

        probe_targets = {probe_id: prop for probe_id, prop in zip(action_ids, proto_props, strict=False)}

        def _proto_payload(action_id: str):
            target_prop = probe_targets.get(action_id, "__proto__")
            # Use a non-server-reference model pointer (`$2:x:<prop>`) rather than `$Fâ€¦` to
            # exercise decodeReply model traversal in react-server-dom-* implementations.
            ref = RscReference(slot=2, root="x", prop=target_prop, marker="").render()
            args_obj = build_no_invoke_args_container(["$K1", ref])
            return build_multipart_form_payload(
                [
                    (f"1_$ACTION_ID_{wire_action_id}", ""),
                    ("2", '{"x":{}}'),
                    ("0", json.dumps(args_obj, separators=(",", ":"))),
                ],
                meta={
                    "probe_kind": "proto",
                    "probe_strategy": SAFE_ARGS_STRATEGY,
                    "wire_action_id": wire_action_id,
                    "probe_id": action_id,
                    "target_prop": target_prop,
                },
            )

        def _control_payload(action_id: str):
            # Use a no-invoke args object so we don't execute unknown server functions while still exercising the decode surface.
            safe_prop = build_random_safe_prop()
            ref = RscReference(slot=2, root="x", prop=safe_prop, marker="").render()
            args_obj = build_no_invoke_args_container(["$K1", ref])
            return build_multipart_form_payload(
                [
                    (f"1_$ACTION_ID_{wire_action_id}", ""),
                    ("2", '{"x":{}}'),
                    ("0", json.dumps(args_obj, separators=(",", ":"))),
                ],
                meta={"probe_kind": "control", "probe_strategy": SAFE_ARGS_STRATEGY, "wire_action_id": wire_action_id, "probe_id": action_id},
            )

        probe_results, control_result = run_rsc_action_probes(
            base_url,
            action_ids,
            request_config=request_config,
            proto_payload=_proto_payload,
            control_payload=_control_payload,
            action_urls=list(action_urls) if action_urls else None,
            control_url=action_urls[0] if action_urls else None,
        )

        analyzer = ReactRouterInterpreter(
            is_rsc_framework=is_rsc_framework,
            react_major=self.get_react_major(detected_versions, detect_context),
            react_version=rsc_runtime_version,
            react_major_confidence=((detect_context or {}).get("react_major_confidence") or self.get_version_confidence("react_version", detected_versions, detect_context)),
            react_major_conflict=(detect_context or {}).get("react_major_conflict"),
            react_major_conflict_confidence=(detect_context or {}).get("react_major_conflict_confidence"),
            react_major_conflict_majors=(detect_context or {}).get("react_major_conflict_majors"),
            server_actions_expected=True,
            server_actions_confidence=signals.get(SIG_SERVER_ACTIONS_CONFIDENCE),
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = detected_versions
        return analysis
