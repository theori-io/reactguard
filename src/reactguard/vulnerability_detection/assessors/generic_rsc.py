# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Generic RSC assessor for CVE-2025-55182."""

from dataclasses import replace
from typing import Any

from ...models.poc import PocStatus
from ...rsc.payloads import RscReference, build_multipart_decode_payload, build_random_safe_prop
from ...rsc.runner import run_rsc_action_probes
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_ids
from ..interpreters.generic_rsc_interpreter import GenericRscInterpreter
from ..journal import PocJournal, get_current_journal
from .base import BaseAssessor


class GenericRSCAssessor(BaseAssessor):
    framework_name = "rsc"

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        journal = get_current_journal() or PocJournal()
        action_ids = generate_action_ids(3)
        invocation_expected = detect_context.get("invocation_enabled") if detect_context else None
        invocation_confidence = (detect_context or {}).get("invocation_confidence") if detect_context else None
        react_major_confidence = (detect_context or {}).get("react_major_confidence") or self.get_version_confidence("react_version", detected_versions, detect_context)
        action_urls = (detect_context or {}).get("invocation_endpoints") if detect_context else None
        request_config = RscRequestConfig(
            method="POST",
            base_headers={"Accept": "text/x-component"},
            action_id_header="Next-Action",
        )

        def _proto_payload(_action_id: str):
            return build_multipart_decode_payload(RscReference(slot=1, root="x", prop="__proto__", marker="F"))

        def _control_payload(_action_id: str):
            safe_prop = build_random_safe_prop()
            return build_multipart_decode_payload(RscReference(slot=1, root="x", prop=safe_prop, marker="F"))

        probe_results, control_result = run_rsc_action_probes(
            base_url,
            action_ids,
            request_config=request_config,
            proto_payload=_proto_payload,
            control_payload=_control_payload,
            action_urls=list(action_urls) if action_urls else None,
            control_url=action_urls[0] if action_urls else None,
        )

        analyzer = GenericRscInterpreter(
            # RSC-only endpoints can serve Flight without accepting Flight-protocol POST payloads (decodeReply).
            # Only treat this as a Flight protocol payload deserialization surface when we have explicit evidence of a
            # Server Actions-style endpoint (i.e., a remotely callable "server function" endpoint) on this target.
            is_rsc_framework=bool(invocation_expected is True),
            react_major=self.get_react_major(detected_versions, detect_context),
            invocation_expected=invocation_expected,
            invocation_confidence=invocation_confidence,
            react_major_confidence=react_major_confidence,
            react_major_conflict=(detect_context or {}).get("react_major_conflict"),
            react_major_conflict_confidence=(detect_context or {}).get("react_major_conflict_confidence"),
            react_major_conflict_majors=(detect_context or {}).get("react_major_conflict_majors"),
            journal=journal,
        )
        analysis = analyzer.analyze(
            probe_results,
            action_ids=action_ids,
            control_results=[control_result],
        )

        analysis["details"]["detected_versions"] = detected_versions
        if analysis["status"] in (PocStatus.VULNERABLE, PocStatus.LIKELY_VULNERABLE):
            confirmation = self._run_confirmation_round(
                base_url,
                analyzer=analyzer,
                action_urls=action_urls,
            )
            self.apply_confirmation(analysis, confirmation)
        return analysis

    def _run_confirmation_round(
        self,
        base_url: str,
        *,
        analyzer: GenericRscInterpreter,
        action_urls: list[str] | None,
    ) -> dict[str, Any] | None:
        confirm_ids = generate_action_ids(2)
        try:
            request_config = RscRequestConfig(
                method="POST",
                base_headers={"Accept": "text/x-component"},
                action_id_header="Next-Action",
            )

            def _proto_payload(_action_id: str):
                return build_multipart_decode_payload(RscReference(slot=1, root="x", prop="__proto__", marker="F"))

            def _control_payload(_action_id: str):
                safe_prop = build_random_safe_prop()
                return build_multipart_decode_payload(RscReference(slot=1, root="x", prop=safe_prop, marker="F"))

            probe_results, control_result = run_rsc_action_probes(
                base_url,
                confirm_ids,
                request_config=request_config,
                proto_payload=_proto_payload,
                control_payload=_control_payload,
                action_urls=list(action_urls) if action_urls else None,
                control_url=action_urls[0] if action_urls else None,
            )
        except Exception as exc:
            if analyzer.journal is not None:
                analyzer.journal.add_event(
                    "confirmation-error",
                    "Confirmation probe round failed; proceeding without confirmation",
                    data={"error_type": exc.__class__.__name__, "error_message": str(exc)},
                )
            return None

        confirm_journal = PocJournal()
        confirm_analyzer = replace(analyzer, journal=confirm_journal)
        return confirm_analyzer.analyze(
            probe_results,
            action_ids=confirm_ids,
            control_results=[control_result],
        )
