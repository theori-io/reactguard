# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Probe orchestration for Dec 2025 RSC patch fingerprinting."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any

from ...framework_detection.keys import (
    TAG_EXPO,
    TAG_EXPO_SERVER_ACTIONS,
    TAG_NEXTJS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_REACT_ROUTER_V6,
    TAG_REACT_ROUTER_V6_RSC,
    TAG_REACT_ROUTER_V7,
    TAG_REACT_ROUTER_V7_RSC,
    TAG_WAKU,
)
from ...http.headers import header_value
from ...rsc.probes import (
    send_dec2025_missing_chunk_probe,
    send_dec2025_nextjs_promise_chain_root_probe,
    send_dec2025_promise_chain_probe,
    send_dec2025_safe_control_probe,
    send_dec2025_server_reference_marker_root_probe,
)
from ...rsc.runner import build_request_config
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_id
from ...utils.context import scan_cache
from ..journal import PocJournal
from ..probes.rsc_patch_fingerprint_probe import discover_nextjs_server_reference_marker
from ..resolvers.expo import normalize_expo_action_endpoints
from ..resolvers.nextjs import discover_nextjs_action_entrypoint_cached
from ..resolvers.react_router import resolve_react_router_action_context
from ..resolvers.waku import resolve_waku_action_endpoints
from ..snapshots import DetectContext
from .rsc_dec2025_evidence import (
    chain_has_decode_evidence,
    is_chain_signature_uninterpretable,
    is_status_only_signature,
    looks_like_non_rsc_transport_error,
    matches_connection_closed,
    pr35345_evidence_strength,
    pr35345_stability_score,
)
from .rsc_dec2025_signatures import (
    flight_major_evidence,
    looks_like_cycle_thenables_error,
    probe_signature,
    truncate,
)
from ..interpreters.rsc_dec2025_interpreter import PatchFingerprintWithUnknown

_DEC2025_CHAIN_EXPECTED_BOUNDARY = 1000
_DEC2025_CHAIN_DELTA = 10

_DEC2025_CACHE_NAMESPACE = "rsc_dec2025"
_DEC2025_FINGERPRINT_KEY = "fingerprints"
_DEC2025_PROBE_KEY = "probe_results"


def dec2025_cache() -> dict[str, Any]:
    return scan_cache(_DEC2025_CACHE_NAMESPACE, legacy_key="rsc_dec2025_probe_cache")


def dec2025_probe_cache(cache: dict[str, Any]) -> dict[str, Any]:
    bucket = cache.get(_DEC2025_PROBE_KEY)
    if not isinstance(bucket, dict):
        bucket = {}
        cache[_DEC2025_PROBE_KEY] = bucket
    return bucket


def dec2025_fingerprint_cache(cache: dict[str, Any]) -> dict[str, Any]:
    bucket = cache.get(_DEC2025_FINGERPRINT_KEY)
    if not isinstance(bucket, dict):
        bucket = {}
        cache[_DEC2025_FINGERPRINT_KEY] = bucket
    return bucket


def probe_cache_key(endpoint: str, key: str) -> str:
    return f"{endpoint}::{key}"


@dataclass
class Dec2025ProbeOrchestrator:
    base_url: str
    detect_context: DetectContext | None
    journal: PocJournal
    cache: dict[str, Any]
    probe_cache: dict[str, Any] = field(init=False)

    def __post_init__(self) -> None:
        self.probe_cache = dec2025_probe_cache(self.cache)

    def _framework_from_tags(self) -> str:
        tag_set = set(self.detect_context.tags or []) if self.detect_context else set()
        if TAG_NEXTJS in tag_set or TAG_NEXTJS_APP_ROUTER in tag_set:
            return "nextjs"
        if TAG_WAKU in tag_set:
            return "waku"
        if TAG_EXPO in tag_set or TAG_EXPO_SERVER_ACTIONS in tag_set:
            return "expo"
        if (
            TAG_REACT_ROUTER_V6 in tag_set
            or TAG_REACT_ROUTER_V7 in tag_set
            or TAG_REACT_ROUTER_V6_RSC in tag_set
            or TAG_REACT_ROUTER_V7_RSC in tag_set
        ):
            return "react-router"
        return "rsc"

    def _cached_call(self, endpoint: str, key: str, func, **kwargs):
        ck = probe_cache_key(endpoint, key)
        existing = self.probe_cache.get(ck)
        if existing is not None:
            return existing
        result = func(endpoint, **kwargs)
        self.probe_cache[ck] = result
        return result

    def _probe_chain(
        self,
        endpoint: str,
        *,
        chain_depth: int,
        framework: str,
        request_config: RscRequestConfig,
        action_id: str | None,
        prefix_parts: list[tuple[str, str]] | None = None,
    ):
        if framework == "nextjs" and action_id:
            return self._cached_call(
                endpoint,
                f"dec2025_chain_root_{chain_depth}:{action_id}",
                send_dec2025_nextjs_promise_chain_root_probe,
                request_config=request_config,
                action_id=action_id,
                chain_depth=chain_depth,
                prefix_parts=prefix_parts,
            )
        return self._cached_call(
            endpoint,
            f"dec2025_chain_{chain_depth}:{action_id or ''}",
            send_dec2025_promise_chain_probe,
            request_config=request_config,
            action_id=action_id,
            chain_depth=chain_depth,
            prefix_parts=prefix_parts,
        )

    def _retest_marker_sigs(
        self,
        endpoint: str,
        *,
        request_config: RscRequestConfig,
        action_id: str | None,
        prefix_parts: list[tuple[str, str]] | None,
        prior_sigs: dict[str, str],
    ) -> tuple[str, str, int, dict[str, bool]]:
        marker_h_retest = self._cached_call(
            endpoint,
            f"dec2025_marker_root_h_retest:{action_id or ''}",
            send_dec2025_server_reference_marker_root_probe,
            request_config=request_config,
            action_id=action_id,
            server_ref_marker="h",
            prefix_parts=prefix_parts,
        )
        marker_f_retest = self._cached_call(
            endpoint,
            f"dec2025_marker_root_f_retest:{action_id or ''}",
            send_dec2025_server_reference_marker_root_probe,
            request_config=request_config,
            action_id=action_id,
            server_ref_marker="F",
            prefix_parts=prefix_parts,
        )
        sig_h_retest = probe_signature(marker_h_retest)
        sig_f_retest = probe_signature(marker_f_retest)
        stability_score, stability = pr35345_stability_score(prior_sigs, {"h": sig_h_retest, "F": sig_f_retest})
        return sig_h_retest, sig_f_retest, stability_score, stability

    def _probe_post_35345_chain(
        self,
        endpoint: str,
        *,
        framework: str,
        request_config: RscRequestConfig,
        action_id: str | None,
        prefix_parts: list[tuple[str, str]] | None,
        baseline_sigs: list[str],
        marker_evidence: dict[str, Any],
    ) -> tuple[PatchFingerprintWithUnknown, dict[str, Any]]:
        expected_boundary = _DEC2025_CHAIN_EXPECTED_BOUNDARY
        delta = _DEC2025_CHAIN_DELTA
        raw_depths = [
            max(1, expected_boundary - delta),
            max(1, expected_boundary),
            max(1, expected_boundary + delta),
        ]
        depths = list(dict.fromkeys(raw_depths))

        chain_results: dict[int, Any] = {}
        chain_sigs: dict[int, str] = {}
        for depth in depths:
            result = self._probe_chain(
                endpoint,
                chain_depth=depth,
                framework=framework,
                request_config=request_config,
                action_id=action_id,
                prefix_parts=prefix_parts,
            )
            chain_results[depth] = result
            chain_sigs[depth] = probe_signature(result)

        chain_evidence: dict[str, Any] = {
            **marker_evidence,
            "chain_expected_boundary": expected_boundary,
            "chain_delta": delta,
            "chain_probe_sigs": dict(chain_sigs),
            "chain_probe_status_codes": {k: v.status_code for k, v in chain_results.items()},
            "chain_probe_body_snippets": {k: truncate(v.text or v.body_snippet) for k, v in chain_results.items()},
        }

        cycle_sig = any(looks_like_cycle_thenables_error(res) for res in chain_results.values())
        decode_evidence = chain_has_decode_evidence(chain_sigs, baseline_sigs)
        has_digest = any(str(sig).startswith("digest:") for sig in chain_sigs.values())
        chain_evidence.update(
            {
                "pr35351_cycle_signature": cycle_sig,
                "pr35351_decode_evidence": decode_evidence,
                "pr35351_chain_has_digest": has_digest,
                "pr35351_threshold_behavior": False,
            }
        )

        if cycle_sig:
            self.journal.add_event(
                "dec2025-post-35351",
                "Chain probe indicates PR#35351 via explicit cycleProtection signature",
                data={"endpoint": endpoint},
            )
            return "post_35351", chain_evidence

        non_rsc_transport = any(looks_like_non_rsc_transport_error(res) for res in chain_results.values())
        uninterpretable_sigs = [sig for sig in chain_sigs.values() if is_chain_signature_uninterpretable(sig)]
        status_only_sigs = [sig for sig in uninterpretable_sigs if is_status_only_signature(sig)]
        non_status_uninterpretable = [sig for sig in uninterpretable_sigs if not is_status_only_signature(sig)]
        status_only_chain = bool(status_only_sigs) and len(status_only_sigs) == len(chain_sigs)

        if non_rsc_transport or non_status_uninterpretable:
            self.journal.add_event(
                "dec2025-post-35345-unknown",
                "Promise-chain probes not interpretable (timeouts/HTML/transport/validation)",
                data={"endpoint": endpoint, "chain_probe_sigs": dict(chain_sigs)},
            )
            return "post_35345_unknown", {**chain_evidence, "reason": "Promise-chain probes not interpretable (timeouts/HTML/transport/validation)"}

        if status_only_chain:
            chain_evidence["pr35351_chain_status_only"] = True
            marker_strength = str(marker_evidence.get("pr35345_evidence_strength") or "").strip().lower()
            marker_stable = marker_evidence.get("pr35345_marker_stable") is True
            if not (marker_strength in {"medium", "strong"} or (marker_strength == "weak" and marker_stable)):
                self.journal.add_event(
                    "dec2025-post-35345-unknown",
                    "Promise-chain probes returned status-only signatures with weak/unstable marker evidence",
                    data={"endpoint": endpoint, "chain_probe_sigs": dict(chain_sigs), "marker_strength": marker_strength, "marker_stable": marker_stable},
                )
                return "post_35345_unknown", {
                    **chain_evidence,
                    "reason": "Promise-chain probes returned status-only signatures with weak/unstable marker evidence",
                }

        if not decode_evidence:
            self.journal.add_event(
                "dec2025-post-35345-unknown",
                "Promise-chain probes did not show stable RSC decode signatures; treating PR#35351 fingerprint as unknown",
                data={"endpoint": endpoint, "chain_probe_sigs": dict(chain_sigs)},
            )
            return "post_35345_unknown", {
                **chain_evidence,
                "reason": "Promise-chain probes did not show stable RSC decode signatures; treating PR#35351 fingerprint as unknown",
            }

        low_sig = chain_sigs.get(depths[0], "")
        high_sig = chain_sigs.get(depths[-1], "")
        threshold_like = bool(low_sig and high_sig and low_sig != high_sig)
        chain_evidence["pr35351_threshold_behavior"] = threshold_like

        if threshold_like:
            self.journal.add_event(
                "dec2025-post-35351",
                "Bounded chain probes indicate PR#35351-like threshold behavior",
                data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
            )
            return "post_35351", chain_evidence

        self.journal.add_event(
            "dec2025-post-35345-pre-35351",
            "Bounded chain probes found no threshold behavior (incomplete fix)",
            data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
        )
        return "post_35345_pre_35351", chain_evidence

    def fingerprint_patch_level(self) -> tuple[PatchFingerprintWithUnknown | None, dict[str, Any], str]:
        framework = self._framework_from_tags()
        endpoints: list[str] = []
        prefix_parts: list[tuple[str, str]] | None = None
        wire_action_id: str | None = None

        # Resolve candidate endpoints and any required per-framework action context.
        # Keep aligned with CVE-2025-55182 assessors so patch-fingerprinting probes
        # hit the same effective Flight protocol payload deserialization surface.
        if framework == "waku":
            waku = resolve_waku_action_endpoints(self.base_url, self.detect_context, crawl_when_missing=True)
            endpoints = [str(u) for u in (waku.urls or []) if u]
        elif framework == "expo":
            action_urls = list(self.detect_context.invocation_endpoints or []) if self.detect_context else []
            endpoints = normalize_expo_action_endpoints([str(u) for u in action_urls if u])
        elif framework == "react-router":
            rr_ctx = resolve_react_router_action_context(self.base_url, self.detect_context)
            if rr_ctx:
                endpoints = list(rr_ctx.urls or [])
                wire_action_id = rr_ctx.action_id
                prefix_parts = list(rr_ctx.prefix_parts or [])
        else:
            action_urls = list(self.detect_context.invocation_endpoints or []) if self.detect_context else []
            endpoints = [str(u) for u in action_urls if u]
            if not endpoints and self.base_url:
                endpoints = [str(self.base_url)]

        endpoints = list(dict.fromkeys([e for e in endpoints if e]))

        if not endpoints and framework != "nextjs":
            self.journal.add_event(
                "dec2025-fingerprint-skip",
                "No candidate Flight protocol endpoints discovered; cannot fingerprint patch level",
                data={"framework": framework, "base_url": self.base_url},
            )
            return None, {"reason": "No candidate Flight protocol endpoints discovered"}, framework

        def _probe_endpoints(
            probe_endpoints: list[str],
            *,
            request_config: RscRequestConfig,
            action_id_override: str | None,
            nextjs_server_ref_marker: str | None = None,
        ) -> tuple[PatchFingerprintWithUnknown | None, dict[str, Any]]:
            if not probe_endpoints:
                self.journal.add_event(
                    "dec2025-fingerprint-skip",
                    "No candidate Flight protocol endpoints discovered; skipping marker probes",
                    data={"framework": framework},
                )
                return None, {"reason": "No candidate Flight protocol endpoints discovered"}

            saw_decode_surface = False
            saw_action_not_found = False
            saw_html = False
            saw_html_with_rsc_vary = False
            html_endpoints: list[str] = []
            html_rsc_vary_endpoints: list[str] = []
            for endpoint in probe_endpoints:
                if framework == "nextjs":
                    if action_id_override:
                        action_id = action_id_override
                    else:
                        cache_key = probe_cache_key(endpoint, "dec2025_nextjs_invalid_action_id")
                        cached_id = self.cache.get(cache_key)
                        if isinstance(cached_id, str) and cached_id:
                            action_id = cached_id
                        else:
                            action_id = generate_action_id()
                            self.cache[cache_key] = action_id
                else:
                    action_id = None

                # 1) Side-effect safe control probe: confirm Flight protocol payload deserialization reachability.
                control = self._cached_call(
                    endpoint,
                    f"dec2025_control_safe:{action_id or ''}",
                    send_dec2025_safe_control_probe,
                    request_config=request_config,
                    action_id=action_id,
                    prefix_parts=prefix_parts,
                )

                control_sig = probe_signature(control)
                if control_sig == "next_action_not_found":
                    saw_action_not_found = True
                if control_sig == "html" and framework == "nextjs":
                    saw_html = True
                    html_endpoints.append(endpoint)
                    vary = header_value(control.headers or {}, "vary").lower()
                    if vary:
                        vary_parts = [part.strip().lower() for part in vary.split(",")]
                        if any(part == "rsc" for part in vary_parts):
                            saw_html_with_rsc_vary = True
                            html_rsc_vary_endpoints.append(endpoint)
                if (
                    control_sig in {"timeout", "html"}
                    or is_status_only_signature(control_sig)
                    or looks_like_non_rsc_transport_error(control)
                ):
                    continue

                if control_sig != "next_action_not_found":
                    saw_decode_surface = True

                # 2) Learn the endpoint baseline "connection closed" signature using a missing-chunk reference.
                conn_probe = self._cached_call(
                    endpoint,
                    f"dec2025_conn_sig:{action_id or ''}",
                    send_dec2025_missing_chunk_probe,
                    request_config=request_config,
                    action_id=action_id,
                    prefix_parts=prefix_parts,
                )
                conn_sig = probe_signature(conn_probe)
                if is_status_only_signature(conn_sig) or looks_like_non_rsc_transport_error(conn_probe):
                    continue

                marker_h = self._cached_call(
                    endpoint,
                    f"dec2025_marker_root_h:{action_id or ''}",
                    send_dec2025_server_reference_marker_root_probe,
                    request_config=request_config,
                    action_id=action_id,
                    server_ref_marker="h",
                    prefix_parts=prefix_parts,
                )
                marker_f = self._cached_call(
                    endpoint,
                    f"dec2025_marker_root_f:{action_id or ''}",
                    send_dec2025_server_reference_marker_root_probe,
                    request_config=request_config,
                    action_id=action_id,
                    server_ref_marker="F",
                    prefix_parts=prefix_parts,
                )

                sig_h = probe_signature(marker_h)
                sig_f = probe_signature(marker_f)

                marker_evidence: dict[str, Any] = {
                    "endpoint": endpoint,
                    "framework": framework,
                    "action_id": action_id,
                    "nextjs_server_ref_marker": nextjs_server_ref_marker,
                    "control_sig": control_sig,
                    "conn_sig": conn_sig,
                    "conn_body_snippet": truncate(conn_probe.text or conn_probe.body_snippet),
                    "marker_h_sig": sig_h,
                    "marker_f_sig": sig_f,
                    "marker_h_status_code": marker_h.status_code,
                    "marker_f_status_code": marker_f.status_code,
                    "marker_h_body_snippet": truncate(marker_h.text or marker_h.body_snippet),
                    "marker_f_body_snippet": truncate(marker_f.text or marker_f.body_snippet),
                }
                marker_evidence["pr35345_evidence_strength"] = pr35345_evidence_strength(
                    {"control": control, "conn": conn_probe, "marker_h": marker_h, "marker_f": marker_f},
                    [control_sig, conn_sig, sig_h, sig_f],
                )
                marker_evidence.update(
                    flight_major_evidence(
                        {
                            "control": control,
                            "conn": conn_probe,
                            "marker_h": marker_h,
                            "marker_f": marker_f,
                        }
                    )
                )
                if wire_action_id:
                    marker_evidence["wire_action_id"] = wire_action_id

                if sig_h == "next_action_not_found" or sig_f == "next_action_not_found":
                    saw_action_not_found = True
                    continue

                saw_decode_surface = True

                h_is_conn = matches_connection_closed(sig_h, conn_sig)
                f_is_conn = matches_connection_closed(sig_f, conn_sig)

                # Waku: some pre-PR#35345 builds collapse `$h` and `$F` to the same baseline
                # (often an Internal Server Error), defeating the `$h` vs `$F` differential.
                # In that case, fall back to comparing the `$h` marker probe against the safe
                # control signature, which remains stable across the Dec 2025 patch chain.
                if framework == "waku" and h_is_conn and f_is_conn and sig_h and control_sig and sig_h != control_sig:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "pr35345_marker_method": "waku_fallback_h_vs_control",
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )
                    self.journal.add_event(
                        "dec2025-pre-35345",
                        "Waku marker probes match baseline but differ from control signature (treat as pre-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "control_sig": control_sig, "conn_sig": conn_sig},
                    )
                    return "pre_35345", {**marker_evidence, "waku_marker_fallback": "h_vs_control"}

                # If marker probes are inconclusive (both match baseline or both differ), retry once to
                # reduce flakiness from transient connection drops under load.
                if h_is_conn == f_is_conn:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )

                    h_is_conn_retest = matches_connection_closed(sig_h_retest, conn_sig)
                    f_is_conn_retest = matches_connection_closed(sig_f_retest, conn_sig)
                    if h_is_conn_retest and not f_is_conn_retest:
                        marker_evidence["pr35345_marker_method"] = "marker_retry_h_is_conn_f_not"
                        self.journal.add_event(
                            "dec2025-pre-35345",
                            "Marker retest indicates `$h` unsupported and `$F` supported (pre-PR#35345)",
                            data={"endpoint": endpoint, "sig_h": sig_h_retest, "sig_f": sig_f_retest, "conn_sig": conn_sig},
                        )
                        if framework == "nextjs" and nextjs_server_ref_marker == "h":
                            marker_evidence["pr35345_marker_method"] = "nextjs_hint_h_override_marker_retry_h_is_conn_f_not"
                            self.journal.add_event(
                                "dec2025-post-35345",
                                "Next.js bundles indicate `$h` server reference marker; treating marker differential as post-PR#35345 and probing PR#35351 chain",
                                data={"endpoint": endpoint, "sig_h": sig_h_retest, "sig_f": sig_f_retest, "conn_sig": conn_sig},
                            )
                            baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                            return self._probe_post_35345_chain(
                                endpoint,
                                framework=framework,
                                request_config=request_config,
                                action_id=action_id,
                                prefix_parts=prefix_parts,
                                baseline_sigs=baseline_sigs,
                                marker_evidence=marker_evidence,
                            )
                        return "pre_35345", marker_evidence

                    if f_is_conn_retest and not h_is_conn_retest:
                        marker_evidence["pr35345_marker_method"] = "marker_retry_f_is_conn_h_not"
                        self.journal.add_event(
                            "dec2025-post-35345",
                            "Marker retest indicates `$h` supported and `$F` unsupported (post-PR#35345)",
                            data={"endpoint": endpoint, "sig_h": sig_h_retest, "sig_f": sig_f_retest, "conn_sig": conn_sig},
                        )
                        baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                        return self._probe_post_35345_chain(
                            endpoint,
                            framework=framework,
                            request_config=request_config,
                            action_id=action_id,
                            prefix_parts=prefix_parts,
                            baseline_sigs=baseline_sigs,
                            marker_evidence=marker_evidence,
                        )

                # pre-PR#35345: $h unsupported, $F supported
                if h_is_conn and not f_is_conn:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "pr35345_marker_method": "marker_diff_h_is_conn_f_not",
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )
                    self.journal.add_event(
                        "dec2025-pre-35345",
                        "Differential marker probes indicate `$h` unsupported and `$F` supported (pre-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                    )
                    if framework == "nextjs" and nextjs_server_ref_marker == "h":
                        marker_evidence["pr35345_marker_method"] = "nextjs_hint_h_override_h_is_conn_f_not"
                        self.journal.add_event(
                            "dec2025-post-35345",
                            "Next.js bundles indicate `$h` server reference marker; treating marker differential as post-PR#35345 and probing PR#35351 chain",
                            data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                        )
                        baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                        return self._probe_post_35345_chain(
                            endpoint,
                            framework=framework,
                            request_config=request_config,
                            action_id=action_id,
                            prefix_parts=prefix_parts,
                            baseline_sigs=baseline_sigs,
                            marker_evidence=marker_evidence,
                        )

                    return "pre_35345", marker_evidence

                # post-PR#35345: $F unsupported, $h supported
                if f_is_conn and not h_is_conn:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "pr35345_marker_method": "marker_diff_f_is_conn_h_not",
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )
                    self.journal.add_event(
                        "dec2025-post-35345",
                        "Differential marker probes indicate `$h` supported and `$F` unsupported (post-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                    )
                    baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                    return self._probe_post_35345_chain(
                        endpoint,
                        framework=framework,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        baseline_sigs=baseline_sigs,
                        marker_evidence=marker_evidence,
                    )

            if not saw_decode_surface:
                evidence: dict[str, Any] = {
                    "reason": "No reachable Flight protocol payload deserialization surface found (HTML/timeouts)",
                    "endpoints": probe_endpoints,
                }
                if framework == "nextjs" and (saw_action_not_found or saw_html):
                    evidence["needs_valid_action_id"] = True
                    evidence["saw_action_not_found"] = saw_action_not_found
                    evidence["saw_html"] = saw_html
                    evidence["saw_html_with_rsc_vary"] = saw_html_with_rsc_vary
                    if html_endpoints:
                        evidence["html_endpoints"] = html_endpoints
                    if html_rsc_vary_endpoints:
                        evidence["html_rsc_vary_endpoints"] = html_rsc_vary_endpoints
                    self.journal.add_event(
                        "dec2025-nextjs-action-id-required",
                        "Next.js did not return a Flight payload for the action probe; a valid Next-Action header may be required",
                        data={"endpoints": probe_endpoints, "html_endpoints": html_endpoints, "html_rsc_vary_endpoints": html_rsc_vary_endpoints},
                    )

                self.journal.add_event(
                    "dec2025-fingerprint-failed",
                    "No reachable Flight protocol payload deserialization surface found (HTML/timeouts)",
                    data={"endpoints": probe_endpoints},
                )
                return None, evidence

            self.journal.add_event(
                "dec2025-fingerprint-inconclusive",
                "Marker probes were inconclusive on all candidate endpoints",
                data={"endpoints": probe_endpoints},
            )
            return None, {"reason": "Marker probes were inconclusive on all candidate endpoints", "endpoints": probe_endpoints}

        if framework == "nextjs" and self.base_url:
            endpoints_server = list(endpoints)

            cache_key_marker = probe_cache_key(self.base_url, "dec2025_nextjs_server_ref_marker")
            cached_marker = self.cache.get(cache_key_marker)
            if isinstance(cached_marker, str) and cached_marker in {"h", "F"}:
                nextjs_marker_hint: str | None = cached_marker
            else:
                try:
                    nextjs_marker_hint = discover_nextjs_server_reference_marker(self.base_url)
                except Exception as exc:  # noqa: BLE001
                    self.journal.add_event(
                        "dec2025-nextjs-marker-discovery-error",
                        "Failed to discover Next.js server reference marker from client bundles",
                        data={"endpoint": self.base_url, "error_type": exc.__class__.__name__, "error_message": str(exc)},
                    )
                    nextjs_marker_hint = None
                self.cache[cache_key_marker] = nextjs_marker_hint

            if nextjs_marker_hint == "F":
                self.journal.add_event(
                    "dec2025-pre-35345",
                    "Next.js client bundles indicate `$F` server reference marker (pre-PR#35345 hint; confirming via probes)",
                    data={"endpoint": self.base_url},
                )

            request_config = build_request_config(action_id_header="Next-Action")

            # First pass: try no-discovery random IDs (some Next.js builds still decode even if the action is unknown).
            patch, evidence = _probe_endpoints(
                endpoints_server,
                request_config=request_config,
                action_id_override=None,
                nextjs_server_ref_marker=nextjs_marker_hint,
            )
            if patch is not None:
                return (
                    patch,
                    {
                        **evidence,
                        "nextjs_action_id_policy": "random_only",
                        "nextjs_server_ref_marker": nextjs_marker_hint,
                    },
                    framework,
                )

            if isinstance(evidence, dict) and evidence.get("needs_valid_action_id") is True:
                cache_key_id = probe_cache_key(self.base_url, "dec2025_nextjs_action_id")
                cache_key_url = probe_cache_key(self.base_url, "dec2025_nextjs_action_entrypoint_url")
                cached_id = self.cache.get(cache_key_id)
                cached_url = self.cache.get(cache_key_url)

                discovered_id: str | None = cached_id if isinstance(cached_id, str) and cached_id else None
                discovered_url: str | None = cached_url if isinstance(cached_url, str) and cached_url else None

                if not (discovered_id and discovered_url):
                    try:
                        entrypoint = discover_nextjs_action_entrypoint_cached(self.base_url, journal=self.journal)
                    except Exception as exc:  # noqa: BLE001
                        self.journal.add_event(
                            "dec2025-nextjs-action-id-discovery-error",
                            "Failed to discover a Next.js action entrypoint; marker probes may remain inconclusive",
                            data={"endpoint": self.base_url, "error_type": exc.__class__.__name__, "error_message": str(exc)},
                        )
                        entrypoint = None

                    if entrypoint:
                        discovered_id = entrypoint.action_id
                        discovered_url = entrypoint.entrypoint_url
                    else:
                        discovered_id = None
                        discovered_url = None

                    self.cache[cache_key_id] = discovered_id
                    self.cache[cache_key_url] = discovered_url

                if discovered_id and discovered_url:
                    endpoints_retry = list(dict.fromkeys([discovered_url, *endpoints_server]))
                    patch2, evidence2 = _probe_endpoints(
                        endpoints_retry,
                        request_config=request_config,
                        action_id_override=str(discovered_id),
                        nextjs_server_ref_marker=nextjs_marker_hint,
                    )
                    if patch2 is not None:
                        return (
                            patch2,
                            {
                                **(evidence2 or {}),
                                "nextjs_action_id_policy": "random_then_entrypoint",
                                "nextjs_action_entrypoint_url": discovered_url,
                                "nextjs_server_ref_marker": nextjs_marker_hint,
                            },
                            framework,
                        )
                    evidence = {
                        **(evidence2 or {}),
                        "nextjs_action_id_policy": "random_then_entrypoint",
                        "nextjs_action_entrypoint_url": discovered_url,
                        "nextjs_server_ref_marker": nextjs_marker_hint,
                    }
                else:
                    evidence = {
                        **evidence,
                        "nextjs_action_id_policy": "random_then_entrypoint",
                        "nextjs_action_id_discovered": False,
                        "nextjs_server_ref_marker": nextjs_marker_hint,
                    }

            return (
                patch,
                {
                    **evidence,
                    "nextjs_action_id_policy": str((evidence or {}).get("nextjs_action_id_policy") or "random_only"),
                    "nextjs_server_ref_marker": nextjs_marker_hint,
                },
                framework,
            )

        if not endpoints:
            self.journal.add_event(
                "dec2025-fingerprint-skip",
                "No candidate Flight protocol endpoints discovered; cannot fingerprint patch level",
                data={"framework": framework, "base_url": self.base_url},
            )
            return None, {"reason": "No candidate Flight protocol endpoints discovered"}, framework

        if framework == "expo":
            request_config = build_request_config(
                action_id_header=None,
                base_headers={"expo-platform": "web"},
            )
        elif framework == "react-router":
            request_config = build_request_config(
                action_id_header=None,
                base_headers={"rsc-action-id": str(wire_action_id or "")},
            )
        else:
            request_config = build_request_config(action_id_header=None)

        patch, evidence = _probe_endpoints(endpoints, request_config=request_config, action_id_override=None)
        return patch, evidence, framework


__all__ = [
    "Dec2025ProbeOrchestrator",
    "dec2025_cache",
    "dec2025_fingerprint_cache",
]
