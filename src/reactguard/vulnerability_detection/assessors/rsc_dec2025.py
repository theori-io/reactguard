from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Assessors for Dec 2025 React Server Components advisories (CVE-2025-55184/67779/55183)."""

from dataclasses import dataclass
from typing import Any, Literal

from ...errors import ErrorCategory
from ...http.url import build_endpoint_candidates
from ...models.poc import PocStatus
from ...utils.context import get_scan_context
from ..constants import ERROR_BODY_SNIPPET_LIMIT
from ..journal import PocJournal, get_current_journal
from ..probes import (
    discover_nextjs_action_entrypoint,
    send_nextjs_decode_control_probe,
    send_nextjs_promise_chain_probe,
    send_nextjs_server_reference_marker_probe,
    send_rsc_decode_control_probe,
    send_rsc_decode_control_probe_json,
    send_rsc_promise_chain_probe,
    send_rsc_server_reference_marker_probe,
    send_rsc_server_reference_marker_probe_json,
)
from .base import BaseAssessor


@dataclass(frozen=True)
class RscDec2025Spec:
    cve_id: Literal["CVE-2025-55184", "CVE-2025-67779", "CVE-2025-55183"]
    title: str


PatchFingerprint = Literal["pre_35345", "post_35345_pre_35351", "post_35351"]


def _truncate(text: str | None, limit: int = ERROR_BODY_SNIPPET_LIMIT) -> str:
    if not text:
        return ""
    if len(text) <= limit:
        return text
    return text[:limit] + "…"


def _body_contains(result: dict[str, Any] | None, needle: str) -> bool:
    if not result or not needle:
        return False
    body = str(result.get("body") or result.get("body_snippet") or "")
    return needle.lower() in body.lower()


def _is_timeout(result: dict[str, Any]) -> bool:
    return (result.get("error_category") or "").upper() == ErrorCategory.TIMEOUT.value


def _header_value(result: dict[str, Any] | None, header_name: str) -> str:
    if not result or not header_name:
        return ""
    headers = result.get("headers") or {}
    if not isinstance(headers, dict):
        return ""
    return str(headers.get(header_name) or headers.get(header_name.lower()) or "").strip()


def _looks_like_html(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    content_type = _header_value(result, "content-type").lower()
    body = str(result.get("body") or result.get("body_snippet") or "").lstrip()
    if not body:
        # If the server explicitly says HTML but provides no body snippet, treat as HTML.
        return "text/html" in content_type
    lowered = body[:256].lower()
    if lowered.startswith("<!doctype") or lowered.startswith("<html") or "<html" in lowered:
        return True
    # Some servers respond with text/html for plain error strings (e.g. "Action not found").
    # Only treat as HTML when it actually looks like markup.
    return False


def _looks_like_cycle_thenables_error(result: dict[str, Any] | None) -> bool:
    """
    Best-effort detection of the PR #35351 guard error across dev/prod builds.

    Dev builds tend to include the full message. Prod builds may include an error code/link.
    """
    if not result:
        return False
    if _body_contains(result, "cannot have cyclic thenables"):
        return True
    # Minified/prod builds: React error code/link for this guard.
    if _body_contains(result, "minified react error #569") or _body_contains(result, "react.dev/errors/569"):
        return True
    return False


def _looks_like_next_action_not_found(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    if _header_value(result, "x-nextjs-action-not-found") == "1":
        return True
    body = str(result.get("body") or result.get("body_snippet") or "").strip().lower()
    return body == "server action not found."


def _looks_like_connection_closed(result: dict[str, Any] | None) -> bool:
    return _body_contains(result, "connection closed")


def _marker_supports_post_35345(result: dict[str, Any] | None) -> bool:
    """
    Return True when the `$h` marker probe appears to have been parsed (PR #35345 present).

    This needs to be more conservative than just checking the status code because framework endpoints
    can return 4xx/5xx for reasons unrelated to marker parsing (unknown action IDs, app errors, etc.).
    """
    if not result:
        return False

    status = result.get("status_code")
    if isinstance(status, int) and status < 400 and not _looks_like_html(result):
        return True

    # Some frameworks execute an action and fail later; these still indicate `$h` parsed to a value.
    if _body_contains(result, "cannot read properties of null"):
        return True
    if _body_contains(result, "cannot read properties of undefined") and _body_contains(result, "reading 'get'"):
        return True

    # If we got a Next.js action-not-found response, we likely didn't reach the React decode surface.
    if _looks_like_next_action_not_found(result):
        return False

    # Frameworks that decode first may return a generic "Action not found" after decoding.
    if _body_contains(result, "action not found"):
        return True

    return False


def _default_cache() -> dict[str, Any]:
    extra = get_scan_context().extra
    if extra is None:
        return {}
    cache = extra.setdefault("rsc_dec2025_probe_cache", {})
    if not isinstance(cache, dict):
        cache = {}
        extra["rsc_dec2025_probe_cache"] = cache
    return cache


def _cache_key(endpoint: str, key: str) -> str:
    return f"{endpoint}::{key}"


def _chain_signature(result: dict[str, Any] | None) -> str:
    if not result:
        return ""
    if _is_timeout(result):
        return "timeout"
    if _looks_like_next_action_not_found(result):
        return "next_action_not_found"
    if _looks_like_html(result):
        return "html"
    if _looks_like_cycle_thenables_error(result):
        return "cycle_thenables"
    body = str(result.get("body") or result.get("body_snippet") or "").strip().lower()
    if not body:
        return f"status:{result.get('status_code')}"
    if body == "internal server error":
        return "internal_server_error"
    if "cannot read properties of undefined" in body and "reading 'get'" in body:
        return "cannot_read_undefined_get"
    if "cannot read properties of null" in body and "reading 'get'" in body:
        return "cannot_read_null_get"
    if "action not found" in body:
        return "action_not_found"
    return body[:120]


def _chain_interpretable(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    if _is_timeout(result):
        return False
    if _looks_like_next_action_not_found(result):
        return False
    if _looks_like_html(result):
        return False
    body = str(result.get("body") or result.get("body_snippet") or "").strip()
    return bool(body)


class ReactServerComponentsDec2025Assessor(BaseAssessor):
    """
    Non-DoS assessor for the Dec 2025 RSC advisories.

    The DoS CVEs are about *infinite* CPU loops. We avoid triggering those and instead fingerprint
    the relevant patch sets using bounded probes:

    - PR #35345 fingerprint: server reference marker `$h` parsing behavior.
    - PR #35351 fingerprint: finite promise chain depth `1000` vs `1001` (cycleProtection threshold).
    """

    framework_name = "rsc"

    def __init__(self, spec: RscDec2025Spec):
        self.spec = spec
        self.cve_id = spec.cve_id

    def _candidate_endpoints(self, base_url: str, detect_context: dict | None) -> list[str]:
        action_urls = (detect_context or {}).get("server_action_endpoints") or []
        if isinstance(action_urls, list) and action_urls:
            return [str(u) for u in action_urls if u]

        tag_set = set((detect_context or {}).get("tags") or [])
        if not base_url:
            return []

        # Prefer dedicated decode surfaces over the base URL, since many apps return HTML for POSTs
        # on non-action routes (leading to noisy "could not fingerprint" outcomes).
        candidates: list[str] = [
            *build_endpoint_candidates(base_url, "/rsc"),
            *build_endpoint_candidates(base_url, "/RSC/_"),
        ]

        # Waku requires concrete action endpoints (e.g., /RSC/F/<id>/<name>.txt); base_url is not an action surface.
        if "waku" not in tag_set:
            candidates.append(str(base_url))

        # De-dupe while preserving order.
        return list(dict.fromkeys([c for c in candidates if c]))

    def _cached_call(self, cache: dict[str, Any], endpoint: str, key: str, func, **kwargs) -> dict[str, Any]:
        ck = _cache_key(endpoint, key)
        existing = cache.get(ck)
        if isinstance(existing, dict):
            return existing
        result = func(endpoint, **kwargs)
        cache[ck] = result
        return result

    def _fingerprint_patch_level(
        self,
        base_url: str,
        detect_context: dict | None,
        *,
        journal: PocJournal,
    ) -> tuple[PatchFingerprint | Literal["post_35345_unknown"] | None, dict[str, Any]]:
        cache = _default_cache()
        tag_set = set((detect_context or {}).get("tags") or [])
        is_nextjs = bool({"nextjs", "nextjs-app-router"} & tag_set)
        endpoints = self._candidate_endpoints(base_url, detect_context)
        next_entrypoint: tuple[str, str] | None = None
        if is_nextjs and base_url:
            http_client = (detect_context or {}).get("http_client")
            next_entrypoint = discover_nextjs_action_entrypoint(base_url, timeout=2.0, http_client=http_client)
            if next_entrypoint:
                entry_url, _action_id = next_entrypoint
                endpoints = list(dict.fromkeys([entry_url, *endpoints]))
        if not endpoints:
            return None, {"reason": "No candidate Server Function endpoints available"}

        saw_decode_surface = False
        for endpoint in endpoints:
            http_client = (detect_context or {}).get("http_client")
            action_id_override: str | None = next_entrypoint[1] if next_entrypoint else None
            if is_nextjs and action_id_override:
                ck_action = _cache_key(endpoint, "dec2025_nextjs_action_id")
                cache.setdefault(ck_action, action_id_override)

            def keyed(base: str, *, action_id: str | None = action_id_override) -> str:
                if not action_id:
                    return base
                return f"{base}:{action_id}"

            # 1) Lightweight control probe: ensure we can reach a decode surface.
            if is_nextjs and action_id_override:
                control = self._cached_call(
                    cache,
                    endpoint,
                    keyed("dec2025_control"),
                    send_nextjs_decode_control_probe,
                    action_id=action_id_override,
                    timeout=5.0,
                )
            else:
                control = self._cached_call(
                    cache,
                    endpoint,
                    keyed("dec2025_control"),
                    send_rsc_decode_control_probe,
                    action_id=action_id_override,
                    timeout=5.0,
                )
            if _is_timeout(control):
                continue
            # Avoid treating normal HTML pages as action endpoints.
            if _looks_like_html(control):
                continue
            saw_decode_surface = True

            # 2) PR #35345 fingerprint via server reference marker (`$h`) — multipart first.
            if is_nextjs and action_id_override:
                marker = self._cached_call(
                    cache,
                    endpoint,
                    keyed("dec2025_sr_marker"),
                    send_nextjs_server_reference_marker_probe,
                    action_id=action_id_override,
                    timeout=5.0,
                )
            else:
                marker = self._cached_call(
                    cache,
                    endpoint,
                    keyed("dec2025_sr_marker"),
                    send_rsc_server_reference_marker_probe,
                    action_id=action_id_override,
                    timeout=5.0,
                )

            marker_status = marker.get("status_code")
            # Some runtimes surface an unsupported server reference marker (`$h` on pre-PR#35345 builds)
            # as a "Connection closed." decode error. Next.js dev builds can also emit this for malformed
            # action probes when we couldn't obtain a real action id, so treat it as an actual fingerprint
            # only when we have a strong decode-surface signal.
            if _looks_like_connection_closed(marker):
                if is_nextjs and not action_id_override:
                    continue
                journal.add_event(
                    "dec2025-pre-35345",
                    "Marker probe suggests `$h` is unsupported (appears pre-PR#35345)",
                    data={"endpoint": endpoint, "status_code": marker_status, "body_snippet": _truncate(marker.get("body") or marker.get("body_snippet"))},
                )
                return (
                    "pre_35345",
                    {
                        "endpoint": endpoint,
                        "control_status_code": control.get("status_code"),
                        "sr_marker_status_code": marker_status,
                        "sr_marker_body_snippet": _truncate(marker.get("body") or marker.get("body_snippet")),
                    },
                )

            if "waku" in tag_set and (_is_timeout(marker) or _chain_signature(marker) == "internal_server_error"):
                control_sig = _chain_signature(control)
                if control_sig and control_sig not in {"timeout", "html", "next_action_not_found"}:
                    journal.add_event(
                        "dec2025-pre-35345",
                        "Marker probe appears unsupported on Waku (pre-PR#35345 signature)",
                        data={
                            "endpoint": endpoint,
                            "control_sig": control_sig,
                            "sr_marker_sig": _chain_signature(marker),
                            "sr_marker_timeout": _is_timeout(marker),
                        },
                    )
                    return (
                        "pre_35345",
                        {
                            "endpoint": endpoint,
                            "control_status_code": control.get("status_code"),
                            "control_body_snippet": _truncate(control.get("body") or control.get("body_snippet")),
                            "sr_marker_status_code": marker_status,
                            "sr_marker_body_snippet": _truncate(marker.get("body") or marker.get("body_snippet")),
                            "sr_marker_error_category": marker.get("error_category"),
                        },
                    )

            if _marker_supports_post_35345(marker):
                # 3) PR #35351 fingerprint via finite chain (1000 vs 1001).
                if is_nextjs and action_id_override:
                    chain1000 = self._cached_call(
                        cache,
                        endpoint,
                        keyed("dec2025_chain_1000"),
                        send_nextjs_promise_chain_probe,
                        chain_depth=1000,
                        action_id=action_id_override,
                        timeout=8.0,
                    )
                    chain1001 = self._cached_call(
                        cache,
                        endpoint,
                        keyed("dec2025_chain_1001"),
                        send_nextjs_promise_chain_probe,
                        chain_depth=1001,
                        action_id=action_id_override,
                        timeout=8.0,
                    )
                else:
                    chain1000 = self._cached_call(
                        cache,
                        endpoint,
                        keyed("dec2025_chain_1000"),
                        send_rsc_promise_chain_probe,
                        chain_depth=1000,
                        action_id=action_id_override,
                        timeout=8.0,
                    )
                    chain1001 = self._cached_call(
                        cache,
                        endpoint,
                        keyed("dec2025_chain_1001"),
                        send_rsc_promise_chain_probe,
                        chain_depth=1001,
                        action_id=action_id_override,
                        timeout=8.0,
                    )

                has_cycle_error_1000 = _looks_like_cycle_thenables_error(chain1000)
                has_cycle_error_1001 = _looks_like_cycle_thenables_error(chain1001)

                if has_cycle_error_1000 or has_cycle_error_1001:
                    tripped_depth = 1000 if has_cycle_error_1000 else 1001
                    tripped = chain1000 if has_cycle_error_1000 else chain1001
                    journal.add_event(
                        "dec2025-post-35351",
                        "Finite chain probe tripped cycleProtection (patched)",
                        data={"endpoint": endpoint, "chain_depth": tripped_depth},
                    )
                    return (
                        "post_35351",
                        {
                            "endpoint": endpoint,
                            "sr_marker_status_code": marker_status,
                            "chain1000_status_code": chain1000.get("status_code"),
                            "chain1001_status_code": chain1001.get("status_code"),
                            "chain_tripped_depth": tripped_depth,
                            "chain_tripped_body_snippet": _truncate(tripped.get("body") or tripped.get("body_snippet")),
                        },
                    )

                sig1000 = _chain_signature(chain1000)
                sig1001 = _chain_signature(chain1001)

                chain_interpretable = _chain_interpretable(chain1000) and _chain_interpretable(chain1001)
                if chain_interpretable and sig1000 == sig1001:
                    # Some frameworks (notably Waku) surface the PR #35351 behavior as a signature boundary
                    # at 999 -> 1000, where 1000/1001 are identical but differ from 999.
                    if is_nextjs and action_id_override:
                        chain999 = self._cached_call(
                            cache,
                            endpoint,
                            keyed("dec2025_chain_999"),
                            send_nextjs_promise_chain_probe,
                            chain_depth=999,
                            action_id=action_id_override,
                            timeout=8.0,
                        )
                    else:
                        chain999 = self._cached_call(
                            cache,
                            endpoint,
                            keyed("dec2025_chain_999"),
                            send_rsc_promise_chain_probe,
                            chain_depth=999,
                            action_id=action_id_override,
                            timeout=8.0,
                        )
                    sig999 = _chain_signature(chain999)

                    if _chain_interpretable(chain999):
                        if sig999 != sig1000 and sig1000 == sig1001:
                            journal.add_event(
                                "dec2025-post-35351",
                                "Finite chain probe indicates PR#35351 via threshold boundary (patched)",
                                data={"endpoint": endpoint, "sig999": sig999, "sig1000": sig1000},
                            )
                            return (
                                "post_35351",
                                {
                                    "endpoint": endpoint,
                                    "sr_marker_status_code": marker_status,
                                    "chain999_status_code": chain999.get("status_code"),
                                    "chain1000_status_code": chain1000.get("status_code"),
                                    "chain1001_status_code": chain1001.get("status_code"),
                                    "chain999_body_snippet": _truncate(chain999.get("body") or chain999.get("body_snippet")),
                                    "chain1000_body_snippet": _truncate(chain1000.get("body") or chain1000.get("body_snippet")),
                                    "chain1001_body_snippet": _truncate(chain1001.get("body") or chain1001.get("body_snippet")),
                                },
                            )

                        if sig999 == sig1000 == sig1001:
                            journal.add_event(
                                "dec2025-post-35345-pre-35351",
                                "Finite chain probe did not trip cycleProtection (incomplete fix)",
                                data={"endpoint": endpoint, "sig": sig1000},
                            )
                            return (
                                "post_35345_pre_35351",
                                {
                                    "endpoint": endpoint,
                                    "sr_marker_status_code": marker_status,
                                    "chain999_status_code": chain999.get("status_code"),
                                    "chain1000_status_code": chain1000.get("status_code"),
                                    "chain1001_status_code": chain1001.get("status_code"),
                                    "chain999_body_snippet": _truncate(chain999.get("body") or chain999.get("body_snippet")),
                                    "chain1000_body_snippet": _truncate(chain1000.get("body") or chain1000.get("body_snippet")),
                                    "chain1001_body_snippet": _truncate(chain1001.get("body") or chain1001.get("body_snippet")),
                                },
                            )

                if chain_interpretable and sig1000 == sig1001:
                    # Interpretable but ambiguous.
                    journal.add_event(
                        "dec2025-post-35345-unknown-35351",
                        "Marker probe suggests PR#35345 present, but chain probes were ambiguous",
                        data={"endpoint": endpoint, "sig1000": sig1000},
                    )
                    return (
                        "post_35345_unknown",
                        {
                            "endpoint": endpoint,
                            "sr_marker_status_code": marker_status,
                            "sr_marker_body_snippet": _truncate(marker.get("body") or marker.get("body_snippet")),
                            "chain1000_status_code": chain1000.get("status_code"),
                            "chain1001_status_code": chain1001.get("status_code"),
                            "chain1000_body_snippet": _truncate(chain1000.get("body") or chain1000.get("body_snippet")),
                            "chain1001_body_snippet": _truncate(chain1001.get("body") or chain1001.get("body_snippet")),
                        },
                    )

                if chain_interpretable and sig1000 != sig1001:
                    # A threshold boundary that doesn't match known PR #35351 signals is treated conservatively.
                    journal.add_event(
                        "dec2025-post-35345-unknown-35351",
                        "Marker probe suggests PR#35345 present, but chain signatures are inconsistent",
                        data={"endpoint": endpoint, "sig1000": sig1000, "sig1001": sig1001},
                    )
                    return (
                        "post_35345_unknown",
                        {
                            "endpoint": endpoint,
                            "sr_marker_status_code": marker_status,
                            "sr_marker_body_snippet": _truncate(marker.get("body") or marker.get("body_snippet")),
                            "chain1000_status_code": chain1000.get("status_code"),
                            "chain1001_status_code": chain1001.get("status_code"),
                            "chain1000_body_snippet": _truncate(chain1000.get("body") or chain1000.get("body_snippet")),
                            "chain1001_body_snippet": _truncate(chain1001.get("body") or chain1001.get("body_snippet")),
                        },
                    )

                journal.add_event(
                    "dec2025-post-35345-unknown-35351",
                    "Marker probe suggests PR#35345 present, but chain probes were not interpretable",
                    data={"endpoint": endpoint},
                )
                return (
                    "post_35345_unknown",
                    {
                        "endpoint": endpoint,
                        "sr_marker_status_code": marker_status,
                        "sr_marker_body_snippet": _truncate(marker.get("body") or marker.get("body_snippet")),
                        "chain1000_status_code": chain1000.get("status_code"),
                        "chain1001_status_code": chain1001.get("status_code"),
                        "chain1000_body_snippet": _truncate(chain1000.get("body") or chain1000.get("body_snippet")),
                        "chain1001_body_snippet": _truncate(chain1001.get("body") or chain1001.get("body_snippet")),
                    },
                )

            # 2b) JSON-body fallback for frameworks that decode with `decodeReply(body: string)`.
            control_json = self._cached_call(
                cache,
                endpoint,
                keyed("dec2025_control_json"),
                send_rsc_decode_control_probe_json,
                action_id=action_id_override,
                timeout=5.0,
            )
            if _is_timeout(control_json):
                continue

            marker_json = self._cached_call(
                cache,
                endpoint,
                keyed("dec2025_sr_marker_json"),
                send_rsc_server_reference_marker_probe_json,
                action_id=action_id_override,
                timeout=5.0,
            )
            marker_json_status = marker_json.get("status_code")
            if _looks_like_connection_closed(marker_json):
                if is_nextjs and not action_id_override:
                    continue
                journal.add_event(
                    "dec2025-pre-35345",
                    "JSON marker probe suggests `$h` is unsupported (appears pre-PR#35345)",
                    data={"endpoint": endpoint, "status_code": marker_json_status},
                )
                return (
                    "pre_35345",
                    {
                        "endpoint": endpoint,
                        "control_status_code": control.get("status_code"),
                        "control_json_status_code": control_json.get("status_code"),
                        "sr_marker_status_code": marker_json_status,
                        "sr_marker_body_snippet": _truncate(marker_json.get("body") or marker_json.get("body_snippet")),
                    },
                )

            if _marker_supports_post_35345(marker_json):
                journal.add_event(
                    "dec2025-post-35345-unknown-35351",
                    "JSON marker probe suggests PR#35345 present (chain probe unsupported on this endpoint)",
                    data={"endpoint": endpoint},
                )
                return (
                    "post_35345_unknown",
                    {
                        "endpoint": endpoint,
                        "control_status_code": control.get("status_code"),
                        "control_json_status_code": control_json.get("status_code"),
                        "sr_marker_status_code": marker_json_status,
                        "sr_marker_body_snippet": _truncate(marker_json.get("body") or marker_json.get("body_snippet")),
                    },
                )

        if not saw_decode_surface:
            return None, {"reason": "No candidate Server Function endpoints available"}

        return None, {"reason": "Could not fingerprint Dec 2025 patch level from candidate endpoints"}

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        journal = get_current_journal() or PocJournal()

        patch_level, evidence = self._fingerprint_patch_level(
            base_url,
            detect_context,
            journal=journal,
        )

        server_actions_enabled = (detect_context or {}).get("server_actions_enabled")
        server_actions_confidence = (detect_context or {}).get("server_actions_confidence")

        if patch_level is None:
            return self.build_inconclusive_result(
                evidence.get("reason") or "Patch fingerprinting inconclusive",
                detected_versions,
                journal=journal,
                confidence="low",
                evidence=evidence,
            )

        if self.cve_id == "CVE-2025-55184":
            if patch_level == "pre_35345":
                return {
                    "status": PocStatus.VULNERABLE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": "high",
                        "reason": "Target appears pre-PR#35345 (missing RSC thenable-cycle mitigation)",
                        "patch_fingerprint": patch_level,
                        "detected_versions": detected_versions,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            return {
                "status": PocStatus.NOT_VULNERABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "high",
                    "reason": "Target appears to include PR#35345 (initial DoS mitigation present)",
                    "patch_fingerprint": patch_level,
                    "detected_versions": detected_versions,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if self.cve_id == "CVE-2025-67779":
            if patch_level == "pre_35345":
                return self.build_not_applicable_result(
                    "Target appears vulnerable to CVE-2025-55184; CVE-2025-67779 applies to incomplete-fix versions only",
                    detected_versions,
                    surface_detected=bool(server_actions_enabled),
                    confidence="high",
                    patch_fingerprint=patch_level,
                )
            if patch_level == "post_35345_unknown":
                return self.build_inconclusive_result(
                    "Target appears to include PR#35345, but the PR#35351 fingerprint is inconclusive on this endpoint",
                    detected_versions,
                    journal=journal,
                    confidence="medium",
                    patch_fingerprint=patch_level,
                    evidence=evidence,
                )
            if patch_level == "post_35351":
                return {
                    "status": PocStatus.NOT_VULNERABLE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": "high",
                        "reason": "Target appears to include PR#35351 (cycleProtection guard present)",
                        "patch_fingerprint": patch_level,
                        "detected_versions": detected_versions,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            return {
                "status": PocStatus.VULNERABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "high",
                    "reason": "Target appears to include PR#35345 but not PR#35351 (incomplete DoS fix)",
                    "patch_fingerprint": patch_level,
                    "detected_versions": detected_versions,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        # CVE-2025-55183 (source exposure) is configuration-dependent, but fixed by PR#35345.
        if patch_level != "pre_35345":
            return {
                "status": PocStatus.NOT_VULNERABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "high",
                    "reason": "Target appears to include PR#35345 (server reference source-hiding present)",
                    "patch_fingerprint": patch_level,
                    "detected_versions": detected_versions,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if server_actions_enabled is False and str(server_actions_confidence or "").lower() == "high":
            return self.build_not_applicable_result(
                "No Server Functions surface detected (CVE requires a Server Function that stringifies attacker-controlled input)",
                detected_versions,
                surface_detected=False,
                confidence="high",
                patch_fingerprint=patch_level,
            )

        return {
            "status": PocStatus.LIKELY_VULNERABLE,
            "details": {
                "cve_id": self.cve_id,
                "confidence": "high",
                "reason": "Target appears pre-PR#35345; exploitation still depends on Server Function behavior (explicit/implicit stringify)",
                "patch_fingerprint": patch_level,
                "server_actions_enabled": server_actions_enabled,
                "server_actions_confidence": server_actions_confidence,
                "detected_versions": detected_versions,
            },
            "raw_data": {"evidence": evidence, "journal": journal.to_list()},
        }


__all__ = ["ReactServerComponentsDec2025Assessor", "RscDec2025Spec"]
