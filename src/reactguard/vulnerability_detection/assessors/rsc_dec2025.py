# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Assessors for Dec 2025 React Server Components advisories (CVE-2025-55184/67779/55183)."""

from __future__ import annotations

import hashlib
from dataclasses import dataclass
from typing import Any, Literal
from urllib.parse import urlsplit, urlunsplit

from ...http.headers import header_value
from ...http.url import build_endpoint_candidates
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_id
from ...utils.context import get_scan_context
from ...utils.react_major import infer_react_major_from_flight_text
from ..constants import ERROR_BODY_SNIPPET_LIMIT
from ..interpreters.digest import ERROR_DIGEST_PATTERN
from ..interpreters.rsc_dec2025_interpreter import PatchFingerprintWithUnknown, RscDec2025Interpreter
from ..journal import PocJournal, get_current_journal
from ..probes.rsc_dec2025_probe import (
    send_dec2025_missing_chunk_probe,
    send_dec2025_nextjs_promise_chain_root_probe,
    send_dec2025_promise_chain_probe,
    send_dec2025_safe_control_probe,
    send_dec2025_server_reference_marker_root_probe,
)
from ..probes.rsc_patch_fingerprint_probe import (
    discover_nextjs_action_id,
    discover_nextjs_server_reference_marker,
)
from .base import BaseAssessor


@dataclass(frozen=True)
class RscDec2025Spec:
    cve_id: Literal["CVE-2025-55184", "CVE-2025-67779", "CVE-2025-55183"]
    title: str


def _truncate(text: str | None, limit: int = ERROR_BODY_SNIPPET_LIMIT) -> str:
    if not text:
        return ""
    if len(text) <= limit:
        return text
    return text[:limit] + "â€¦"


def _body_contains(result: dict[str, Any] | None, needle: str) -> bool:
    if not result or not needle:
        return False
    body = str(result.get("body") or result.get("body_snippet") or "")
    return needle.lower() in body.lower()


def _is_timeout(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    error_type = str(result.get("error_type") or "").lower()
    if "timeout" in error_type:
        return True
    error_message = str(result.get("error_message") or "").lower()
    return "timed out" in error_message or "timeout" in error_message


def _looks_like_html(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    content_type = header_value(result.get("headers") or {}, "content-type").lower()
    body = str(result.get("body") or result.get("body_snippet") or "").lstrip()
    if not body:
        return "text/html" in content_type
    lowered = body[:256].lower()
    if lowered.startswith("<!doctype") or lowered.startswith("<html") or "<html" in lowered:
        return True
    return False


def _looks_like_cycle_thenables_error(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    if _body_contains(result, "cannot have cyclic thenables"):
        return True
    if _body_contains(result, "minified react error #569") or _body_contains(result, "react.dev/errors/569"):
        return True
    return False


def _looks_like_next_action_not_found(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    if header_value(result.get("headers") or {}, "x-nextjs-action-not-found") == "1":
        return True
    body = str(result.get("body") or result.get("body_snippet") or "").strip().lower()
    return body == "server action not found."


def _looks_like_connection_closed(result: dict[str, Any] | None) -> bool:
    return _body_contains(result, "connection closed")


def _extract_digest(result: dict[str, Any] | None) -> str:
    if not result:
        return ""
    body = str(result.get("body") or result.get("body_snippet") or "")
    if not body:
        return ""
    match = ERROR_DIGEST_PATTERN.search(body)
    return match.group(1) if match else ""


def _probe_signature(result: dict[str, Any] | None) -> str:
    """
    Extract a stable signature from a probe response.

    Prefer:
    - explicit cycleProtection signals (dev/prod React error link)
    - digest tokens (prod)
    - stable textual markers (connection closed / action-not-found)
    - status+snippet fallback
    """
    if not result:
        return ""
    if _is_timeout(result):
        return "timeout"
    if _looks_like_cycle_thenables_error(result):
        return "cycle_thenables"
    if _looks_like_connection_closed(result):
        return "connection_closed"

    digest = _extract_digest(result)
    if digest:
        return f"digest:{digest}"
    if _looks_like_next_action_not_found(result):
        return "next_action_not_found"
    if _looks_like_html(result):
        return "html"

    body = str(result.get("body") or result.get("body_snippet") or "").strip().lower()
    if not body:
        return f"status:{result.get('status_code')}"
    return body[:160]


def _infer_react_major_from_result(result: dict[str, Any] | None) -> int | None:
    if not result:
        return None
    body = str(result.get("body") or result.get("body_snippet") or "")
    return infer_react_major_from_flight_text(body)


def _flight_major_evidence(label_to_result: dict[str, dict[str, Any] | None]) -> dict[str, Any]:
    majors: set[int] = set()
    sources: list[str] = []
    for label, result in label_to_result.items():
        major = _infer_react_major_from_result(result)
        if major is None:
            continue
        majors.add(int(major))
        sources.append(str(label))

    if not majors:
        return {}

    out: dict[str, Any] = {
        "react_major_from_flight_majors": sorted(majors),
        "react_major_from_flight_sources": list(dict.fromkeys(sources)),
    }
    if len(majors) == 1:
        out["react_major_from_flight"] = next(iter(majors))
        out["react_major_from_flight_confidence"] = "high"
    else:
        out["react_major_from_flight_conflict"] = True
        out["react_major_from_flight_confidence"] = "medium"
    return out


def _matches_connection_closed(sig: str, conn_sig: str) -> bool:
    if not sig:
        return False
    if sig == "connection_closed":
        return True
    return bool(conn_sig and sig == conn_sig)


def _is_status_only_signature(sig: str) -> bool:
    return bool(sig) and sig.startswith("status:")


def _normalize_signature(sig: str) -> str:
    if not sig:
        return ""
    if sig.startswith("digest:"):
        return "digest"
    return sig


def _is_chain_signature_uninterpretable(sig: str) -> bool:
    if not sig:
        return True
    if sig in {"timeout", "next_action_not_found", "html"}:
        return True
    return _is_status_only_signature(sig)


def _chain_has_decode_evidence(chain_sigs: dict[int, str], baseline_sigs: list[str] | tuple[str, ...]) -> bool:
    normalized_chain = {_normalize_signature(s) for s in chain_sigs.values() if s}
    if not normalized_chain:
        return False

    # Treat these as standalone evidence that the request reached RSC decode/Flight plumbing.
    if normalized_chain & {"digest", "connection_closed", "cycle_thenables"}:
        return True

    normalized_baseline = {_normalize_signature(s) for s in baseline_sigs if s}
    return bool(normalized_chain & normalized_baseline)


def _pr35345_evidence_strength(label_to_result: dict[str, dict[str, Any] | None], sigs: list[str]) -> str:
    """
    Estimate how likely it is that marker probes reached the RSC/Flight deserializer.

    Returned levels are used to down-weight PR#35345 patch fingerprints that could be explained by
    generic infra behavior (WAF/proxy/routing) rather than React decode paths.
    """
    for result in label_to_result.values():
        if not result:
            continue
        content_type = header_value(result.get("headers") or {}, "content-type").lower()
        if "text/x-component" in content_type:
            return "strong"
        if _extract_digest(result):
            return "strong"
        if _looks_like_cycle_thenables_error(result):
            return "strong"
        if _infer_react_major_from_result(result) is not None:
            return "strong"

    normalized = {_normalize_signature(s) for s in sigs if s}
    normalized.discard("timeout")
    normalized.discard("html")
    normalized.discard("next_action_not_found")
    if not normalized or all(_is_status_only_signature(s) for s in sigs if s):
        return "none"
    if "connection_closed" in normalized:
        return "medium"
    if "digest" in normalized or "cycle_thenables" in normalized:
        return "strong"
    return "weak"


def _pr35345_stability_score(primary: dict[str, str], retest: dict[str, str]) -> tuple[int, dict[str, bool]]:
    """
    Compare marker signatures from a retest to detect unstable/non-deterministic infrastructure behavior.

    Returns:
    - score: count of matching markers (0..2)
    - per_marker: {"h": bool, "F": bool}
    """
    stable_h = _normalize_signature(retest.get("h", "")) == _normalize_signature(primary.get("h", ""))
    stable_f = _normalize_signature(retest.get("F", "")) == _normalize_signature(primary.get("F", ""))
    return int(stable_h) + int(stable_f), {"h": stable_h, "F": stable_f}

_DEC2025_CHAIN_NON_RSC_STATUS_CODES = {401, 403, 404, 405, 413, 415}


def _looks_like_non_rsc_transport_error(result: dict[str, Any] | None) -> bool:
    if not result:
        return True
    status_code = result.get("status_code")
    if isinstance(status_code, int) and status_code in _DEC2025_CHAIN_NON_RSC_STATUS_CODES:
        # Allow known decode-time patterns even if the HTTP status is unexpected.
        if _looks_like_next_action_not_found(result):
            return False
        if _looks_like_cycle_thenables_error(result) or _looks_like_connection_closed(result) or _extract_digest(result):
            return False
        return True
    return False


def _default_cache() -> dict[str, Any]:
    extra = get_scan_context().extra
    if extra is None:
        return {}
    cache = extra.setdefault("rsc_dec2025_probe_cache", {})
    if not isinstance(cache, dict):
        cache = {}
        extra["rsc_dec2025_probe_cache"] = cache
    return cache


def _cache_key(endpoint: str, key: str) -> str:
    return f"{endpoint}::{key}"


_DEC2025_CHAIN_EXPECTED_BOUNDARY = 1000
_DEC2025_CHAIN_DELTA = 10


def _expo_random_action_url(url: str) -> str:
    """
    Expo Router Server Functions encode the target module/export in the URL path (ACTION_...).

    Use a deterministic, non-existent action target so we never invoke unknown app code while still
    exercising decodeReply() before the router attempts module resolution.
    """
    if not url:
        return url
    parts = urlsplit(url)
    marker = "/ACTION_"
    if marker not in parts.path:
        return url
    base_path, _ = parts.path.split(marker, 1)
    token = hashlib.sha256(url.encode("utf-8")).hexdigest()[:12]
    new_path = f"{base_path}{marker}./reactguard_probe_{token}.ts/probe.txt"
    return urlunsplit((parts.scheme, parts.netloc, new_path, parts.query, parts.fragment))


def _react_router_action_id(detect_context: dict | None) -> str | None:
    signals = (detect_context or {}).get("signals") or {}
    action_ids = signals.get("react_router_server_action_ids")
    if not isinstance(action_ids, list) or not action_ids:
        return None
    first = str(action_ids[0] or "").strip()
    return first or None


class ReactServerComponentsDec2025Assessor(BaseAssessor):
    """
    Non-DoS assessor for the Dec 2025 RSC advisories.

    Fingerprints patch sets using bounded probes:
    - PR #35345 fingerprint: server reference marker `$h` parsing behavior ($F vs $h differential).
    - PR #35351 fingerprint: finite promise chain threshold (cycleProtection guard).
    """

    framework_name = "rsc"

    def __init__(self, spec: RscDec2025Spec):
        self.spec = spec
        self.cve_id = spec.cve_id

    def _candidate_endpoints(self, base_url: str, detect_context: dict | None) -> list[str]:
        action_urls = (detect_context or {}).get("invocation_endpoints") or []
        if isinstance(action_urls, list) and action_urls:
            return [str(u) for u in action_urls if u]

        tag_set = set((detect_context or {}).get("tags") or [])
        if not base_url:
            return []

        candidates: list[str] = []
        if "waku" in tag_set:
            candidates.extend(build_endpoint_candidates(base_url, "/RSC/_"))
        else:
            candidates.append(str(base_url))

        return list(dict.fromkeys([c for c in candidates if c]))

    @staticmethod
    def _framework_from_tags(detect_context: dict | None) -> str:
        tag_set = set((detect_context or {}).get("tags") or [])
        if {"nextjs", "nextjs-app-router"} & tag_set:
            return "nextjs"
        if "waku" in tag_set:
            return "waku"
        if "expo" in tag_set or "expo-server-actions" in tag_set:
            return "expo"
        if any(tag.startswith("react-router") for tag in tag_set):
            return "react-router"
        return "rsc"

    def _cached_call(self, cache: dict[str, Any], endpoint: str, key: str, func, **kwargs) -> dict[str, Any]:
        ck = _cache_key(endpoint, key)
        existing = cache.get(ck)
        if isinstance(existing, dict):
            return existing
        result = func(endpoint, **kwargs)
        cache[ck] = result
        return result

    def _probe_chain(
        self,
        cache: dict[str, Any],
        endpoint: str,
        *,
        chain_depth: int,
        framework: str,
        request_config: RscRequestConfig,
        action_id: str | None,
        prefix_parts: list[tuple[str, str]] | None = None,
    ) -> dict[str, Any]:
        if framework == "nextjs" and action_id:
            return self._cached_call(
                cache,
                endpoint,
                f"dec2025_chain_root_{chain_depth}:{action_id}",
                send_dec2025_nextjs_promise_chain_root_probe,
                request_config=request_config,
                action_id=action_id,
                chain_depth=chain_depth,
                prefix_parts=prefix_parts,
            )
        return self._cached_call(
            cache,
            endpoint,
            f"dec2025_chain_{chain_depth}:{action_id or ''}",
            send_dec2025_promise_chain_probe,
            request_config=request_config,
            action_id=action_id,
            chain_depth=chain_depth,
            prefix_parts=prefix_parts,
        )

    def _retest_marker_sigs(
        self,
        cache: dict[str, Any],
        endpoint: str,
        *,
        request_config: RscRequestConfig,
        action_id: str | None,
        prefix_parts: list[tuple[str, str]] | None,
        prior_sigs: dict[str, str],
    ) -> tuple[str, str, int, dict[str, bool]]:
        marker_h_retest = self._cached_call(
            cache,
            endpoint,
            f"dec2025_marker_root_h_retest:{action_id or ''}",
            send_dec2025_server_reference_marker_root_probe,
            request_config=request_config,
            action_id=action_id,
            server_ref_marker="h",
            prefix_parts=prefix_parts,
        )
        marker_f_retest = self._cached_call(
            cache,
            endpoint,
            f"dec2025_marker_root_f_retest:{action_id or ''}",
            send_dec2025_server_reference_marker_root_probe,
            request_config=request_config,
            action_id=action_id,
            server_ref_marker="F",
            prefix_parts=prefix_parts,
        )
        sig_h_retest = _probe_signature(marker_h_retest)
        sig_f_retest = _probe_signature(marker_f_retest)
        stability_score, stability = _pr35345_stability_score(prior_sigs, {"h": sig_h_retest, "F": sig_f_retest})
        return sig_h_retest, sig_f_retest, stability_score, stability

    def _probe_post_35345_chain(
        self,
        cache: dict[str, Any],
        endpoint: str,
        *,
        framework: str,
        request_config: RscRequestConfig,
        action_id: str | None,
        prefix_parts: list[tuple[str, str]] | None,
        baseline_sigs: list[str],
        marker_evidence: dict[str, Any],
        journal: PocJournal,
    ) -> tuple[PatchFingerprintWithUnknown, dict[str, Any]]:
        expected_boundary = _DEC2025_CHAIN_EXPECTED_BOUNDARY
        delta = _DEC2025_CHAIN_DELTA
        raw_depths = [
            max(1, expected_boundary - delta),
            max(1, expected_boundary),
            max(1, expected_boundary + delta),
        ]
        depths = list(dict.fromkeys(raw_depths))

        chain_results: dict[int, dict[str, Any]] = {}
        chain_sigs: dict[int, str] = {}
        for depth in depths:
            result = self._probe_chain(
                cache,
                endpoint,
                chain_depth=depth,
                framework=framework,
                request_config=request_config,
                action_id=action_id,
                prefix_parts=prefix_parts,
            )
            chain_results[depth] = result
            chain_sigs[depth] = _probe_signature(result)

        chain_evidence: dict[str, Any] = {
            **marker_evidence,
            "chain_expected_boundary": expected_boundary,
            "chain_delta": delta,
            "chain_probe_sigs": dict(chain_sigs),
            "chain_probe_status_codes": {k: v.get("status_code") for k, v in chain_results.items()},
            "chain_probe_body_snippets": {k: _truncate(v.get("body") or v.get("body_snippet")) for k, v in chain_results.items()},
        }

        if any(_looks_like_cycle_thenables_error(res) for res in chain_results.values()):
            journal.add_event(
                "dec2025-post-35351",
                "Chain probe indicates PR#35351 via explicit cycleProtection signature",
                data={"endpoint": endpoint},
            )
            return "post_35351", chain_evidence

        if any(_is_chain_signature_uninterpretable(sig) for sig in chain_sigs.values()) or any(
            _looks_like_non_rsc_transport_error(res) for res in chain_results.values()
        ):
            journal.add_event(
                "dec2025-post-35345-unknown",
                "Promise-chain probes not interpretable (timeouts/HTML/transport/validation)",
                data={"endpoint": endpoint, "chain_probe_sigs": dict(chain_sigs)},
            )
            return "post_35345_unknown", {**chain_evidence, "reason": "Promise-chain probes not interpretable (timeouts/HTML/transport/validation)"}

        if not _chain_has_decode_evidence(chain_sigs, baseline_sigs):
            journal.add_event(
                "dec2025-post-35345-unknown",
                "Promise-chain probes did not show stable RSC decode signatures; treating PR#35351 fingerprint as unknown",
                data={"endpoint": endpoint, "chain_probe_sigs": dict(chain_sigs)},
            )
            return "post_35345_unknown", {
                **chain_evidence,
                "reason": "Promise-chain probes did not show stable RSC decode signatures; treating PR#35351 fingerprint as unknown",
            }

        low_sig = chain_sigs.get(depths[0], "")
        high_sig = chain_sigs.get(depths[-1], "")
        threshold_like = bool(low_sig and high_sig and low_sig != high_sig)

        if threshold_like:
            journal.add_event(
                "dec2025-post-35351",
                "Bounded chain probes indicate PR#35351-like threshold behavior",
                data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
            )
            return "post_35351", chain_evidence

        journal.add_event(
            "dec2025-post-35345-pre-35351",
            "Bounded chain probes found no threshold behavior (incomplete fix)",
            data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
        )
        return "post_35345_pre_35351", chain_evidence

    def _fingerprint_patch_level(
        self,
        base_url: str,
        detect_context: dict | None,
        *,
        journal: PocJournal,
    ) -> tuple[PatchFingerprintWithUnknown | None, dict[str, Any], str]:
        cache = _default_cache()
        framework = self._framework_from_tags(detect_context)
        endpoints = self._candidate_endpoints(base_url, detect_context)
        if not endpoints and framework != "nextjs":
            journal.add_event(
                "dec2025-fingerprint-skip",
                "No candidate Flight protocol endpoints discovered; cannot fingerprint patch level",
                data={"framework": framework, "base_url": base_url},
            )
            return None, {"reason": "No candidate Flight protocol endpoints discovered"}, framework

        prefix_parts: list[tuple[str, str]] | None = None
        wire_action_id: str | None = None
        if framework == "react-router":
            wire_action_id = _react_router_action_id(detect_context)
            if not wire_action_id:
                journal.add_event(
                    "dec2025-fingerprint-skip",
                    "React Router Server Function ID not discovered; cannot probe Flight protocol payload deserialization",
                    data={"framework": framework},
                )
                return None, {"reason": "React Router Server Function ID not discovered; cannot probe Flight protocol payload deserialization"}, framework
            prefix_parts = [(f"1_$ACTION_ID_{wire_action_id}", "")]

        if framework == "expo":
            endpoints = [_expo_random_action_url(str(endpoint)) for endpoint in endpoints]

        def _probe_endpoints(
            probe_endpoints: list[str],
            *,
            request_config: RscRequestConfig,
            action_id_override: str | None,
            nextjs_server_ref_marker: str | None = None,
        ) -> tuple[PatchFingerprintWithUnknown | None, dict[str, Any]]:
            if not probe_endpoints:
                journal.add_event(
                    "dec2025-fingerprint-skip",
                    "No candidate Flight protocol endpoints discovered; skipping marker probes",
                    data={"framework": framework},
                )
                return None, {"reason": "No candidate Flight protocol endpoints discovered"}

            saw_decode_surface = False
            saw_action_not_found = False
            saw_html = False
            saw_html_with_rsc_vary = False
            html_endpoints: list[str] = []
            html_rsc_vary_endpoints: list[str] = []
            for endpoint in probe_endpoints:
                if framework == "nextjs":
                    if action_id_override:
                        action_id = action_id_override
                    else:
                        cache_key = _cache_key(endpoint, "dec2025_nextjs_invalid_action_id")
                        cached_id = cache.get(cache_key)
                        if isinstance(cached_id, str) and cached_id:
                            action_id = cached_id
                        else:
                            action_id = generate_action_id()
                            cache[cache_key] = action_id
                else:
                    action_id = None

                # 1) Side-effect safe control probe: confirm Flight protocol payload deserialization reachability.
                control = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_control_safe:{action_id or ''}",
                    send_dec2025_safe_control_probe,
                    request_config=request_config,
                    action_id=action_id,
                    prefix_parts=prefix_parts,
                )

                control_sig = _probe_signature(control)
                if control_sig == "next_action_not_found":
                    saw_action_not_found = True
                if control_sig == "html" and framework == "nextjs":
                    saw_html = True
                    html_endpoints.append(endpoint)
                    vary = header_value(control.get("headers") or {}, "vary").lower()
                    if vary:
                        vary_parts = [part.strip().lower() for part in vary.split(",")]
                        if any(part == "rsc" for part in vary_parts):
                            saw_html_with_rsc_vary = True
                            html_rsc_vary_endpoints.append(endpoint)
                if (
                    control_sig in {"timeout", "html"}
                    or _is_status_only_signature(control_sig)
                    or _looks_like_non_rsc_transport_error(control)
                ):
                    continue

                if control_sig != "next_action_not_found":
                    saw_decode_surface = True

                # 2) Learn the endpoint baseline "connection closed" signature using a missing-chunk reference.
                conn_probe = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_conn_sig:{action_id or ''}",
                    send_dec2025_missing_chunk_probe,
                    request_config=request_config,
                    action_id=action_id,
                    prefix_parts=prefix_parts,
                )
                conn_sig = _probe_signature(conn_probe)
                if _is_status_only_signature(conn_sig) or _looks_like_non_rsc_transport_error(conn_probe):
                    continue

                marker_h = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_marker_root_h:{action_id or ''}",
                    send_dec2025_server_reference_marker_root_probe,
                    request_config=request_config,
                    action_id=action_id,
                    server_ref_marker="h",
                    prefix_parts=prefix_parts,
                )
                marker_f = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_marker_root_f:{action_id or ''}",
                    send_dec2025_server_reference_marker_root_probe,
                    request_config=request_config,
                    action_id=action_id,
                    server_ref_marker="F",
                    prefix_parts=prefix_parts,
                )

                sig_h = _probe_signature(marker_h)
                sig_f = _probe_signature(marker_f)

                marker_evidence: dict[str, Any] = {
                    "endpoint": endpoint,
                    "framework": framework,
                    "action_id": action_id,
                    "nextjs_server_ref_marker": nextjs_server_ref_marker,
                    "control_sig": control_sig,
                    "conn_sig": conn_sig,
                    "conn_body_snippet": _truncate(conn_probe.get("body") or conn_probe.get("body_snippet")),
                    "marker_h_sig": sig_h,
                    "marker_f_sig": sig_f,
                    "marker_h_status_code": marker_h.get("status_code"),
                    "marker_f_status_code": marker_f.get("status_code"),
                    "marker_h_body_snippet": _truncate(marker_h.get("body") or marker_h.get("body_snippet")),
                    "marker_f_body_snippet": _truncate(marker_f.get("body") or marker_f.get("body_snippet")),
                }
                marker_evidence["pr35345_evidence_strength"] = _pr35345_evidence_strength(
                    {"control": control, "conn": conn_probe, "marker_h": marker_h, "marker_f": marker_f},
                    [control_sig, conn_sig, sig_h, sig_f],
                )
                marker_evidence.update(
                    _flight_major_evidence(
                        {
                            "control": control,
                            "conn": conn_probe,
                            "marker_h": marker_h,
                            "marker_f": marker_f,
                        }
                    )
                )
                if wire_action_id:
                    marker_evidence["wire_action_id"] = wire_action_id

                if sig_h == "next_action_not_found" or sig_f == "next_action_not_found":
                    saw_action_not_found = True
                    continue

                saw_decode_surface = True

                h_is_conn = _matches_connection_closed(sig_h, conn_sig)
                f_is_conn = _matches_connection_closed(sig_f, conn_sig)

                # Waku: some pre-PR#35345 builds collapse `$h` and `$F` to the same baseline
                # (often an Internal Server Error), defeating the `$h` vs `$F` differential.
                # In that case, fall back to comparing the `$h` marker probe against the safe
                # control signature, which remains stable across the Dec 2025 patch chain.
                if framework == "waku" and h_is_conn and f_is_conn and sig_h and control_sig and sig_h != control_sig:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        cache,
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "pr35345_marker_method": "waku_fallback_h_vs_control",
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )
                    journal.add_event(
                        "dec2025-pre-35345",
                        "Waku marker probes match baseline but differ from control signature (treat as pre-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "control_sig": control_sig, "conn_sig": conn_sig},
                    )
                    return "pre_35345", {**marker_evidence, "waku_marker_fallback": "h_vs_control"}

                # If marker probes are inconclusive (both match baseline or both differ), retry once to
                # reduce flakiness from transient connection drops under load.
                if h_is_conn == f_is_conn:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        cache,
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )

                    h_is_conn_retest = _matches_connection_closed(sig_h_retest, conn_sig)
                    f_is_conn_retest = _matches_connection_closed(sig_f_retest, conn_sig)
                    if h_is_conn_retest and not f_is_conn_retest:
                        marker_evidence["pr35345_marker_method"] = "marker_retry_h_is_conn_f_not"
                        journal.add_event(
                            "dec2025-pre-35345",
                            "Marker retest indicates `$h` unsupported and `$F` supported (pre-PR#35345)",
                            data={"endpoint": endpoint, "sig_h": sig_h_retest, "sig_f": sig_f_retest, "conn_sig": conn_sig},
                        )
                        if framework == "nextjs" and nextjs_server_ref_marker == "h":
                            marker_evidence["pr35345_marker_method"] = "nextjs_hint_h_override_marker_retry_h_is_conn_f_not"
                            journal.add_event(
                                "dec2025-post-35345",
                                "Next.js bundles indicate `$h` server reference marker; treating marker differential as post-PR#35345 and probing PR#35351 chain",
                                data={"endpoint": endpoint, "sig_h": sig_h_retest, "sig_f": sig_f_retest, "conn_sig": conn_sig},
                            )
                            baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                            return self._probe_post_35345_chain(
                                cache,
                                endpoint,
                                framework=framework,
                                request_config=request_config,
                                action_id=action_id,
                                prefix_parts=prefix_parts,
                                baseline_sigs=baseline_sigs,
                                marker_evidence=marker_evidence,
                                journal=journal,
                            )
                        return "pre_35345", marker_evidence

                    if f_is_conn_retest and not h_is_conn_retest:
                        marker_evidence["pr35345_marker_method"] = "marker_retry_f_is_conn_h_not"
                        journal.add_event(
                            "dec2025-post-35345",
                            "Marker retest indicates `$h` supported and `$F` unsupported (post-PR#35345)",
                            data={"endpoint": endpoint, "sig_h": sig_h_retest, "sig_f": sig_f_retest, "conn_sig": conn_sig},
                        )
                        baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                        return self._probe_post_35345_chain(
                            cache,
                            endpoint,
                            framework=framework,
                            request_config=request_config,
                            action_id=action_id,
                            prefix_parts=prefix_parts,
                            baseline_sigs=baseline_sigs,
                            marker_evidence=marker_evidence,
                            journal=journal,
                        )

                # pre-PR#35345: $h unsupported, $F supported
                if h_is_conn and not f_is_conn:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        cache,
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "pr35345_marker_method": "marker_diff_h_is_conn_f_not",
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )
                    journal.add_event(
                        "dec2025-pre-35345",
                        "Differential marker probes indicate `$h` unsupported and `$F` supported (pre-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                    )
                    if framework == "nextjs" and nextjs_server_ref_marker == "h":
                        marker_evidence["pr35345_marker_method"] = "nextjs_hint_h_override_h_is_conn_f_not"
                        journal.add_event(
                            "dec2025-post-35345",
                            "Next.js bundles indicate `$h` server reference marker; treating marker differential as post-PR#35345 and probing PR#35351 chain",
                            data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                        )
                        baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                        return self._probe_post_35345_chain(
                            cache,
                            endpoint,
                            framework=framework,
                            request_config=request_config,
                            action_id=action_id,
                            prefix_parts=prefix_parts,
                            baseline_sigs=baseline_sigs,
                            marker_evidence=marker_evidence,
                            journal=journal,
                        )

                    return "pre_35345", marker_evidence

                # post-PR#35345: $F unsupported, $h supported
                if f_is_conn and not h_is_conn:
                    sig_h_retest, sig_f_retest, stability_score, stability = self._retest_marker_sigs(
                        cache,
                        endpoint,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        prior_sigs={"h": sig_h, "F": sig_f},
                    )
                    marker_evidence.update(
                        {
                            "pr35345_marker_method": "marker_diff_f_is_conn_h_not",
                            "marker_h_sig_retest": sig_h_retest,
                            "marker_f_sig_retest": sig_f_retest,
                            "pr35345_marker_stability": stability,
                            "pr35345_marker_stability_score": stability_score,
                            "pr35345_marker_stable": stability_score == 2,
                        }
                    )
                    journal.add_event(
                        "dec2025-post-35345",
                        "Differential marker probes indicate `$h` supported and `$F` unsupported (post-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                    )
                    baseline_sigs = [control_sig, conn_sig, sig_h, sig_f]
                    return self._probe_post_35345_chain(
                        cache,
                        endpoint,
                        framework=framework,
                        request_config=request_config,
                        action_id=action_id,
                        prefix_parts=prefix_parts,
                        baseline_sigs=baseline_sigs,
                        marker_evidence=marker_evidence,
                        journal=journal,
                    )

            if not saw_decode_surface:
                evidence: dict[str, Any] = {
                    "reason": "No reachable Flight protocol payload deserialization surface found (HTML/timeouts)",
                    "endpoints": probe_endpoints,
                }
                if framework == "nextjs" and (saw_action_not_found or saw_html):
                    evidence["needs_valid_action_id"] = True
                    evidence["saw_action_not_found"] = saw_action_not_found
                    evidence["saw_html"] = saw_html
                    evidence["saw_html_with_rsc_vary"] = saw_html_with_rsc_vary
                    if html_endpoints:
                        evidence["html_endpoints"] = html_endpoints
                    if html_rsc_vary_endpoints:
                        evidence["html_rsc_vary_endpoints"] = html_rsc_vary_endpoints
                    journal.add_event(
                        "dec2025-nextjs-action-id-required",
                        "Next.js did not return a Flight payload for the action probe; a valid Next-Action header may be required",
                        data={"endpoints": probe_endpoints, "html_endpoints": html_endpoints, "html_rsc_vary_endpoints": html_rsc_vary_endpoints},
                    )

                journal.add_event(
                    "dec2025-fingerprint-failed",
                    "No reachable Flight protocol payload deserialization surface found (HTML/timeouts)",
                    data={"endpoints": probe_endpoints},
                )
                return None, evidence

            journal.add_event(
                "dec2025-fingerprint-inconclusive",
                "Marker probes were inconclusive on all candidate endpoints",
                data={"endpoints": probe_endpoints},
            )
            return None, {"reason": "Marker probes were inconclusive on all candidate endpoints", "endpoints": probe_endpoints}

        if framework == "nextjs" and base_url:
            endpoints_server = list(endpoints)

            cache_key_marker = _cache_key(base_url, "dec2025_nextjs_server_ref_marker")
            cached_marker = cache.get(cache_key_marker)
            if isinstance(cached_marker, str) and cached_marker in {"h", "F"}:
                nextjs_marker_hint: str | None = cached_marker
            else:
                try:
                    nextjs_marker_hint = discover_nextjs_server_reference_marker(base_url)
                except Exception as exc:
                    journal.add_event(
                        "dec2025-nextjs-marker-discovery-error",
                        "Failed to discover Next.js server reference marker from client bundles",
                        data={"endpoint": base_url, "error_type": exc.__class__.__name__, "error_message": str(exc)},
                    )
                    nextjs_marker_hint = None
                cache[cache_key_marker] = nextjs_marker_hint

            if nextjs_marker_hint == "F":
                journal.add_event(
                    "dec2025-pre-35345",
                    "Next.js client bundles indicate `$F` server reference marker (pre-PR#35345 hint; confirming via probes)",
                    data={"endpoint": base_url},
                )

            request_config = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header="Next-Action")

            # First pass: try no-discovery random IDs (some Next.js builds still decode even if the action is unknown).
            patch, evidence = _probe_endpoints(
                endpoints_server,
                request_config=request_config,
                action_id_override=None,
                nextjs_server_ref_marker=nextjs_marker_hint,
            )
            if patch is not None:
                return (
                    patch,
                    {
                        **evidence,
                        "nextjs_action_id_policy": "random_only",
                        "nextjs_server_ref_marker": nextjs_marker_hint,
                    },
                    framework,
                )

            if isinstance(evidence, dict) and evidence.get("needs_valid_action_id") is True:
                cache_key = _cache_key(base_url, "dec2025_nextjs_action_id")
                cached_id = cache.get(cache_key)
                if isinstance(cached_id, str) and cached_id:
                    discovered_id = cached_id
                else:
                    try:
                        discovered_id = discover_nextjs_action_id(base_url)
                    except Exception as exc:
                        journal.add_event(
                            "dec2025-nextjs-action-id-discovery-error",
                            "Failed to discover a valid Next.js action ID; marker probes may remain inconclusive",
                            data={"endpoint": base_url, "error_type": exc.__class__.__name__, "error_message": str(exc)},
                        )
                        discovered_id = None
                    cache[cache_key] = discovered_id

                if discovered_id:
                    patch2, evidence2 = _probe_endpoints(
                        endpoints_server,
                        request_config=request_config,
                        action_id_override=str(discovered_id),
                        nextjs_server_ref_marker=nextjs_marker_hint,
                    )
                    if patch2 is not None:
                        return (
                            patch2,
                            {
                                **(evidence2 or {}),
                                "nextjs_action_id_policy": "random_then_discovered",
                                "nextjs_server_ref_marker": nextjs_marker_hint,
                            },
                            framework,
                        )
                    evidence = {**(evidence2 or {}), "nextjs_action_id_policy": "random_then_discovered", "nextjs_server_ref_marker": nextjs_marker_hint}
                else:
                    evidence = {**evidence, "nextjs_action_id_policy": "random_then_discovered", "nextjs_action_id_discovered": False, "nextjs_server_ref_marker": nextjs_marker_hint}

            return (
                patch,
                {
                    **evidence,
                    "nextjs_action_id_policy": str((evidence or {}).get("nextjs_action_id_policy") or "random_only"),
                    "nextjs_server_ref_marker": nextjs_marker_hint,
                },
                framework,
            )

        if not endpoints:
            journal.add_event(
                "dec2025-fingerprint-skip",
                "No candidate Flight protocol endpoints discovered; cannot fingerprint patch level",
                data={"framework": framework, "base_url": base_url},
            )
            return None, {"reason": "No candidate Flight protocol endpoints discovered"}, framework

        if framework == "expo":
            request_config = RscRequestConfig(
                method="POST",
                base_headers={"Accept": "text/x-component", "expo-platform": "web"},
                action_id_header=None,
            )
        elif framework == "react-router":
            request_config = RscRequestConfig(
                method="POST",
                base_headers={"Accept": "text/x-component", "rsc-action-id": str(wire_action_id or "")},
                action_id_header=None,
            )
        else:
            request_config = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header=None)

        patch, evidence = _probe_endpoints(endpoints, request_config=request_config, action_id_override=None)
        return patch, evidence, framework

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        journal = get_current_journal() or PocJournal()

        invocation_enabled = (detect_context or {}).get("invocation_enabled")
        invocation_confidence = (detect_context or {}).get("invocation_confidence")

        context = get_scan_context()
        cache_key = f"rsc_dec2025_fingerprint::{base_url}"
        cached = context.extra.get(cache_key) if isinstance(context.extra, dict) else None
        if isinstance(cached, dict) and "patch_fingerprint" in cached and "evidence" in cached and "framework" in cached:
            patch_level = cached.get("patch_fingerprint")
            evidence = cached.get("evidence") or {}
            framework = str(cached.get("framework") or "rsc")
            journal.add_event(
                "dec2025-cache-hit",
                "Reused cached Dec 2025 patch fingerprint for target",
                data={"cache_key": cache_key, "patch_fingerprint": patch_level, "framework": framework},
            )
        else:
            journal.add_event(
                "dec2025-cache-miss",
                "No cached Dec 2025 patch fingerprint; probing endpoints",
                data={"cache_key": cache_key},
            )
            patch_level, evidence, framework = self._fingerprint_patch_level(
                base_url,
                detect_context,
                journal=journal,
            )
            cache_entry = {"patch_fingerprint": patch_level, "evidence": evidence, "framework": framework}
            if isinstance(context.extra, dict):
                context.extra[cache_key] = dict(cache_entry)

        interpreter = RscDec2025Interpreter(cve_id=self.spec.cve_id, framework=framework)
        return interpreter.to_report(
            patch_fingerprint=patch_level,
            detected_versions=detected_versions,
            evidence=evidence,
            journal=journal,
            invocation_enabled=invocation_enabled,
            invocation_confidence=invocation_confidence,
        )


__all__ = ["ReactServerComponentsDec2025Assessor", "RscDec2025Spec"]
