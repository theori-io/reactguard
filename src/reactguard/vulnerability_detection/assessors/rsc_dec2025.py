from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Assessors for Dec 2025 React Server Components advisories (CVE-2025-55184/67779/55183)."""

import hashlib
from dataclasses import dataclass
from typing import Any, Literal
from urllib.parse import urlsplit, urlunsplit

from ...http.url import build_endpoint_candidates
from ...rsc.types import RscRequestConfig
from ...utils.actions import generate_action_id
from ...utils.context import get_scan_context
from ..constants import ERROR_BODY_SNIPPET_LIMIT
from ..interpreters.digest import ERROR_DIGEST_PATTERN
from ..interpreters.rsc_dec2025_interpreter import PatchFingerprintWithUnknown, RscDec2025Interpreter
from ..journal import PocJournal, get_current_journal
from ..probes.rsc_dec2025_probe import (
    send_dec2025_missing_chunk_probe,
    send_dec2025_nextjs_promise_chain_root_probe,
    send_dec2025_promise_chain_probe,
    send_dec2025_safe_control_probe,
    send_dec2025_server_reference_marker_root_probe,
)
from ..probes.rsc_patch_fingerprint_probe import (
    discover_nextjs_action_id,
    discover_nextjs_server_reference_marker,
)
from .base import BaseAssessor


@dataclass(frozen=True)
class RscDec2025Spec:
    cve_id: Literal["CVE-2025-55184", "CVE-2025-67779", "CVE-2025-55183"]
    title: str


def _truncate(text: str | None, limit: int = ERROR_BODY_SNIPPET_LIMIT) -> str:
    if not text:
        return ""
    if len(text) <= limit:
        return text
    return text[:limit] + "â€¦"


def _body_contains(result: dict[str, Any] | None, needle: str) -> bool:
    if not result or not needle:
        return False
    body = str(result.get("body") or result.get("body_snippet") or "")
    return needle.lower() in body.lower()


def _is_timeout(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    error_type = str(result.get("error_type") or "").lower()
    if "timeout" in error_type:
        return True
    error_message = str(result.get("error_message") or "").lower()
    return "timed out" in error_message or "timeout" in error_message


def _header_value(result: dict[str, Any] | None, header_name: str) -> str:
    if not result or not header_name:
        return ""
    headers = result.get("headers") or {}
    if not isinstance(headers, dict):
        return ""
    for key in (header_name, header_name.lower(), header_name.title()):
        if key in headers:
            return str(headers.get(key) or "").strip()
    # Slow fallback: case-insensitive lookup across keys.
    lower = header_name.lower()
    for key, value in headers.items():
        if str(key).lower() == lower:
            return str(value or "").strip()
    return ""


def _looks_like_html(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    content_type = _header_value(result, "content-type").lower()
    body = str(result.get("body") or result.get("body_snippet") or "").lstrip()
    if not body:
        return "text/html" in content_type
    lowered = body[:256].lower()
    if lowered.startswith("<!doctype") or lowered.startswith("<html") or "<html" in lowered:
        return True
    return False


def _looks_like_cycle_thenables_error(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    if _body_contains(result, "cannot have cyclic thenables"):
        return True
    if _body_contains(result, "minified react error #569") or _body_contains(result, "react.dev/errors/569"):
        return True
    return False


def _looks_like_next_action_not_found(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    if _header_value(result, "x-nextjs-action-not-found") == "1":
        return True
    body = str(result.get("body") or result.get("body_snippet") or "").strip().lower()
    return body == "server action not found."


def _looks_like_connection_closed(result: dict[str, Any] | None) -> bool:
    return _body_contains(result, "connection closed")


def _extract_digest(result: dict[str, Any] | None) -> str:
    if not result:
        return ""
    body = str(result.get("body") or result.get("body_snippet") or "")
    if not body:
        return ""
    match = ERROR_DIGEST_PATTERN.search(body)
    return match.group(1) if match else ""


def _probe_signature(result: dict[str, Any] | None) -> str:
    """
    Extract a stable signature from a probe response.

    Prefer:
    - explicit cycleProtection signals (dev/prod React error link)
    - digest tokens (prod)
    - stable textual markers (connection closed / action-not-found)
    - status+snippet fallback
    """
    if not result:
        return ""
    if _is_timeout(result):
        return "timeout"
    if _looks_like_cycle_thenables_error(result):
        return "cycle_thenables"
    if _looks_like_connection_closed(result):
        return "connection_closed"

    digest = _extract_digest(result)
    if digest:
        return f"digest:{digest}"
    if _looks_like_next_action_not_found(result):
        return "next_action_not_found"
    if _looks_like_html(result):
        return "html"

    body = str(result.get("body") or result.get("body_snippet") or "").strip().lower()
    if not body:
        return f"status:{result.get('status_code')}"
    return body[:160]


def _matches_connection_closed(sig: str, conn_sig: str) -> bool:
    if not sig:
        return False
    if sig == "connection_closed":
        return True
    return bool(conn_sig and sig == conn_sig)


def _default_cache() -> dict[str, Any]:
    extra = get_scan_context().extra
    if extra is None:
        return {}
    cache = extra.setdefault("rsc_dec2025_probe_cache", {})
    if not isinstance(cache, dict):
        cache = {}
        extra["rsc_dec2025_probe_cache"] = cache
    return cache


def _cache_key(endpoint: str, key: str) -> str:
    return f"{endpoint}::{key}"


_DEC2025_CHAIN_EXPECTED_BOUNDARY = 1000
_DEC2025_CHAIN_DELTA = 10


def _expo_random_action_url(url: str) -> str:
    """
    Expo Router Server Functions encode the target module/export in the URL path (ACTION_...).

    Use a deterministic, non-existent action target so we never invoke unknown app code while still
    exercising decodeReply() before the router attempts module resolution.
    """
    if not url:
        return url
    parts = urlsplit(url)
    marker = "/ACTION_"
    if marker not in parts.path:
        return url
    base_path, _ = parts.path.split(marker, 1)
    token = hashlib.sha256(url.encode("utf-8")).hexdigest()[:12]
    new_path = f"{base_path}{marker}./reactguard_probe_{token}.ts/probe.txt"
    return urlunsplit((parts.scheme, parts.netloc, new_path, parts.query, parts.fragment))


def _react_router_action_id(detect_context: dict | None) -> str | None:
    signals = (detect_context or {}).get("signals") or {}
    action_ids = signals.get("react_router_server_action_ids")
    if not isinstance(action_ids, list) or not action_ids:
        return None
    first = str(action_ids[0] or "").strip()
    return first or None


class ReactServerComponentsDec2025Assessor(BaseAssessor):
    """
    Non-DoS assessor for the Dec 2025 RSC advisories.

    Fingerprints patch sets using bounded probes:
    - PR #35345 fingerprint: server reference marker `$h` parsing behavior ($F vs $h differential).
    - PR #35351 fingerprint: finite promise chain threshold (cycleProtection guard).
    """

    framework_name = "rsc"

    def __init__(self, spec: RscDec2025Spec):
        self.spec = spec
        self.cve_id = spec.cve_id

    def _candidate_endpoints(self, base_url: str, detect_context: dict | None) -> list[str]:
        action_urls = (detect_context or {}).get("server_action_endpoints") or []
        if isinstance(action_urls, list) and action_urls:
            return [str(u) for u in action_urls if u]

        tag_set = set((detect_context or {}).get("tags") or [])
        if not base_url:
            return []

        candidates: list[str] = []
        if "waku" in tag_set:
            candidates.extend(build_endpoint_candidates(base_url, "/RSC/_"))
        else:
            candidates.append(str(base_url))

        return list(dict.fromkeys([c for c in candidates if c]))

    @staticmethod
    def _framework_from_tags(detect_context: dict | None) -> str:
        tag_set = set((detect_context or {}).get("tags") or [])
        if {"nextjs", "nextjs-app-router"} & tag_set:
            return "nextjs"
        if "waku" in tag_set:
            return "waku"
        if "expo" in tag_set or "expo-server-actions" in tag_set:
            return "expo"
        if any(tag.startswith("react-router") for tag in tag_set):
            return "react-router"
        return "rsc"

    def _cached_call(self, cache: dict[str, Any], endpoint: str, key: str, func, **kwargs) -> dict[str, Any]:
        ck = _cache_key(endpoint, key)
        existing = cache.get(ck)
        if isinstance(existing, dict):
            return existing
        result = func(endpoint, **kwargs)
        cache[ck] = result
        return result

    def _probe_chain(
        self,
        cache: dict[str, Any],
        endpoint: str,
        *,
        chain_depth: int,
        framework: str,
        request_config: RscRequestConfig,
        action_id: str | None,
        prefix_parts: list[tuple[str, str]] | None = None,
    ) -> dict[str, Any]:
        if framework == "nextjs" and action_id:
            return self._cached_call(
                cache,
                endpoint,
                f"dec2025_chain_root_{chain_depth}:{action_id}",
                send_dec2025_nextjs_promise_chain_root_probe,
                request_config=request_config,
                action_id=action_id,
                chain_depth=chain_depth,
                prefix_parts=prefix_parts,
            )
        return self._cached_call(
            cache,
            endpoint,
            f"dec2025_chain_{chain_depth}:{action_id or ''}",
            send_dec2025_promise_chain_probe,
            request_config=request_config,
            action_id=action_id,
            chain_depth=chain_depth,
            prefix_parts=prefix_parts,
        )

    def _fingerprint_patch_level(
        self,
        base_url: str,
        detect_context: dict | None,
        *,
        journal: PocJournal,
    ) -> tuple[PatchFingerprintWithUnknown | None, dict[str, Any], str]:
        cache = _default_cache()
        framework = self._framework_from_tags(detect_context)
        endpoints = self._candidate_endpoints(base_url, detect_context)
        if not endpoints and framework != "nextjs":
            return None, {"reason": "No candidate Server Functions endpoints discovered"}, framework

        prefix_parts: list[tuple[str, str]] | None = None
        wire_action_id: str | None = None
        if framework == "react-router":
            wire_action_id = _react_router_action_id(detect_context)
            if not wire_action_id:
                return None, {"reason": "React Router Server Action ID not discovered; cannot probe decode surface"}, framework
            prefix_parts = [(f"1_$ACTION_ID_{wire_action_id}", "")]

        if framework == "expo":
            endpoints = [_expo_random_action_url(str(endpoint)) for endpoint in endpoints]

        def _probe_endpoints(
            probe_endpoints: list[str],
            *,
            request_config: RscRequestConfig,
            action_id_override: str | None,
        ) -> tuple[PatchFingerprintWithUnknown | None, dict[str, Any]]:
            if not probe_endpoints:
                return None, {"reason": "No candidate Server Functions endpoints discovered"}

            saw_decode_surface = False
            for endpoint in probe_endpoints:
                if framework == "nextjs":
                    if action_id_override:
                        action_id = action_id_override
                    else:
                        cache_key = _cache_key(endpoint, "dec2025_nextjs_invalid_action_id")
                        cached_id = cache.get(cache_key)
                        if isinstance(cached_id, str) and cached_id:
                            action_id = cached_id
                        else:
                            action_id = generate_action_id()
                            cache[cache_key] = action_id
                else:
                    action_id = None

                # 1) Side-effect safe control probe: confirm decode surface reachability.
                control = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_control_safe:{action_id or ''}",
                    send_dec2025_safe_control_probe,
                    request_config=request_config,
                    action_id=action_id,
                    prefix_parts=prefix_parts,
                )

                control_sig = _probe_signature(control)
                if control_sig in {"timeout", "html"}:
                    continue

                if control_sig != "next_action_not_found":
                    saw_decode_surface = True

                # 2) Learn the endpoint baseline "connection closed" signature using a missing-chunk reference.
                conn_probe = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_conn_sig:{action_id or ''}",
                    send_dec2025_missing_chunk_probe,
                    request_config=request_config,
                    action_id=action_id,
                    prefix_parts=prefix_parts,
                )
                conn_sig = _probe_signature(conn_probe)

                marker_h = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_marker_root_h:{action_id or ''}",
                    send_dec2025_server_reference_marker_root_probe,
                    request_config=request_config,
                    action_id=action_id,
                    server_ref_marker="h",
                    prefix_parts=prefix_parts,
                )
                marker_f = self._cached_call(
                    cache,
                    endpoint,
                    f"dec2025_marker_root_f:{action_id or ''}",
                    send_dec2025_server_reference_marker_root_probe,
                    request_config=request_config,
                    action_id=action_id,
                    server_ref_marker="F",
                    prefix_parts=prefix_parts,
                )

                sig_h = _probe_signature(marker_h)
                sig_f = _probe_signature(marker_f)

                marker_evidence: dict[str, Any] = {
                    "endpoint": endpoint,
                    "framework": framework,
                    "action_id": action_id,
                    "control_sig": control_sig,
                    "conn_sig": conn_sig,
                    "conn_body_snippet": _truncate(conn_probe.get("body") or conn_probe.get("body_snippet")),
                    "marker_h_sig": sig_h,
                    "marker_f_sig": sig_f,
                    "marker_h_status_code": marker_h.get("status_code"),
                    "marker_f_status_code": marker_f.get("status_code"),
                    "marker_h_body_snippet": _truncate(marker_h.get("body") or marker_h.get("body_snippet")),
                    "marker_f_body_snippet": _truncate(marker_f.get("body") or marker_f.get("body_snippet")),
                }
                if wire_action_id:
                    marker_evidence["wire_action_id"] = wire_action_id

                if sig_h == "next_action_not_found" or sig_f == "next_action_not_found":
                    continue

                saw_decode_surface = True

                h_is_conn = _matches_connection_closed(sig_h, conn_sig)
                f_is_conn = _matches_connection_closed(sig_f, conn_sig)

                # Waku: some pre-PR#35345 builds collapse `$h` and `$F` to the same baseline
                # (often an Internal Server Error), defeating the `$h` vs `$F` differential.
                # In that case, fall back to comparing the `$h` marker probe against the safe
                # control signature, which remains stable across the Dec 2025 patch chain.
                if framework == "waku" and h_is_conn and f_is_conn and sig_h and control_sig and sig_h != control_sig:
                    journal.add_event(
                        "dec2025-pre-35345",
                        "Waku marker probes match baseline but differ from control signature (treat as pre-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "control_sig": control_sig, "conn_sig": conn_sig},
                    )
                    return "pre_35345", {**marker_evidence, "waku_marker_fallback": "h_vs_control"}

                # pre-PR#35345: $h unsupported, $F supported
                if h_is_conn and not f_is_conn:
                    journal.add_event(
                        "dec2025-pre-35345",
                        "Differential marker probes indicate `$h` unsupported and `$F` supported (pre-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                    )
                    return "pre_35345", marker_evidence

                # post-PR#35345: $F unsupported, $h supported
                if f_is_conn and not h_is_conn:
                    journal.add_event(
                        "dec2025-post-35345",
                        "Differential marker probes indicate `$h` supported and `$F` unsupported (post-PR#35345)",
                        data={"endpoint": endpoint, "sig_h": sig_h, "sig_f": sig_f, "conn_sig": conn_sig},
                    )

                    expected_boundary = _DEC2025_CHAIN_EXPECTED_BOUNDARY
                    delta = _DEC2025_CHAIN_DELTA
                    raw_depths = [max(1, expected_boundary - delta), max(1, expected_boundary), max(1, expected_boundary + delta)]
                    depths = list(dict.fromkeys(raw_depths))

                    chain_results: dict[int, dict[str, Any]] = {}
                    chain_sigs: dict[int, str] = {}
                    for depth in depths:
                        result = self._probe_chain(
                            cache,
                            endpoint,
                            chain_depth=depth,
                            framework=framework,
                            request_config=request_config,
                            action_id=action_id,
                            prefix_parts=prefix_parts,
                        )
                        chain_results[depth] = result
                        chain_sigs[depth] = _probe_signature(result)

                    chain_evidence: dict[str, Any] = {
                        **marker_evidence,
                        "chain_expected_boundary": expected_boundary,
                        "chain_delta": delta,
                        "chain_probe_sigs": dict(chain_sigs),
                        "chain_probe_status_codes": {k: v.get("status_code") for k, v in chain_results.items()},
                        "chain_probe_body_snippets": {k: _truncate(v.get("body") or v.get("body_snippet")) for k, v in chain_results.items()},
                    }

                    if any(_looks_like_cycle_thenables_error(res) for res in chain_results.values()):
                        journal.add_event(
                            "dec2025-post-35351",
                            "Chain probe indicates PR#35351 via explicit cycleProtection signature",
                            data={"endpoint": endpoint},
                        )
                        return "post_35351", chain_evidence

                    uninterpretable = {"timeout", "next_action_not_found", "html"}
                    if any(sig in uninterpretable for sig in chain_sigs.values()):
                        return "post_35345_unknown", {**chain_evidence, "reason": "Promise-chain probes not interpretable (timeouts/HTML/validation)"}

                    low_sig = chain_sigs.get(depths[0], "")
                    high_sig = chain_sigs.get(depths[-1], "")
                    threshold_like = bool(low_sig and high_sig and low_sig != high_sig)

                    if threshold_like:
                        journal.add_event(
                            "dec2025-post-35351",
                            "Bounded chain probes indicate PR#35351-like threshold behavior",
                            data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
                        )
                        return "post_35351", chain_evidence
                    journal.add_event(
                        "dec2025-post-35345-pre-35351",
                        "Bounded chain probes found no threshold behavior (incomplete fix)",
                        data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
                    )
                    return "post_35345_pre_35351", chain_evidence

            if not saw_decode_surface:
                return None, {"reason": "No reachable Server Functions decode surface found (HTML/timeouts)", "endpoints": probe_endpoints}

            return None, {"reason": "Marker probes were inconclusive on all candidate endpoints", "endpoints": probe_endpoints}

        if framework == "nextjs" and base_url:
            endpoints_server = list(endpoints)

            cache_key_marker = _cache_key(base_url, "dec2025_nextjs_server_ref_marker")
            cached_marker = cache.get(cache_key_marker)
            if isinstance(cached_marker, str) and cached_marker in {"h", "F"}:
                nextjs_marker_hint: str | None = cached_marker
            else:
                try:
                    nextjs_marker_hint = discover_nextjs_server_reference_marker(base_url)
                except Exception:
                    nextjs_marker_hint = None
                cache[cache_key_marker] = nextjs_marker_hint

            if nextjs_marker_hint == "F":
                journal.add_event(
                    "dec2025-pre-35345",
                    "Next.js client bundles indicate `$F` server reference marker (treat as pre-PR#35345)",
                    data={"endpoint": base_url},
                )
                return (
                    "pre_35345",
                    {
                        "framework": framework,
                        "endpoints": endpoints_server,
                        "nextjs_server_ref_marker": nextjs_marker_hint,
                    },
                    framework,
                )

            request_config = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header="Next-Action")

            if nextjs_marker_hint == "h":

                def _probe_chain_only(
                    probe_endpoints: list[str],
                    *,
                    request_config: RscRequestConfig,
                    action_id_override: str | None,
                ) -> tuple[PatchFingerprintWithUnknown | None, dict[str, Any]]:
                    if not probe_endpoints:
                        return None, {"reason": "No candidate Server Functions endpoints discovered"}

                    saw_decode_surface = False
                    saw_action_not_found = False
                    for endpoint in probe_endpoints:
                        if action_id_override:
                            action_id = action_id_override
                        else:
                            cache_key = _cache_key(endpoint, "dec2025_nextjs_invalid_action_id")
                            cached_id = cache.get(cache_key)
                            if isinstance(cached_id, str) and cached_id:
                                action_id = cached_id
                            else:
                                action_id = generate_action_id()
                                cache[cache_key] = action_id

                        expected_boundary = _DEC2025_CHAIN_EXPECTED_BOUNDARY
                        delta = _DEC2025_CHAIN_DELTA
                        raw_depths = [max(1, expected_boundary - delta), max(1, expected_boundary), max(1, expected_boundary + delta)]
                        depths = list(dict.fromkeys(raw_depths))

                        chain_results: dict[int, dict[str, Any]] = {}
                        chain_sigs: dict[int, str] = {}
                        for depth in depths:
                            result = self._probe_chain(
                                cache,
                                endpoint,
                                chain_depth=depth,
                                framework=framework,
                                request_config=request_config,
                                action_id=action_id,
                                prefix_parts=prefix_parts,
                            )
                            chain_results[depth] = result
                            chain_sigs[depth] = _probe_signature(result)

                        chain_evidence: dict[str, Any] = {
                            "endpoint": endpoint,
                            "framework": framework,
                            "action_id": action_id,
                            "nextjs_server_ref_marker": nextjs_marker_hint,
                            "chain_expected_boundary": expected_boundary,
                            "chain_delta": delta,
                            "chain_probe_sigs": dict(chain_sigs),
                            "chain_probe_status_codes": {k: v.get("status_code") for k, v in chain_results.items()},
                            "chain_probe_body_snippets": {k: _truncate(v.get("body") or v.get("body_snippet")) for k, v in chain_results.items()},
                        }

                        if any(_looks_like_cycle_thenables_error(res) for res in chain_results.values()):
                            journal.add_event(
                                "dec2025-post-35351",
                                "Chain probe indicates PR#35351 via explicit cycleProtection signature",
                                data={"endpoint": endpoint},
                            )
                            return "post_35351", chain_evidence

                        if all(sig == "next_action_not_found" for sig in chain_sigs.values()):
                            saw_action_not_found = True
                            continue

                        if any(sig in {"timeout", "html"} for sig in chain_sigs.values()):
                            continue

                        saw_decode_surface = True
                        low_sig = chain_sigs.get(depths[0], "")
                        high_sig = chain_sigs.get(depths[-1], "")
                        threshold_like = bool(low_sig and high_sig and low_sig != high_sig)

                        if threshold_like:
                            journal.add_event(
                                "dec2025-post-35351",
                                "Bounded chain probes indicate PR#35351-like threshold behavior",
                                data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
                            )
                            return "post_35351", chain_evidence

                        journal.add_event(
                            "dec2025-post-35345-pre-35351",
                            "Bounded chain probes found no threshold behavior (incomplete fix)",
                            data={"endpoint": endpoint, "expected_boundary": expected_boundary, "delta": delta},
                        )
                        return "post_35345_pre_35351", chain_evidence

                    if saw_action_not_found and not saw_decode_surface:
                        return (
                            None,
                            {
                                "reason": "Next.js validated action IDs before decode; a valid Next-Action header is required",
                                "endpoints": probe_endpoints,
                                "needs_valid_action_id": True,
                            },
                        )
                    if not saw_decode_surface:
                        return None, {"reason": "No reachable Server Functions decode surface found (HTML/timeouts)", "endpoints": probe_endpoints}
                    return None, {"reason": "Chain probes were inconclusive on all candidate endpoints", "endpoints": probe_endpoints}

                # First pass: try no-discovery random IDs (some Next.js builds still decode even if the action is unknown).
                patch, evidence = _probe_chain_only(endpoints_server, request_config=request_config, action_id_override=None)
                if patch is not None:
                    return (
                        patch,
                        {
                            **evidence,
                            "nextjs_action_id_policy": "random_only",
                        },
                        framework,
                    )

                if isinstance(evidence, dict) and evidence.get("needs_valid_action_id") is True:
                    cache_key = _cache_key(base_url, "dec2025_nextjs_action_id")
                    cached_id = cache.get(cache_key)
                    if isinstance(cached_id, str) and cached_id:
                        discovered_id = cached_id
                    else:
                        try:
                            discovered_id = discover_nextjs_action_id(base_url)
                        except Exception:
                            discovered_id = None
                        cache[cache_key] = discovered_id

                    if discovered_id:
                        patch2, evidence2 = _probe_chain_only(
                            endpoints_server,
                            request_config=request_config,
                            action_id_override=str(discovered_id),
                        )
                        if patch2 is not None:
                            return (
                                patch2,
                                {
                                    **evidence2,
                                    "nextjs_action_id_policy": "random_then_discovered",
                                },
                                framework,
                            )
                        evidence = {**(evidence2 or {}), "nextjs_action_id_policy": "random_then_discovered"}
                    else:
                        evidence = {**evidence, "nextjs_action_id_policy": "random_then_discovered", "nextjs_action_id_discovered": False}

                return (
                    patch,
                    {
                        **evidence,
                        "nextjs_action_id_policy": str((evidence or {}).get("nextjs_action_id_policy") or "random_only"),
                    },
                    framework,
                )

            # First pass: try no-discovery random IDs (some Next.js builds still decode even if the action is unknown).
            patch, evidence = _probe_endpoints(endpoints_server, request_config=request_config, action_id_override=None)
            if patch is not None:
                return (
                    patch,
                    {
                        **evidence,
                        "nextjs_action_id_policy": "random_only",
                        "nextjs_server_ref_marker": nextjs_marker_hint,
                    },
                    framework,
                )

            return (
                patch,
                {
                    **evidence,
                    "nextjs_action_id_policy": "random_only",
                    "nextjs_server_ref_marker": nextjs_marker_hint,
                },
                framework,
            )

        if not endpoints:
            return None, {"reason": "No candidate Server Functions endpoints discovered"}, framework

        if framework == "expo":
            request_config = RscRequestConfig(
                method="POST",
                base_headers={"Accept": "text/x-component", "expo-platform": "web"},
                action_id_header=None,
            )
        elif framework == "react-router":
            request_config = RscRequestConfig(
                method="POST",
                base_headers={"Accept": "text/x-component", "rsc-action-id": str(wire_action_id or "")},
                action_id_header=None,
            )
        else:
            request_config = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header=None)

        patch, evidence = _probe_endpoints(endpoints, request_config=request_config, action_id_override=None)
        return patch, evidence, framework

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        journal = get_current_journal() or PocJournal()

        server_actions_enabled = (detect_context or {}).get("server_actions_enabled")
        server_actions_confidence = (detect_context or {}).get("server_actions_confidence")

        context = get_scan_context()
        cache_key = f"rsc_dec2025_fingerprint::{base_url}"
        cached = context.extra.get(cache_key) if isinstance(context.extra, dict) else None
        if isinstance(cached, dict) and "patch_fingerprint" in cached and "evidence" in cached and "framework" in cached:
            patch_level = cached.get("patch_fingerprint")
            evidence = cached.get("evidence") or {}
            framework = str(cached.get("framework") or "rsc")
        else:
            patch_level, evidence, framework = self._fingerprint_patch_level(
                base_url,
                detect_context,
                journal=journal,
            )
            if isinstance(context.extra, dict):
                context.extra[cache_key] = {"patch_fingerprint": patch_level, "evidence": evidence, "framework": framework}

        interpreter = RscDec2025Interpreter(cve_id=self.spec.cve_id, framework=framework)
        return interpreter.to_report(
            patch_fingerprint=patch_level,
            detected_versions=detected_versions,
            evidence=evidence,
            journal=journal,
            server_actions_enabled=server_actions_enabled,
            server_actions_confidence=server_actions_confidence,
        )


__all__ = ["ReactServerComponentsDec2025Assessor", "RscDec2025Spec"]
