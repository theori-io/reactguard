# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Signature extraction helpers for Dec 2025 RSC patch fingerprinting."""

from __future__ import annotations

import re
from collections.abc import Mapping
from typing import Any

from ...http.heuristics import response_looks_like_html
from ...http.models import HttpResponse
from ...rsc.heuristics import extract_error_digest, is_action_not_found_response, is_timeout_result, response_body_text
from ...utils.react_major import infer_react_major_from_flight_text
from ..constants import ERROR_BODY_SNIPPET_LIMIT

_TEMP_REF_CANNOT_ACCESS_RE = re.compile(
    r"^Cannot access [^.\n]{1,80} on the server\. "
    r"You cannot dot into a temporary client reference from a server component\. "
    r"You can only pass the value through to the client\.\s*$"
)

_TEMP_REF_OPAQUE_MESSAGE = (
    "Could not reference an opaque temporary reference. "
    "This is likely due to misconfiguring the temporaryReferences options on the server."
)


def truncate(text: str | None, limit: int = ERROR_BODY_SNIPPET_LIMIT) -> str:
    if not text:
        return ""
    if len(text) <= limit:
        return text
    return text[:limit] + "..."


def body_contains(result: Mapping[str, Any] | HttpResponse | None, needle: str) -> bool:
    if not result or not needle:
        return False
    body = response_body_text(result)
    return needle.lower() in body.lower()


def looks_like_cycle_thenables_error(result: Mapping[str, Any] | HttpResponse | None) -> bool:
    if not result:
        return False
    if body_contains(result, "cannot have cyclic thenables"):
        return True
    if body_contains(result, "minified react error #569") or body_contains(result, "react.dev/errors/569"):
        return True
    return False


def looks_like_temporary_reference_error(result: Mapping[str, Any] | HttpResponse | None) -> bool:
    """
    Return True when a response contains React RSC "temporary reference" decode errors.

    These errors are strong evidence that a probe reached React's RSC/Flight deserializer, even when the
    HTTP status/content-type is generic (e.g., 500 text/plain) or when infra produces timeouts.
    """
    if not result:
        return False
    body = response_body_text(result).strip()
    snippet = ""
    if isinstance(result, Mapping):
        snippet = str(result.get("body_snippet") or "").strip()
    for text in (body, snippet):
        if not text:
            continue
        if text == _TEMP_REF_OPAQUE_MESSAGE:
            return True
        if _TEMP_REF_CANNOT_ACCESS_RE.match(text):
            return True
    return False


def looks_like_connection_closed(result: Mapping[str, Any] | HttpResponse | None) -> bool:
    return body_contains(result, "connection closed")


def extract_digest(result: Mapping[str, Any] | HttpResponse | None) -> str:
    if not result:
        return ""
    body = response_body_text(result)
    return extract_error_digest(body) or ""


def probe_signature(result: Mapping[str, Any] | HttpResponse | None) -> str:
    """
    Extract a stable signature from a probe response.

    Prefer:
    - explicit cycleProtection signals (dev/prod React error link)
    - digest tokens (prod)
    - stable textual markers (connection closed / action-not-found)
    - status+snippet fallback
    """
    if not result:
        return ""
    if is_timeout_result(result):
        return "timeout"
    if looks_like_cycle_thenables_error(result):
        return "cycle_thenables"
    if looks_like_temporary_reference_error(result):
        return "temporary_reference"
    if looks_like_connection_closed(result):
        return "connection_closed"

    digest = extract_digest(result)
    if digest:
        return f"digest:{digest}"
    if is_action_not_found_response(result):
        return "next_action_not_found"
    if response_looks_like_html(result):
        return "html"

    body = response_body_text(result).strip().lower()
    if not body:
        status_code = result.status_code if isinstance(result, HttpResponse) else result.get("status_code")
        return f"status:{status_code}"
    return body[:160]


def infer_react_major_from_result(result: Mapping[str, Any] | HttpResponse | None) -> int | None:
    if not result:
        return None
    body = response_body_text(result)
    return infer_react_major_from_flight_text(body)


def flight_major_evidence(label_to_result: dict[str, Mapping[str, Any] | HttpResponse | None]) -> dict[str, Any]:
    majors: set[int] = set()
    sources: list[str] = []
    for label, result in label_to_result.items():
        major = infer_react_major_from_result(result)
        if major is None:
            continue
        majors.add(int(major))
        sources.append(str(label))

    if not majors:
        return {}

    out: dict[str, Any] = {
        "react_major_from_flight_majors": sorted(majors),
        "react_major_from_flight_sources": list(dict.fromkeys(sources)),
    }
    if len(majors) == 1:
        out["react_major_from_flight"] = next(iter(majors))
        out["react_major_from_flight_confidence"] = "high"
    else:
        out["react_major_from_flight_conflict"] = True
        out["react_major_from_flight_confidence"] = "medium"
    return out


__all__ = [
    "body_contains",
    "extract_digest",
    "flight_major_evidence",
    "infer_react_major_from_result",
    "looks_like_connection_closed",
    "looks_like_cycle_thenables_error",
    "looks_like_temporary_reference_error",
    "probe_signature",
    "truncate",
]
