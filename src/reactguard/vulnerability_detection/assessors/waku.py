# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Waku assessor for CVE-2025-55182."""

import secrets
from typing import Any

from ...framework_detection.keys import SIG_DETECTION_CONFIDENCE_LEVEL, SIG_INVOCATION_ENABLED
from ...models.poc import PocStatus
from ...utils import normalize_version_map
from ..constants import MAX_WAKU_PROBE_ENDPOINTS
from ..interpreters import analyze_waku_results
from ..journal import PocJournal, get_current_journal
from ..probes.waku_probe import send_waku_probe
from ..resolvers.waku import resolve_waku_action_endpoints
from ..snapshots import DetectContext
from ..surface import surface_from_detect_context
from .base import BaseAssessor


class WakuAssessor(BaseAssessor):
    framework_name = "waku"

    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: DetectContext | None = None,
    ) -> dict[str, Any]:
        detect_context = self._resolve_detect_context(detect_context)
        normalized_versions = normalize_version_map(detected_versions)
        journal = get_current_journal() or PocJournal()
        signals = self._context_signals(detect_context)
        surface = surface_from_detect_context(detect_context)
        react_pick = normalized_versions.get("react_version")
        react_version = str(react_pick.value) if react_pick else None
        react_major_confidence = (detect_context.react_major_confidence if detect_context else None) or self.get_version_confidence(
            "react_version",
            normalized_versions,
            detect_context,
        )

        resolved = resolve_waku_action_endpoints(base_url, detect_context, crawl_when_missing=True)
        endpoints = list(resolved.endpoint_pairs or [])
        has_actions = bool(resolved.has_actions)
        error_info = resolved.error_info

        if resolved.discovery_method and resolved.discovery_method != "none":
            journal.add_event(
                "waku-discovery",
                "Resolved Waku action endpoints for probing",
                data={
                    "discovery_method": resolved.discovery_method,
                    "entrypoint_url": resolved.entrypoint_url,
                    "has_actions": has_actions,
                    "endpoints_discovered": len(endpoints),
                },
            )

        if (not has_actions or not endpoints) and error_info and error_info.get("error_message"):
            reason = str(error_info.get("error_message") or "")
            journal.add_event(
                "waku-discovery",
                "Waku endpoint probe returned an error",
                data={
                    "error_message": reason,
                    "error_type": str(error_info.get("error_type") or ""),
                    "has_actions": has_actions,
                    "endpoints_discovered": len(endpoints),
                },
            )
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="discovery_error")
            return self.build_inconclusive_result(
                reason,
                normalized_versions,
                journal=journal,
                confidence=signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "low",
                error_message=reason,
                error_type=str(error_info.get("error_type") or ""),
            )

        if not has_actions or not endpoints:
            expected_actions = surface.invocation_surface is True or signals.get(SIG_INVOCATION_ENABLED) is True
            if expected_actions:
                reason = "Waku Server Actions were expected, but no action endpoints were discovered (crawl/auth may be required)"
                journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="missing_endpoints_expected")
                return self.build_inconclusive_result(
                    reason,
                    normalized_versions,
                    journal=journal,
                    confidence="medium",
                    framework=self.framework_name,
                    surface_detected=False,
                    decode_surface_reached=False,
                )
            reason = "No Waku Server Actions endpoints found (crawl/auth may be required)"
            journal.add_decision(PocStatus.NOT_VULNERABLE, reason, rule="missing_endpoints")
            confidence = signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "medium"
            if confidence == "low":
                confidence = "medium"
            return self.build_missing_surface_result(
                reason,
                normalized_versions,
                surface_detected=False,
                journal=journal,
                confidence=confidence,
                framework=self.framework_name,
                decode_surface_reached=False,
            )

        # Limit probes to avoid excessive requests
        endpoints_to_probe = endpoints[:MAX_WAKU_PROBE_ENDPOINTS]
        journal.add_event(
            "waku-endpoints",
            "Prepared Waku action endpoints for probing",
            data={
                "endpoints_total": len(endpoints),
                "endpoints_to_probe": len(endpoints_to_probe),
                "sample_endpoints": [ep for ep, _name in endpoints_to_probe[:5]],
            },
        )
        probe_results = []
        control_results = []

        for endpoint_url, action_name in endpoints_to_probe:
            proto_result = send_waku_probe(
                endpoint_url,
                target_prop="__proto__",
                force_fail=True,
            )
            control_result = send_waku_probe(
                endpoint_url,
                target_prop=f"z{secrets.token_hex(4)}",
                force_fail=True,
            )
            for res in (proto_result, control_result):
                res.endpoint = endpoint_url
                if action_name:
                    res.meta["action_name"] = action_name

            probe_results.append(proto_result)
            control_results.append(control_result)

        analysis = analyze_waku_results(
            probe_results,
            endpoints=endpoints_to_probe,
            control_results=control_results,
            react_major=self.get_react_major(normalized_versions, detect_context),
            react_version=react_version,
            react_major_confidence=react_major_confidence,
            react_major_conflict=(detect_context.react_major_conflict if detect_context else None),
            react_major_conflict_confidence=(detect_context.react_major_conflict_confidence if detect_context else None),
            react_major_conflict_majors=(detect_context.react_major_conflict_majors if detect_context else None),
            journal=journal,
        )

        analysis["details"]["detected_versions"] = self._version_values_for_output(normalized_versions)
        return analysis
