# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Vulnerability detection engine."""

from ..framework_detection.engine import FrameworkDetectionEngine
from ..framework_detection.keys import SIG_FETCH_ERROR_MESSAGE
from ..http import create_default_http_client
from ..models import FrameworkDetectionResult, ScanRequest, VulnerabilityReport
from ..utils.context import get_scan_context, scan_context
from .registry import detector_registry, get_applicable_detectors
from .snapshots import DetectionSnapshot


class VulnerabilityDetectionEngine:
    """Run framework detection + all applicable CVE detectors."""

    def __init__(self, detection_engine: FrameworkDetectionEngine | None = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()

    def run(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None = None,
        scan_request: ScanRequest | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> list[VulnerabilityReport]:
        context = get_scan_context()
        if context.http_client is None:
            http_client = getattr(self.detection_engine, "http_client", None) or create_default_http_client()
            with scan_context(http_client=http_client, proxy_profile=proxy_profile, correlation_id=correlation_id):
                return self._run_ctx(
                    url,
                    detection_result=detection_result,
                    scan_request=scan_request,
                    proxy_profile=proxy_profile,
                    correlation_id=correlation_id,
                )
        return self._run_ctx(
            url,
            detection_result=detection_result,
            scan_request=scan_request,
            proxy_profile=proxy_profile,
            correlation_id=correlation_id,
        )

    def _run_ctx(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None,
        scan_request: ScanRequest | None,
        proxy_profile: str | None,
        correlation_id: str | None,
    ) -> list[VulnerabilityReport]:
        context = get_scan_context()
        detection = detection_result or self._detect(url, scan_request, proxy_profile=proxy_profile, correlation_id=correlation_id)
        snapshot = DetectionSnapshot.from_detection(detection)

        detect_context = snapshot.to_detect_context()
        shared_extra = dict(context.extra) if isinstance(context.extra, dict) else {}
        shared_extra.update({"detect_context": detect_context, "detection_snapshot": snapshot})

        if snapshot.signals.get(SIG_FETCH_ERROR_MESSAGE):
            detectors = detector_registry(detection_engine=self.detection_engine)
        else:
            detectors = get_applicable_detectors(snapshot.tags or [], detection_engine=self.detection_engine)
        results: list[VulnerabilityReport] = []
        with scan_context(extra=shared_extra):
            for detector in detectors:
                finding = detector.evaluate(
                    url,
                    detection_result=detection,
                    proxy_profile=proxy_profile,
                    correlation_id=correlation_id,
                )
                results.append(finding if isinstance(finding, VulnerabilityReport) else VulnerabilityReport.from_mapping(finding))
        return results

    def _detect(
        self,
        url: str,
        scan_request: ScanRequest | None = None,
        *,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> FrameworkDetectionResult:
        effective_request = scan_request or ScanRequest(url=url, proxy_profile=proxy_profile, correlation_id=correlation_id)
        if not effective_request.url:
            effective_request.url = url
        return self.detection_engine.detect(effective_request)


__all__ = ["VulnerabilityDetectionEngine"]
