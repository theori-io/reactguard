# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Vulnerability detection engine."""

from ..framework_detection.engine import FrameworkDetectionEngine
from ..framework_detection.keys import SIG_FETCH_ERROR_MESSAGE, SIG_FINAL_URL
from ..http import create_default_http_client
from ..models import FrameworkDetectionResult, ScanRequest, VulnerabilityReport
from ..models.poc import PocStatus
from ..utils.context import ensure_scan_extra, get_http_settings, get_scan_context, register_scan_target, scan_context
from .registry import detector_registry, get_applicable_detectors
from .snapshots import DetectionSnapshot


class VulnerabilityDetectionEngine:
    """Run framework detection + all applicable CVE detectors."""

    def __init__(self, detection_engine: FrameworkDetectionEngine | None = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()

    def run(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None = None,
        scan_request: ScanRequest | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> list[VulnerabilityReport]:
        context = get_scan_context()
        needs_http_client = context.http_client is None
        if isinstance(context.extra, dict) and isinstance(detection_result, FrameworkDetectionResult):
            final_url = detection_result.signals.get(SIG_FINAL_URL)
            if final_url:
                register_scan_target(str(final_url), extra=context.extra)
        extra, needs_extra = ensure_scan_extra(url, extra=context.extra if isinstance(context.extra, dict) else None)
        needs_settings = context.http_settings is None
        if needs_http_client or needs_settings or needs_extra:
            http_client = context.http_client or getattr(self.detection_engine, "http_client", None) or create_default_http_client()
            with scan_context(
                http_client=http_client,
                http_settings=get_http_settings(),
                extra=extra,
                proxy_profile=proxy_profile,
                correlation_id=correlation_id,
            ):
                return self._run_ctx(
                    url,
                    detection_result=detection_result,
                    scan_request=scan_request,
                    proxy_profile=proxy_profile,
                    correlation_id=correlation_id,
                )
        return self._run_ctx(
            url,
            detection_result=detection_result,
            scan_request=scan_request,
            proxy_profile=proxy_profile,
            correlation_id=correlation_id,
        )

    def _run_ctx(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None,
        scan_request: ScanRequest | None,
        proxy_profile: str | None,
        correlation_id: str | None,
    ) -> list[VulnerabilityReport]:
        context = get_scan_context()
        detection = detection_result or self._detect(url, scan_request, proxy_profile=proxy_profile, correlation_id=correlation_id)
        snapshot = DetectionSnapshot.from_detection(detection)
        final_url = snapshot.signals.get(SIG_FINAL_URL)
        if final_url:
            register_scan_target(str(final_url))

        detect_context = snapshot.to_detect_context()
        shared_extra = dict(context.extra) if isinstance(context.extra, dict) else {}
        shared_extra.update({"detect_context": detect_context, "detection_snapshot": snapshot})

        if snapshot.signals.get(SIG_FETCH_ERROR_MESSAGE):
            detectors = detector_registry(detection_engine=self.detection_engine)
        else:
            detectors = get_applicable_detectors(snapshot.tags or [], detection_engine=self.detection_engine)
        results: list[VulnerabilityReport] = []
        with scan_context(extra=shared_extra):
            for detector in detectors:
                finding = detector.evaluate(
                    url,
                    detection_result=detection,
                    proxy_profile=proxy_profile,
                    correlation_id=correlation_id,
                )
                results.append(self._normalize_finding(detector, finding))
        return results

    @staticmethod
    def _normalize_finding(detector, finding: object) -> VulnerabilityReport:
        if isinstance(finding, VulnerabilityReport):
            return finding
        if isinstance(finding, dict) and finding:
            return VulnerabilityReport.from_mapping(finding)

        detector_name = getattr(detector, "name", None) or "unknown"
        details = {
            "cve_id": detector_name.upper() if detector_name.startswith("cve-") else detector_name,
            "confidence": "low",
            "reason": "Detector returned empty result",
        }
        return VulnerabilityReport(
            status=PocStatus.INCONCLUSIVE,
            details=details,
            raw_data={"detector": detector_name},
        )

    def _detect(
        self,
        url: str,
        scan_request: ScanRequest | None = None,
        *,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> FrameworkDetectionResult:
        effective_request = scan_request or ScanRequest(url=url, proxy_profile=proxy_profile, correlation_id=correlation_id)
        if not effective_request.url:
            effective_request.url = url
        return self.detection_engine.detect(effective_request)


__all__ = ["VulnerabilityDetectionEngine"]
