# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Detection snapshot utilities shared by vulnerability assessors."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from ..framework_detection.keys import (
    SIG_INVOCATION_CONFIDENCE,
    SIG_INVOCATION_ENABLED,
    SIG_INVOCATION_ENDPOINTS,
)
from ..models import FrameworkDetectionResult
from ..utils.version import parse_semver


@dataclass
class DetectionSnapshot:
    """Normalized view of framework detection output for downstream assessors."""

    tags: list[str]
    signals: dict[str, Any]
    detected_versions: dict[str, Any]
    react_major: int | None
    react_major_confidence: str | None
    invocation_enabled: bool | None
    invocation_confidence: str | None
    invocation_endpoints: list[str]

    @classmethod
    def from_detection(cls, detection: FrameworkDetectionResult) -> DetectionSnapshot:
        signals = detection.signals or {}
        tags = list(detection.tags or [])

        detected_versions = {key.replace("detected_", ""): value for key, value in signals.items() if key.startswith("detected_")}

        react_major = cls._resolve_react_major(signals, detected_versions)
        react_major_confidence = cls._resolve_react_major_confidence(signals, detected_versions)
        invocation_enabled = signals.get(SIG_INVOCATION_ENABLED)
        invocation_confidence = signals.get(SIG_INVOCATION_CONFIDENCE)
        invocation_endpoints = list(signals.get(SIG_INVOCATION_ENDPOINTS) or [])

        return cls(
            tags=tags,
            signals=signals,
            detected_versions=detected_versions,
            react_major=react_major,
            react_major_confidence=react_major_confidence,
            invocation_enabled=invocation_enabled,
            invocation_confidence=invocation_confidence,
            invocation_endpoints=invocation_endpoints,
        )

    @staticmethod
    def _resolve_react_major(signals: dict[str, Any], versions: dict[str, Any]) -> int | None:
        if signals.get("detected_react_major") is not None:
            try:
                return int(signals["detected_react_major"])
            except (TypeError, ValueError):
                return None

        if versions.get("rsc_runtime_version"):
            parsed = parse_semver(str(versions["rsc_runtime_version"]))
            if parsed:
                return parsed.major

        if versions.get("react_version"):
            parsed = parse_semver(str(versions["react_version"]))
            if parsed:
                return parsed.major

        if versions.get("react_major") is not None:
            try:
                return int(versions["react_major"])
            except (TypeError, ValueError):
                return None

        return None

    @staticmethod
    def _resolve_react_major_confidence(signals: dict[str, Any], versions: dict[str, Any]) -> str | None:
        if signals.get("detected_react_major_confidence"):
            return signals.get("detected_react_major_confidence")

        if versions.get("rsc_runtime_version_confidence"):
            return versions.get("rsc_runtime_version_confidence")

        if versions.get("react_major_confidence"):
            return versions.get("react_major_confidence")

        if versions.get("react_version_confidence"):
            return versions.get("react_version_confidence")

        return None

    def to_detect_context(self) -> dict[str, Any]:
        """Detect-context mapping consumed by vulnerability evaluators (sans transport plumbing)."""
        return {
            "react_major": self.react_major,
            "react_major_confidence": self.react_major_confidence,
            "react_major_conflict": self.signals.get("react_major_conflict"),
            "react_major_conflict_confidence": self.signals.get("react_major_conflict_confidence"),
            "react_major_conflict_majors": self.signals.get("react_major_conflict_majors"),
            "invocation_enabled": self.invocation_enabled,
            "invocation_confidence": self.invocation_confidence,
            "signals": self.signals,
            "tags": self.tags,
            "invocation_endpoints": self.invocation_endpoints,
        }
