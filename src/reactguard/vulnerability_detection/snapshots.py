# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Detection snapshot utilities shared by vulnerability assessors."""

from __future__ import annotations

from collections.abc import Iterator, Mapping
from dataclasses import dataclass, field
from typing import Any

from ..framework_detection.keys import (
    SIG_DETECTED_VERSIONS,
    SIG_INVOCATION_CONFIDENCE,
    SIG_INVOCATION_ENABLED,
    SIG_INVOCATION_ENDPOINTS,
    SIG_REACT_MAJOR_CONFLICT,
    SIG_REACT_MAJOR_CONFLICT_CONFIDENCE,
    SIG_REACT_MAJOR_CONFLICT_MAJORS,
)
from ..models import FrameworkDetectionResult
from ..utils.version import (
    DetectedVersion,
    normalize_version_map,
    parse_semver,
    version_map_from_signals,
)

_DETECT_CONTEXT_KEYS = (
    "react_major",
    "react_major_confidence",
    "react_major_conflict",
    "react_major_conflict_confidence",
    "react_major_conflict_majors",
    "invocation_enabled",
    "invocation_confidence",
    "signals",
    "tags",
    "invocation_endpoints",
    "detected_versions",
)


@dataclass(frozen=True)
class DetectContext(Mapping[str, Any]):
    """Mapping-style detection context for assessors and resolvers."""

    react_major: int | None
    react_major_confidence: str | None
    react_major_conflict: bool | None
    react_major_conflict_confidence: str | None
    react_major_conflict_majors: list[int] | None
    invocation_enabled: bool | None
    invocation_confidence: str | None
    signals: dict[str, Any] = field(default_factory=dict)
    tags: list[str] = field(default_factory=list)
    invocation_endpoints: list[str] = field(default_factory=list)
    detected_versions: dict[str, DetectedVersion] = field(default_factory=dict)
    extra: dict[str, Any] = field(default_factory=dict)

    def _lookup(self, key: str) -> Any:
        if key == "react_major":
            return self.react_major
        if key == "react_major_confidence":
            return self.react_major_confidence
        if key == "react_major_conflict":
            return self.react_major_conflict
        if key == "react_major_conflict_confidence":
            return self.react_major_conflict_confidence
        if key == "react_major_conflict_majors":
            return self.react_major_conflict_majors
        if key == "invocation_enabled":
            return self.invocation_enabled
        if key == "invocation_confidence":
            return self.invocation_confidence
        if key == "signals":
            return self.signals
        if key == "tags":
            return self.tags
        if key == "invocation_endpoints":
            return self.invocation_endpoints
        if key == "detected_versions":
            return self.detected_versions
        if key in self.extra:
            return self.extra[key]
        raise KeyError(key)

    def get(self, key: str, default: Any = None) -> Any:
        try:
            return self._lookup(key)
        except KeyError:
            return default

    def __getitem__(self, key: str) -> Any:
        return self._lookup(key)

    def __iter__(self) -> Iterator[str]:
        yielded = set()
        for key in _DETECT_CONTEXT_KEYS:
            yielded.add(key)
            yield key
        for key in self.extra:
            if key not in yielded:
                yield key

    def __len__(self) -> int:
        base_count = len(_DETECT_CONTEXT_KEYS)
        extra_count = sum(1 for key in self.extra if key not in _DETECT_CONTEXT_KEYS)
        return base_count + extra_count

    def to_dict(self) -> dict[str, Any]:
        data = {
            "react_major": self.react_major,
            "react_major_confidence": self.react_major_confidence,
            "react_major_conflict": self.react_major_conflict,
            "react_major_conflict_confidence": self.react_major_conflict_confidence,
            "react_major_conflict_majors": self.react_major_conflict_majors,
            "invocation_enabled": self.invocation_enabled,
            "invocation_confidence": self.invocation_confidence,
            "signals": self.signals,
            "tags": self.tags,
            "invocation_endpoints": self.invocation_endpoints,
            "detected_versions": {key: pick.to_mapping() for key, pick in self.detected_versions.items()},
        }
        data.update(self.extra)
        return data



@dataclass
class DetectionSnapshot:
    """Normalized view of framework detection output for downstream assessors."""

    tags: list[str]
    signals: dict[str, Any]
    detected_versions: dict[str, DetectedVersion]
    react_major: int | None
    react_major_confidence: str | None
    invocation_enabled: bool | None
    invocation_confidence: str | None
    invocation_endpoints: list[str]

    @classmethod
    def from_detection(cls, detection: FrameworkDetectionResult) -> DetectionSnapshot:
        signals = detection.signals or {}
        tags = list(detection.tags or [])

        detected_versions = normalize_version_map(signals.get(SIG_DETECTED_VERSIONS))
        if not detected_versions:
            detected_versions = version_map_from_signals(signals, prefix="detected_")

        react_major = cls._resolve_react_major(signals, detected_versions)
        react_major_confidence = cls._resolve_react_major_confidence(signals, detected_versions)
        invocation_enabled = signals.get(SIG_INVOCATION_ENABLED)
        invocation_confidence = signals.get(SIG_INVOCATION_CONFIDENCE)
        invocation_endpoints = list(signals.get(SIG_INVOCATION_ENDPOINTS) or [])

        return cls(
            tags=tags,
            signals=signals,
            detected_versions=detected_versions,
            react_major=react_major,
            react_major_confidence=react_major_confidence,
            invocation_enabled=invocation_enabled,
            invocation_confidence=invocation_confidence,
            invocation_endpoints=invocation_endpoints,
        )

    @classmethod
    def from_detect_context(cls, detect_context: DetectContext) -> DetectionSnapshot:
        """Build a snapshot from an existing detect_context (used by assessors)."""
        signals = dict(detect_context.signals or {})
        tags = list(detect_context.tags or [])
        detected_versions = normalize_version_map(detect_context.detected_versions)
        invocation_endpoints = list(detect_context.invocation_endpoints or [])
        if not invocation_endpoints:
            endpoints_from_signal = signals.get(SIG_INVOCATION_ENDPOINTS)
            if isinstance(endpoints_from_signal, list):
                invocation_endpoints = [str(ep) for ep in endpoints_from_signal if ep]

        return cls(
            tags=tags,
            signals=signals,
            detected_versions=detected_versions,
            react_major=detect_context.react_major,
            react_major_confidence=detect_context.react_major_confidence,
            invocation_enabled=detect_context.invocation_enabled,
            invocation_confidence=detect_context.invocation_confidence,
            invocation_endpoints=invocation_endpoints,
        )

    @staticmethod
    def _resolve_react_major(signals: dict[str, Any], versions: dict[str, DetectedVersion]) -> int | None:
        pick = versions.get("react_major")
        if pick:
            try:
                return int(pick.value)
            except (TypeError, ValueError):
                return None

        rsc_pick = versions.get("rsc_runtime_version")
        if rsc_pick:
            parsed = parse_semver(str(rsc_pick.value))
            if parsed:
                return parsed.major

        react_pick = versions.get("react_version")
        if react_pick:
            parsed = parse_semver(str(react_pick.value))
            if parsed:
                return parsed.major

        return None

    @staticmethod
    def _resolve_react_major_confidence(signals: dict[str, Any], versions: dict[str, DetectedVersion]) -> str | None:
        pick = versions.get("react_major")
        if pick and pick.confidence:
            return pick.confidence

        rsc_pick = versions.get("rsc_runtime_version")
        if rsc_pick and rsc_pick.confidence:
            return rsc_pick.confidence

        react_pick = versions.get("react_version")
        if react_pick and react_pick.confidence:
            return react_pick.confidence

        return None

    def to_detect_context(self) -> DetectContext:
        """Detect-context mapping consumed by vulnerability evaluators (sans transport plumbing)."""
        return DetectContext(
            react_major=self.react_major,
            react_major_confidence=self.react_major_confidence,
            react_major_conflict=self.signals.get(SIG_REACT_MAJOR_CONFLICT),
            react_major_conflict_confidence=self.signals.get(SIG_REACT_MAJOR_CONFLICT_CONFIDENCE),
            react_major_conflict_majors=self.signals.get(SIG_REACT_MAJOR_CONFLICT_MAJORS),
            invocation_enabled=self.invocation_enabled,
            invocation_confidence=self.invocation_confidence,
            signals=self.signals,
            tags=self.tags,
            invocation_endpoints=self.invocation_endpoints,
            detected_versions=self.detected_versions,
        )
