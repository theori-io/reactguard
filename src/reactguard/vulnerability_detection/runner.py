"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Vulnerability detection runner and CVE-2025-55182 detector."""

from typing import Any

from ..errors import error_category_to_reason
from ..framework_detection.engine import FrameworkDetectionEngine
from ..models import FrameworkDetectionResult, ScanRequest
from ..models.poc import PocStatus
from ..utils.context import get_scan_context, scan_context
from .assessors import (
    ExpoAssessor,
    GenericRSCAssessor,
    NextJSAssessor,
    ReactRouterAssessor,
    WakuAssessor,
)
from .journal import PocJournal, journal_context
from .plugin import PocPlugin
from .snapshots import DetectionSnapshot


class CVE202555182VulnerabilityDetector(PocPlugin):
    name = "cve-2025-55182"
    applicable_tags = [
        "nextjs",
        "nextjs-app-router",
        "waku",
        "expo",
        "react-router-v7",
        "react-router-v6",
        "rsc",
    ]

    def __init__(self, detection_engine: FrameworkDetectionEngine | None = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.assessors = {
            "nextjs": NextJSAssessor(),
            "waku": WakuAssessor(),
            "expo": ExpoAssessor(),
            "react-router": ReactRouterAssessor(),
            "rsc": GenericRSCAssessor(),
        }

    def evaluate(
        self,
        url: str,
        *,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
        detection_result: FrameworkDetectionResult | None = None,
    ) -> dict[str, Any]:
        with scan_context(
            proxy_profile=proxy_profile,
            correlation_id=correlation_id,
            http_client=getattr(self.detection_engine, "http_client", None),
        ):
            context = get_scan_context()
            effective_proxy_profile = context.proxy_profile
            effective_correlation_id = context.correlation_id
            detection = detection_result or self.detection_engine.detect(
                ScanRequest(
                    url=url,
                    proxy_profile=effective_proxy_profile,
                    correlation_id=effective_correlation_id,
                )
            )
            snapshot = DetectionSnapshot.from_detection(detection)

            if self._has_fatal_fetch_error(snapshot):
                category = detection.signals.get("fetch_error_category")
                return {
                    "status": PocStatus.INCONCLUSIVE,
                    "details": {
                        "cve_id": "CVE-2025-55182",
                        "confidence": "none",
                        "reason": error_category_to_reason(category),
                        "framework": None,
                        "error_category": category,
                        "detection_confidence": detection.signals.get("detection_confidence"),
                        "detection_confidence_level": detection.signals.get("detection_confidence_level"),
                    },
                    "raw_data": {"detection": detection.signals},
                }

            framework = self._framework_from_tags(snapshot.tags)
            assessor = self._assessor_for_framework(framework)

            if not assessor:
                return {
                    "status": PocStatus.NOT_APPLICABLE,
                    "details": {
                        "cve_id": "CVE-2025-55182",
                        "confidence": "none",
                        "reason": "Framework not in scope for PoC",
                        "framework_detected": None,
                        "detection_confidence": detection.signals.get("detection_confidence"),
                        "detection_confidence_level": detection.signals.get("detection_confidence_level"),
                    },
                    "raw_data": {"detection": detection.signals},
                }

            detect_context = snapshot.to_detect_context(getattr(self.detection_engine, "http_client", None))
            merged_extra = dict(context.extra or {})
            merged_extra.update({"detect_context": detect_context, "detection_snapshot": snapshot})
            journal = PocJournal()
            with journal_context(journal):
                with scan_context(extra=merged_extra):
                    result = assessor.evaluate(
                        url,
                        snapshot.detected_versions,
                    )

            result["details"]["framework_detected"] = framework
            result["details"]["detection_confidence"] = snapshot.signals.get("detection_confidence")
            result["details"]["detection_confidence_level"] = snapshot.signals.get("detection_confidence_level")
            result["details"]["detection_tags"] = snapshot.tags
            return result

    def _framework_from_tags(self, tags) -> str | None:
        tag_set = set(tags or [])
        if "waku" in tag_set:
            return "waku"
        if "nextjs" in tag_set or "nextjs-app-router" in tag_set:
            return "nextjs"
        if "expo" in tag_set:
            return "expo"
        if "react-router-v7" in tag_set or "react-router-v6" in tag_set:
            return "react-router"
        if "rsc" in tag_set:
            return "rsc"
        return None

    @staticmethod
    def _has_fatal_fetch_error(snapshot: DetectionSnapshot) -> bool:
        return bool(snapshot.signals.get("fetch_error_category"))

    def _assessor_for_framework(self, framework: str | None):
        if framework is None:
            return None
        return self.assessors.get(framework)


class VulnerabilityDetectionRunner:
    """Utility to run framework detection + vulnerability detection in one step."""

    def __init__(self, detection_engine: FrameworkDetectionEngine | None = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.detector = CVE202555182VulnerabilityDetector(self.detection_engine)

    def run(
        self,
        url: str,
        *,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
        detection_result=None,
        scan_request: ScanRequest | None = None,
    ) -> dict[str, Any]:
        with scan_context(
            proxy_profile=proxy_profile,
            correlation_id=correlation_id,
            http_client=getattr(self.detection_engine, "http_client", None),
        ):
            detection = detection_result or self._detect(url, scan_request)

            result = self.detector.evaluate(
                url,
                detection_result=detection,
            )
            return result

    def _detect(
        self,
        url: str,
        scan_request: ScanRequest | None = None,
    ) -> FrameworkDetectionResult:
        effective_request = scan_request or ScanRequest(url=url)
        if not effective_request.url:
            effective_request.url = url
        context = get_scan_context()
        if effective_request.proxy_profile is None:
            effective_request.proxy_profile = context.proxy_profile
        if effective_request.correlation_id is None:
            effective_request.correlation_id = context.correlation_id
        return self.detection_engine.detect(effective_request)
