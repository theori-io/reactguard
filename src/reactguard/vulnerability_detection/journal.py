# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Lightweight journal helper for PoC evaluations."""

import json
from collections.abc import Iterator
from contextlib import contextmanager
from contextvars import ContextVar
from typing import Any

from ..http.headers import header_value


class PocJournal:
    """Structured journal for PoC runs with size-aware serialization."""

    def __init__(self, entry_limit_bytes: int = 8192, max_entries: int = 128):
        self.entry_limit_bytes = entry_limit_bytes
        self.max_entries = max_entries
        self.entries: list[dict[str, Any]] = []

    def add_event(
        self,
        step: str,
        summary: str,
        *,
        outcome: str | None = None,
        data: Any | None = None,
        status_code: int | None = None,
    ) -> None:
        entry: dict[str, Any] = {"step": step, "summary": summary}
        if outcome is not None:
            entry["outcome"] = outcome
        if status_code is not None:
            entry["status_code"] = status_code
        if data is not None:
            entry["data"] = self._normalize_data(data)
        self.entries.append(entry)

    def add_probe(
        self,
        label: str,
        *,
        action_id: str | None = None,
        endpoint: str | None = None,
        status_code: int | None = None,
        body_snippet: str = "",
        headers: dict[str, Any] | None = None,
        digest: str | None = None,
        payload_meta: dict[str, Any] | None = None,
        request_wire_format: str | None = None,
        error_message: str | None = None,
        error_type: str | None = None,
    ) -> None:
        target = action_id or endpoint or "unknown"
        summary = f"{label} probe for {target} returned {status_code}"
        probe_data: dict[str, Any] = {
            "body_snippet": (body_snippet or "")[:4096],
        }
        if action_id:
            probe_data["action_id"] = action_id
        if endpoint:
            probe_data["endpoint"] = endpoint
        content_type = header_value(headers or {}, "content-type")
        if content_type:
            probe_data["content_type"] = content_type
        if digest:
            probe_data["digest"] = digest
        if request_wire_format:
            probe_data["request_wire_format"] = request_wire_format
        if payload_meta:
            probe_data["payload_meta"] = payload_meta
        if error_message:
            probe_data["error_message"] = error_message
        if error_type:
            probe_data["error_type"] = error_type

        self.add_event(
            "probe",
            summary,
            status_code=status_code,
            data=probe_data,
        )

    def add_probe_result(self, label: str, result: dict[str, Any] | None, *, digest: str | None = None) -> None:
        """
        Convenience adapter for common probe result dicts.

        Expected keys (best-effort):
        - endpoint/url, action_id/action_name, status_code, headers, body/body_snippet
        - payload_meta, request_wire_format, error_message, error_type
        """
        if not isinstance(result, dict):
            self.add_probe(label, status_code=None, body_snippet="", headers={})
            return

        body = result.get("body") or result.get("body_snippet") or ""
        headers = result.get("headers")
        headers_dict = headers if isinstance(headers, dict) else {}

        action_id = result.get("action_id") or result.get("action_name")
        action_id_str = str(action_id) if action_id is not None and str(action_id) else None

        endpoint = result.get("endpoint") or result.get("url")
        endpoint_str = str(endpoint) if endpoint is not None and str(endpoint) else None

        payload_meta = result.get("payload_meta")
        payload_meta_dict = payload_meta if isinstance(payload_meta, dict) else None

        request_wire_format_raw = result.get("request_wire_format")
        request_wire_format = str(request_wire_format_raw) if request_wire_format_raw is not None and str(request_wire_format_raw) else None

        error_message_raw = result.get("error_message")
        error_message = str(error_message_raw) if error_message_raw is not None and str(error_message_raw) else None

        error_type_raw = result.get("error_type")
        error_type = str(error_type_raw) if error_type_raw is not None and str(error_type_raw) else None

        self.add_probe(
            label,
            action_id=action_id_str,
            endpoint=endpoint_str,
            status_code=result.get("status_code"),
            body_snippet=str(body or ""),
            headers=headers_dict,
            digest=digest,
            payload_meta=payload_meta_dict,
            request_wire_format=request_wire_format,
            error_message=error_message,
            error_type=error_type,
        )

    def add_decision(
        self,
        outcome: str,
        reason: str,
        *,
        rule: str | None = None,
        data: dict[str, Any] | None = None,
    ) -> None:
        payload: dict[str, Any] | None = None
        if rule is not None or data:
            payload = dict(data or {})
            if rule is not None:
                payload.setdefault("decision_rule", rule)
        self.add_event("decision", reason, outcome=outcome, data=payload)

    def to_list(self) -> list[dict[str, Any]]:
        total_entries = len(self.entries)
        if total_entries == 0:
            return []

        if total_entries <= self.max_entries:
            serialized: list[dict[str, Any]] = []
            for entry in self.entries:
                trimmed = self._trim_entry(entry)
                trimmed = self._enforce_entry_limit(trimmed)
                serialized.append(trimmed)
            return serialized

        if self.max_entries <= 0:
            return [
                {
                    "step": "journal-truncated",
                    "summary": "Journal truncated (max_entries <= 0)",
                    "dropped_entries": total_entries,
                }
            ]

        # Preserve both early context and the most recent evidence/decision trail.
        # Keep a small head (setup) and a larger tail (probes + decision).
        if self.max_entries == 1:
            kept = [self.entries[-1]]
            head_count = 0
            tail_count = 1
        else:
            head_count = max(1, min(32, self.max_entries // 3))
            head_count = min(head_count, self.max_entries - 1)
            tail_count = self.max_entries - head_count
            kept = list(self.entries[:head_count]) + list(self.entries[-tail_count:])

        serialized = []
        for entry in kept:
            trimmed = self._trim_entry(entry)
            trimmed = self._enforce_entry_limit(trimmed)
            serialized.append(trimmed)

        dropped = max(0, total_entries - len(kept))
        serialized.append(
            {
                "step": "journal-truncated",
                "summary": f"Journal truncated: kept first {head_count} and last {tail_count} entries (max={self.max_entries})",
                "dropped_entries": dropped,
                "total_entries": total_entries,
            }
        )
        return serialized

    def _normalize_data(self, data: Any) -> Any:
        if isinstance(data, str):
            return data[: self.entry_limit_bytes]
        if isinstance(data, dict):
            return {key: self._normalize_data(value) for key, value in data.items()}
        if isinstance(data, list):
            return [self._normalize_data(item) for item in data][: self.max_entries]
        try:
            serialized = json.dumps(data, ensure_ascii=True)
            return serialized[: self.entry_limit_bytes]
        except Exception:
            return str(data)[: self.entry_limit_bytes]

    def _trim_entry(self, entry: dict[str, Any]) -> dict[str, Any]:
        trimmed: dict[str, Any] = {}
        for key, value in entry.items():
            if key == "data" and isinstance(value, str):
                trimmed[key] = value[: self.entry_limit_bytes]
            else:
                trimmed[key] = value
        return trimmed

    def _enforce_entry_limit(self, entry: dict[str, Any]) -> dict[str, Any]:
        serialized = json.dumps(entry, ensure_ascii=True)
        if len(serialized) <= self.entry_limit_bytes:
            return entry

        trimmed = dict(entry)
        data = trimmed.get("data")

        if isinstance(data, str):
            base = dict(trimmed)
            base.pop("data", None)
            base_size = len(json.dumps(base, ensure_ascii=True))
            allowance = max(0, self.entry_limit_bytes - base_size - 10)
            trimmed["data"] = data[:allowance]
        else:
            trimmed.pop("data", None)

        if len(json.dumps(trimmed, ensure_ascii=True)) > self.entry_limit_bytes:
            return {"step": "journal-entry-truncated", "summary": "Entry exceeded size limit"}

        return trimmed


_current_journal: ContextVar[PocJournal | None] = ContextVar("reactguard_poc_journal", default=None)


def get_current_journal() -> PocJournal | None:
    """Return the ambient PoC journal when set."""
    return _current_journal.get()


@contextmanager
def journal_context(journal: PocJournal | None = None) -> Iterator[PocJournal]:
    """
    Context manager that sets an ambient PoC journal for nested helpers.

    When ``journal`` is None, reuses any outer ambient journal or creates a new one.
    """
    current = get_current_journal()
    effective = journal or current or PocJournal()
    token = _current_journal.set(effective)
    try:
        yield effective
    finally:
        _current_journal.reset(token)


__all__ = ["PocJournal", "get_current_journal", "journal_context"]
