# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Shared base for Dec 2025 React Server Components CVE detectors."""

from __future__ import annotations

from urllib.parse import urlsplit
from typing import Any

from ...framework_detection.engine import FrameworkDetectionEngine
from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_FETCH_ERROR_MESSAGE,
    SIG_REACT_MAJOR_CONFLICT,
    SIG_REACT_MAJOR_CONFLICT_CONFIDENCE,
    SIG_REACT_MAJOR_CONFLICT_MAJORS,
    TAG_EXPO,
    TAG_NEXTJS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_REACT_ROUTER_V6,
    TAG_REACT_ROUTER_V7,
    TAG_REACT_STREAMING,
    TAG_RSC,
    TAG_WAKU,
)
from ...http.url import build_endpoint_candidates
from ...models import FrameworkDetectionResult, ScanRequest, VulnerabilityReport
from ...models.poc import PocStatus
from ...utils.confidence import confidence_at_least, confidence_label, confidence_score
from ...utils.context import get_scan_context, scan_context
from ..assessors import ReactServerComponentsDec2025Assessor, RscDec2025Spec
from ..journal import PocJournal
from ..plugin import PocPlugin
from ..snapshots import DetectionSnapshot
from ..surface import build_missing_surface_report, compute_rsc_server_functions_surface
from ._rsc_common import (
    build_fetch_failure_report,
    rsc_surface_cache,
    run_assessor_with_context,
)

_DEC2025_MISSING_SURFACE_REASON = "No reachable Flight protocol payload deserialization surface detected"

RSC_DEC2025_APPLICABLE_TAGS = [
    TAG_NEXTJS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_WAKU,
    TAG_EXPO,
    TAG_REACT_ROUTER_V7,
    TAG_REACT_ROUTER_V6,
    TAG_RSC,
]


def _candidate_dec2025_endpoints(*, url: str, snapshot: DetectionSnapshot) -> list[str]:
    endpoints = list(snapshot.invocation_endpoints or [])
    if endpoints:
        return [str(e) for e in endpoints if e]
    tag_set = set(snapshot.tags or [])
    if TAG_WAKU in tag_set and url:
        return [str(e) for e in build_endpoint_candidates(url, "/RSC/_") if e]
    return [str(url)] if url else []


def _action_prefix(url: str) -> tuple[tuple[str, str], str] | None:
    """
    Return an origin+path prefix for Expo-style ACTION_ endpoints.

    Dec 2025 probing may rewrite the suffix after `/ACTION_...` to avoid invoking user code, so we
    treat any endpoint with the same origin+prefix as "covered".
    """
    marker = "/ACTION_"
    try:
        parts = urlsplit(str(url or ""))
    except Exception:
        return None
    if marker not in parts.path:
        return None
    prefix_path = parts.path.split(marker, 1)[0] + marker
    return (parts.scheme, parts.netloc), prefix_path


def _cached_endpoints_cover(*, cached: list[str], required: list[str]) -> bool:
    if not required:
        return False
    cached_set = {str(e) for e in cached if e}
    if not cached_set:
        return False

    for endpoint in required:
        if endpoint in cached_set:
            continue

        required_prefix = _action_prefix(endpoint)
        if required_prefix is None:
            return False
        required_origin, required_path_prefix = required_prefix

        covered = False
        for candidate in cached_set:
            cand_prefix = _action_prefix(candidate)
            if cand_prefix is None:
                continue
            cand_origin, cand_path_prefix = cand_prefix
            if cand_origin == required_origin and cand_path_prefix == required_path_prefix:
                covered = True
                break
        if not covered:
            return False
    return True


def _dec2025_missing_surface_evidence(evidence: dict[str, Any] | None) -> tuple[bool, bool]:
    if not isinstance(evidence, dict):
        return False, False
    reason = str(evidence.get("reason") or "")
    needs_action_id = evidence.get("needs_valid_action_id") is True
    if reason.startswith("No candidate Flight protocol endpoints discovered"):
        return True, needs_action_id
    if "No reachable Flight protocol payload deserialization surface found" in reason:
        return True, needs_action_id
    if needs_action_id:
        return True, True
    return False, False


def _missing_surface_confidence(surface_confidence: str | None, detection_confidence: str | None) -> str:
    detection_level = str(detection_confidence or "none")
    if confidence_at_least(detection_level, "medium"):
        return "medium"
    surface_level = str(surface_confidence or "none")
    if confidence_at_least(surface_level, "medium"):
        return "medium"
    return "low"


class RscDec2025CveDetector(PocPlugin):
    """Shared detector runner for Dec 2025 React Server Components CVEs."""

    applicable_tags = RSC_DEC2025_APPLICABLE_TAGS

    def __init__(
        self,
        spec: RscDec2025Spec,
        detection_engine: FrameworkDetectionEngine | None = None,
    ):
        self.spec = spec
        self.name = spec.cve_id.lower()
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.assessor = ReactServerComponentsDec2025Assessor(spec)

    def evaluate(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> VulnerabilityReport:
        context = get_scan_context()
        needs_http_client = context.http_client is None
        needs_extra = not isinstance(context.extra, dict)

        if needs_http_client or needs_extra:
            overrides = {}
            if needs_http_client:
                overrides.update(
                    {
                        "http_client": getattr(self.detection_engine, "http_client", None),
                        "proxy_profile": proxy_profile,
                        "correlation_id": correlation_id,
                    }
                )
            if needs_extra:
                # Dec 2025 assessors intentionally cache probing work in ScanContext.extra so multiple CVE
                # evaluations against the same detection result can reuse the patch fingerprinting probes.
                # When a caller provides a detection_result, attach a per-result cache dictionary to avoid
                # global cache leakage and reduce live-test flakiness under load.
                #
                # Note: do not store this cache in `detection_result.signals` (user-facing, often serialized).
                # Some caches store non-JSON objects (dataclasses), which would break report serialization.
                if isinstance(detection_result, FrameworkDetectionResult):
                    scan_extra = getattr(detection_result, "_reactguard_scan_extra", None)
                    if not isinstance(scan_extra, dict):
                        scan_extra = {}
                        setattr(detection_result, "_reactguard_scan_extra", scan_extra)
                    overrides["extra"] = scan_extra
                else:
                    overrides["extra"] = {}

            with scan_context(**overrides):
                return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)

        return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)

    def _evaluate_ctx(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None,
        proxy_profile: str | None,
        correlation_id: str | None,
    ) -> VulnerabilityReport:
        cve_id = self.spec.cve_id
        context = get_scan_context()

        detection = detection_result or self.detection_engine.detect(ScanRequest(url=url, proxy_profile=proxy_profile, correlation_id=correlation_id))
        snapshot = DetectionSnapshot.from_detection(detection)
        surface = compute_rsc_server_functions_surface(snapshot)
        has_streaming_hint = TAG_REACT_STREAMING in set(snapshot.tags or [])

        if snapshot.signals.get(SIG_FETCH_ERROR_MESSAGE):
            return build_fetch_failure_report(
                cve_id=cve_id,
                detection=detection,
            )

        # Dec 2025 CVEs apply to React 19.x react-server-dom-* runtimes (RSC Flight protocol).
        #
        # Be conservative with NOT_APPLICABLE gating based on versions alone: client bundle strings can be noisy
        # (vendored React, third-party bundles, mixed deployments). Prefer behavioral confirmation from Flight
        # payloads when possible, and only short-circuit on *high-confidence* non-19 detection.
        react_major = snapshot.react_major
        react_major_confidence = snapshot.react_major_confidence
        react_major_conflict = snapshot.signals.get(SIG_REACT_MAJOR_CONFLICT) is True
        conflict_confidence = str(snapshot.signals.get(SIG_REACT_MAJOR_CONFLICT_CONFIDENCE) or "none")
        conflict_majors_raw = snapshot.signals.get(SIG_REACT_MAJOR_CONFLICT_MAJORS)
        conflict_majors: set[int] = set()
        if isinstance(conflict_majors_raw, list):
            for item in conflict_majors_raw:
                try:
                    conflict_majors.add(int(item))
                except (TypeError, ValueError):
                    continue
        strong_react19_conflict = react_major_conflict and (19 in conflict_majors) and confidence_at_least(conflict_confidence, "medium")

        if react_major is not None and react_major != 19 and confidence_at_least(react_major_confidence, "high") and not strong_react19_conflict:
            confidence = confidence_label(confidence_score(react_major_confidence) or confidence_score("medium"))
            reason = f"React {react_major}.x detected; {cve_id} applies to React 19.x only"
            journal = PocJournal()
            journal.add_event(
                "react-major-gate",
                "Short-circuited Dec 2025 CVE detector based on React major version",
                data={
                    "react_major": react_major,
                    "react_major_confidence": react_major_confidence,
                    "react_major_conflict": react_major_conflict,
                    "react_major_conflict_confidence": conflict_confidence,
                    "react_major_conflict_majors": sorted(conflict_majors),
                    "cve_id": cve_id,
                },
            )
            journal.add_decision(PocStatus.NOT_APPLICABLE, reason, rule="react_major_gate")
            details = {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "not_affected": True,
                "react_major": react_major,
                "react_major_confidence": react_major_confidence,
                "detected_versions": snapshot.detected_versions,
                "detection_confidence": snapshot.signals.get(SIG_DETECTION_CONFIDENCE),
                "detection_confidence_level": snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
                "detection_tags": snapshot.tags,
                "attack_surface": surface.to_dict(),
            }
            return VulnerabilityReport(
                status=PocStatus.NOT_APPLICABLE,
                details=details,
                raw_data={"detection": detection.signals, "journal": journal.to_list()},
            )

        cache = rsc_surface_cache()
        if isinstance(cache, dict) and cache:
            cache_confidence = str(cache.get("confidence") or "none")
            cached_endpoints_raw = cache.get("endpoints") or []
            cached_endpoints = [str(e) for e in cached_endpoints_raw if e] if isinstance(cached_endpoints_raw, list) else []
            required_endpoints = _candidate_dec2025_endpoints(url=url, snapshot=snapshot)
            if confidence_at_least(cache_confidence, "medium") and _cached_endpoints_cover(cached=cached_endpoints, required=required_endpoints):
                return build_missing_surface_report(
                    cve_id=cve_id,
                    snapshot=snapshot,
                    surface=surface,
                    status=PocStatus.NOT_VULNERABLE,
                    reason="No reachable Flight protocol payload deserialization surface detected",
                    confidence_override=cache_confidence,
                    decision_rule="cached_missing_surface",
                )

        if surface.server_functions_surface is False and not has_streaming_hint:
            return build_missing_surface_report(
                cve_id=cve_id,
                snapshot=snapshot,
                surface=surface,
                status=PocStatus.NOT_VULNERABLE,
                reason="No reachable Flight protocol payload deserialization surface detected",
                decision_rule="surface_gate",
            )

        result = run_assessor_with_context(
            self.assessor,
            url=url,
            snapshot=snapshot,
        )

        result_details = result.get("details") if isinstance(result, dict) else None
        result_raw = result.get("raw_data") if isinstance(result, dict) else None
        evidence = result_raw.get("evidence") if isinstance(result_raw, dict) else None
        missing_surface, _needs_action_id = _dec2025_missing_surface_evidence(evidence)
        if missing_surface:
            confidence_override = _missing_surface_confidence(
                surface.confidence,
                snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
            )
            return build_missing_surface_report(
                cve_id=cve_id,
                snapshot=snapshot,
                surface=surface,
                status=PocStatus.NOT_VULNERABLE,
                reason=_DEC2025_MISSING_SURFACE_REASON,
                confidence_override=confidence_override,
                decision_rule="fingerprint_missing_surface",
                raw_data=result_raw if isinstance(result_raw, dict) else None,
            )

        if isinstance(result_details, dict):
            result_details["detection_confidence"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE)
            result_details["detection_confidence_level"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)
            result_details["detection_tags"] = snapshot.tags
            result_details["attack_surface"] = surface.to_dict()
        return VulnerabilityReport.from_mapping(result)


__all__ = ["RSC_DEC2025_APPLICABLE_TAGS", "RscDec2025CveDetector"]
