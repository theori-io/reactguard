# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Shared base for Dec 2025 React Server Components CVE detectors."""

from __future__ import annotations

from ...framework_detection.engine import FrameworkDetectionEngine
from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_FETCH_ERROR_MESSAGE,
    TAG_EXPO,
    TAG_NEXTJS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_REACT_ROUTER_V6,
    TAG_REACT_ROUTER_V7,
    TAG_REACT_STREAMING,
    TAG_RSC,
    TAG_WAKU,
)
from ...models import FrameworkDetectionResult, ScanRequest, VulnerabilityReport
from ...models.poc import PocStatus
from ...utils.confidence import confidence_at_least, confidence_label, confidence_score
from ...utils.context import get_scan_context, scan_context
from ..assessors import ReactServerComponentsDec2025Assessor, RscDec2025Spec
from ..journal import PocJournal
from ..plugin import PocPlugin
from ..snapshots import DetectionSnapshot
from ..surface import build_missing_surface_report, compute_rsc_server_functions_surface
from ._rsc_common import (
    RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY,
    build_fetch_failure_report,
    run_assessor_with_context,
)

RSC_DEC2025_APPLICABLE_TAGS = [
    TAG_NEXTJS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_WAKU,
    TAG_EXPO,
    TAG_REACT_ROUTER_V7,
    TAG_REACT_ROUTER_V6,
    TAG_RSC,
]


class RscDec2025CveDetector(PocPlugin):
    """Shared detector runner for Dec 2025 React Server Components CVEs."""

    applicable_tags = RSC_DEC2025_APPLICABLE_TAGS

    def __init__(
        self,
        spec: RscDec2025Spec,
        detection_engine: FrameworkDetectionEngine | None = None,
    ):
        self.spec = spec
        self.name = spec.cve_id.lower()
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.assessor = ReactServerComponentsDec2025Assessor(spec)

    def evaluate(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> VulnerabilityReport:
        context = get_scan_context()
        if context.http_client is None:
            with scan_context(
                http_client=getattr(self.detection_engine, "http_client", None),
                proxy_profile=proxy_profile,
                correlation_id=correlation_id,
            ):
                return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)
        return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)

    def _evaluate_ctx(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None,
        proxy_profile: str | None,
        correlation_id: str | None,
    ) -> VulnerabilityReport:
        cve_id = self.spec.cve_id
        context = get_scan_context()

        detection = detection_result or self.detection_engine.detect(ScanRequest(url=url, proxy_profile=proxy_profile, correlation_id=correlation_id))
        snapshot = DetectionSnapshot.from_detection(detection)
        surface = compute_rsc_server_functions_surface(snapshot)
        has_streaming_hint = TAG_REACT_STREAMING in set(snapshot.tags or [])

        if snapshot.signals.get(SIG_FETCH_ERROR_MESSAGE):
            return build_fetch_failure_report(
                cve_id=cve_id,
                detection=detection,
            )

        # Dec 2025 CVEs apply to React 19.x react-server-dom-* runtimes (RSC Flight protocol).
        #
        # Be conservative with NOT_APPLICABLE gating based on versions alone: client bundle strings can be noisy
        # (vendored React, third-party bundles, mixed deployments). Prefer behavioral confirmation from Flight
        # payloads when possible, and only short-circuit on *high-confidence* non-19 detection.
        react_major = snapshot.react_major
        react_major_confidence = snapshot.react_major_confidence
        react_major_conflict = snapshot.signals.get("react_major_conflict") is True
        conflict_confidence = str(snapshot.signals.get("react_major_conflict_confidence") or "none")
        conflict_majors_raw = snapshot.signals.get("react_major_conflict_majors")
        conflict_majors: set[int] = set()
        if isinstance(conflict_majors_raw, list):
            for item in conflict_majors_raw:
                try:
                    conflict_majors.add(int(item))
                except (TypeError, ValueError):
                    continue
        strong_react19_conflict = react_major_conflict and (19 in conflict_majors) and confidence_at_least(conflict_confidence, "medium")

        if react_major is not None and react_major != 19 and confidence_at_least(react_major_confidence, "high") and not strong_react19_conflict:
            confidence = confidence_label(confidence_score(react_major_confidence) or confidence_score("medium"))
            reason = f"React {react_major}.x detected; {cve_id} applies to React 19.x only"
            journal = PocJournal()
            journal.add_event(
                "react-major-gate",
                "Short-circuited Dec 2025 CVE detector based on React major version",
                data={
                    "react_major": react_major,
                    "react_major_confidence": react_major_confidence,
                    "react_major_conflict": react_major_conflict,
                    "react_major_conflict_confidence": conflict_confidence,
                    "react_major_conflict_majors": sorted(conflict_majors),
                    "cve_id": cve_id,
                },
            )
            journal.add_decision(PocStatus.NOT_APPLICABLE, reason, rule="react_major_gate")
            details = {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "not_affected": True,
                "react_major": react_major,
                "react_major_confidence": react_major_confidence,
                "detected_versions": snapshot.detected_versions,
                "detection_confidence": snapshot.signals.get(SIG_DETECTION_CONFIDENCE),
                "detection_confidence_level": snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
                "detection_tags": snapshot.tags,
                "attack_surface": surface.to_dict(),
            }
            return VulnerabilityReport(
                status=PocStatus.NOT_APPLICABLE,
                details=details,
                raw_data={"detection": detection.signals, "journal": journal.to_list()},
            )

        if isinstance(context.extra, dict) and context.extra.get(RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY) is True:
            return build_missing_surface_report(
                cve_id=cve_id,
                snapshot=snapshot,
                surface=surface,
                status=PocStatus.NOT_VULNERABLE,
                reason="No reachable Flight protocol payload deserialization surface detected",
                decision_rule="cached_missing_surface",
            )

        if surface.server_functions_surface is False and not has_streaming_hint:
            return build_missing_surface_report(
                cve_id=cve_id,
                snapshot=snapshot,
                surface=surface,
                status=PocStatus.NOT_VULNERABLE,
                reason="No reachable Flight protocol payload deserialization surface detected",
                decision_rule="surface_gate",
            )

        result = run_assessor_with_context(
            self.assessor,
            url=url,
            snapshot=snapshot,
        )

        result["details"]["detection_confidence"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE)
        result["details"]["detection_confidence_level"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)
        result["details"]["detection_tags"] = snapshot.tags
        result["details"]["attack_surface"] = surface.to_dict()
        return VulnerabilityReport.from_mapping(result)


__all__ = ["RSC_DEC2025_APPLICABLE_TAGS", "RscDec2025CveDetector"]
