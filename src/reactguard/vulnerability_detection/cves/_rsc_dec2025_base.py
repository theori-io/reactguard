from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Shared base for Dec 2025 React Server Components CVE detectors."""

from ...errors import error_category_to_reason
from ...framework_detection.engine import FrameworkDetectionEngine
from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_FETCH_ERROR_CATEGORY,
)
from ...models import FrameworkDetectionResult, ScanRequest, VulnerabilityReport
from ...models.poc import PocStatus
from ...utils.context import get_scan_context, scan_context
from ..assessors import ReactServerComponentsDec2025Assessor, RscDec2025Spec
from ..journal import PocJournal, journal_context
from ..plugin import PocPlugin
from ..snapshots import DetectionSnapshot
from ..surface import (
    ENTRYPOINT_EXPECTED_NOT_FOUND_REASON_CODE,
    ENTRYPOINT_NOT_FOUND_REASON_CODE,
    build_missing_surface_report,
    compute_rsc_server_functions_surface,
)

RSC_DEC2025_APPLICABLE_TAGS = [
    "nextjs",
    "nextjs-app-router",
    "waku",
    "expo",
    "expo-rsc",
    "react-router-v7",
    "react-router-v6",
    "rsc",
]

RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY = "rsc_server_functions_surface_missing"


class RscDec2025CveDetector(PocPlugin):
    """Shared detector runner for Dec 2025 React Server Components CVEs."""

    applicable_tags = RSC_DEC2025_APPLICABLE_TAGS

    def __init__(
        self,
        spec: RscDec2025Spec,
        detection_engine: FrameworkDetectionEngine | None = None,
    ):
        self.spec = spec
        self.name = spec.cve_id.lower()
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.assessor = ReactServerComponentsDec2025Assessor(spec)

    def evaluate(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> VulnerabilityReport:
        cve_id = self.spec.cve_id
        with scan_context(
            http_client=getattr(self.detection_engine, "http_client", None),
            proxy_profile=proxy_profile,
            correlation_id=correlation_id,
        ):
            context = get_scan_context()
            detection = detection_result or self.detection_engine.detect(ScanRequest(url=url, proxy_profile=proxy_profile, correlation_id=correlation_id))
            snapshot = DetectionSnapshot.from_detection(detection)

            if snapshot.signals.get(SIG_FETCH_ERROR_CATEGORY):
                category = detection.signals.get(SIG_FETCH_ERROR_CATEGORY)
                return VulnerabilityReport(
                    status=PocStatus.INCONCLUSIVE,
                    details={
                        "cve_id": cve_id,
                        "confidence": "none",
                        "reason": error_category_to_reason(category),
                        "error_category": category,
                        "detection_confidence": detection.signals.get(SIG_DETECTION_CONFIDENCE),
                        "detection_confidence_level": detection.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
                    },
                    raw_data={"detection": detection.signals},
                )

            if isinstance(context.extra, dict) and context.extra.get(RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY) is True:
                surface = compute_rsc_server_functions_surface(snapshot)
                return build_missing_surface_report(
                    cve_id=cve_id,
                    snapshot=snapshot,
                    surface=surface,
                    status=PocStatus.NOT_VULNERABLE,
                    reason="No RSC / Server Functions surface detected",
                )

            surface = compute_rsc_server_functions_surface(snapshot)
            if surface.entrypoint_required and surface.entrypoint_available is False:
                if surface.entrypoint_expected is True:
                    return build_missing_surface_report(
                        cve_id=cve_id,
                        snapshot=snapshot,
                        surface=surface,
                        status=PocStatus.INCONCLUSIVE,
                        reason="Server Functions entrypoint expected but not found",
                        reason_code=ENTRYPOINT_EXPECTED_NOT_FOUND_REASON_CODE,
                    )
                return build_missing_surface_report(
                    cve_id=cve_id,
                    snapshot=snapshot,
                    surface=surface,
                    status=PocStatus.LIKELY_NOT_VULNERABLE,
                    reason="No Server Functions entrypoint discovered",
                    reason_code=ENTRYPOINT_NOT_FOUND_REASON_CODE,
                )

            if surface.server_functions_surface is False:
                return build_missing_surface_report(
                    cve_id=cve_id,
                    snapshot=snapshot,
                    surface=surface,
                    status=PocStatus.NOT_VULNERABLE,
                    reason="No RSC / Server Functions surface detected",
                )

            detect_context = snapshot.to_detect_context(getattr(self.detection_engine, "http_client", None))
            merged_extra = dict(context.extra) if isinstance(context.extra, dict) else {}
            merged_extra.update({"detect_context": detect_context, "detection_snapshot": snapshot})

            journal = PocJournal()
            with journal_context(journal):
                with scan_context(extra=merged_extra):
                    result = self.assessor.evaluate(
                        url,
                        snapshot.detected_versions,
                    )

            result["details"]["detection_confidence"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE)
            result["details"]["detection_confidence_level"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)
            result["details"]["detection_tags"] = snapshot.tags
            result["details"]["attack_surface"] = surface.to_dict()
            return VulnerabilityReport.from_mapping(result)


__all__ = ["RSC_DEC2025_APPLICABLE_TAGS", "RscDec2025CveDetector"]
