# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""CVE-2025-55182 detector (React2Shell)."""

from __future__ import annotations

from ...framework_detection.engine import FrameworkDetectionEngine
from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_FETCH_ERROR_MESSAGE,
    TAG_EXPO,
    TAG_NEXTJS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_REACT_ROUTER_V6,
    TAG_REACT_ROUTER_V7,
    TAG_REACT_STREAMING,
    TAG_RSC,
    TAG_WAKU,
)
from ...models import FrameworkDetectionResult, ScanRequest, VulnerabilityReport
from ...models.poc import PocStatus
from ...utils.context import get_scan_context, scan_context
from ..assessors import (
    ExpoAssessor,
    GenericRSCAssessor,
    NextJSAssessor,
    ReactRouterAssessor,
    WakuAssessor,
)
from ..journal import PocJournal
from ..plugin import PocPlugin
from ..snapshots import DetectionSnapshot
from ..surface import (
    MISSING_SURFACE_REASON_CODE,
    build_missing_surface_report,
    compute_rsc_server_functions_surface,
)
from ._rsc_common import (
    RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY,
    build_fetch_failure_report,
    run_assessor_with_context,
)


class CVE202555182VulnerabilityDetector(PocPlugin):
    name = "cve-2025-55182"
    applicable_tags = [
        TAG_NEXTJS,
        TAG_NEXTJS_APP_ROUTER,
        TAG_WAKU,
        TAG_EXPO,
        TAG_REACT_ROUTER_V7,
        TAG_REACT_ROUTER_V6,
        TAG_RSC,
    ]

    def __init__(self, detection_engine: FrameworkDetectionEngine | None = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.assessors = {
            "nextjs": NextJSAssessor(),
            "waku": WakuAssessor(),
            "expo": ExpoAssessor(),
            "react-router": ReactRouterAssessor(),
            "rsc": GenericRSCAssessor(),
        }

    def evaluate(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> VulnerabilityReport:
        context = get_scan_context()
        if context.http_client is None:
            with scan_context(
                http_client=getattr(self.detection_engine, "http_client", None),
                proxy_profile=proxy_profile,
                correlation_id=correlation_id,
            ):
                return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)
        return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)

    def _evaluate_ctx(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None,
        proxy_profile: str | None,
        correlation_id: str | None,
    ) -> VulnerabilityReport:
        context = get_scan_context()
        detection = detection_result or self.detection_engine.detect(
            ScanRequest(
                url=url,
                proxy_profile=proxy_profile,
                correlation_id=correlation_id,
            )
        )
        snapshot = DetectionSnapshot.from_detection(detection)
        surface = compute_rsc_server_functions_surface(snapshot)
        has_streaming_hint = TAG_REACT_STREAMING in set(snapshot.tags or [])

        if self._has_fatal_fetch_error(snapshot):
            return build_fetch_failure_report(
                cve_id="CVE-2025-55182",
                detection=detection,
            )

        framework = self._framework_from_tags(snapshot.tags)
        assessor = self._assessor_for_framework(framework)

        if not assessor:
            detection_level = str(detection.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL) or "").strip().lower()
            if detection_level not in {"low", "medium", "high"}:
                detection_level = "low"
            reason = "Detected framework not in scope for this PoC"
            journal = PocJournal()
            journal.add_event(
                "detector-skip",
                "Skipping CVE-2025-55182 assessor for unsupported framework",
                data={
                    "framework_detected": framework,
                    "tags": snapshot.tags,
                    "detection_confidence_level": detection.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
                },
            )
            journal.add_decision(PocStatus.NOT_APPLICABLE, reason, rule="unsupported_framework")
            return VulnerabilityReport(
                status=PocStatus.NOT_APPLICABLE,
                details={
                    "cve_id": "CVE-2025-55182",
                    "confidence": detection_level,
                    "reason": reason,
                    "framework_detected": None,
                    "detection_confidence": detection.signals.get(SIG_DETECTION_CONFIDENCE),
                    "detection_confidence_level": detection.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
                },
                raw_data={"detection": detection.signals, "journal": journal.to_list()},
            )

        # When we have only weak "no surface" hints (e.g., generic React streaming markers),
        # allow the CVE-2025-55182 assessor to run at least once so it can confirm the absence
        # of a reachable Flight protocol payload deserialization surface. Downstream CVEs can reuse that decision.
        if surface.server_functions_surface is False and not has_streaming_hint:
            return build_missing_surface_report(
                cve_id="CVE-2025-55182",
                snapshot=snapshot,
                surface=surface,
                status=PocStatus.NOT_VULNERABLE,
                reason="No reachable Flight protocol payload deserialization surface detected",
                framework_detected=framework,
                decision_rule="surface_gate",
            )

        result = run_assessor_with_context(
            assessor,
            url=url,
            snapshot=snapshot,
        )

        details = result.get("details") if isinstance(result, dict) else None
        if isinstance(details, dict):
            status = result.get("status") if isinstance(result, dict) else None
            decision_rule = str(details.get("decision_rule") or "")
            reason_code = str(details.get("reason_code") or "")
            surface_detected = details.get("surface_detected")
            not_affected = bool(details.get("not_affected")) is True

            # Mapping contract:
            # - missing-surface => NOT_VULNERABLE (surface_detected=False, reason_code=missing_surface)
            # - not-affected   => NOT_APPLICABLE (not_affected=True)
            missing_surface = (
                reason_code == MISSING_SURFACE_REASON_CODE
                or (
                    surface_detected is False
                    and not not_affected
                    and status in {PocStatus.NOT_VULNERABLE, PocStatus.LIKELY_NOT_VULNERABLE}
                )
            )

            # Multi-action interpreters can emit NOT_APPLICABLE when probes find no RSC/Flight protocol payload deserialization surface.
            # Treat these as a missing-surface decision so downstream CVEs can reuse it.
            multi_action_no_surface_rules = {
                "_default_rule",
                "_rule_html_only_responses",
                "_rule_validation_non_rsc",
            }
            missing_surface = missing_surface or (
                surface_detected is False and decision_rule in multi_action_no_surface_rules
            )

            # When CVE-2025-55182 indicates an absent/unreachable Flight protocol payload deserialization surface, cache a missing-surface
            # signal for downstream CVEs. We intentionally do *not* rewrite the CVE-2025-55182 report
            # here unless it is an explicit missing-surface verdict above.
            decode_surface_reached = details.get("decode_surface_reached")
            invocation_expected = details.get("invocation_expected")

            cache_missing_surface = missing_surface or (
                (not not_affected)
                and (
                    # Explicit missing-surface signals from assessors.
                    surface_detected is False
                    # Strong "no actions" signal (but avoid caching when we actually reached Flight protocol payload deserialization).
                    or (invocation_expected is False and decode_surface_reached is not True)
                    # HTML-only responses imply the Flight protocol payload deserialization surface is unreachable (blocked/disabled), even if
                    # framework heuristics suggested an RSC surface.
                    or (decision_rule == "_rule_html_only_responses" and decode_surface_reached is not True)
                )
            )

            if cache_missing_surface and isinstance(context.extra, dict):
                context.extra[RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY] = True

            if missing_surface:
                result_raw = result.get("raw_data") if isinstance(result, dict) else None
                result_raw = dict(result_raw) if isinstance(result_raw, dict) else None
                return build_missing_surface_report(
                    cve_id="CVE-2025-55182",
                    snapshot=snapshot,
                    surface=surface,
                    status=PocStatus.NOT_VULNERABLE,
                    reason=str(details.get("reason") or "No reachable Flight protocol payload deserialization surface detected"),
                    framework_detected=framework,
                    decision_rule=decision_rule or "assessor_missing_surface",
                    raw_data=result_raw,
                )

        result["details"]["framework_detected"] = framework
        result["details"]["detection_confidence"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE)
        result["details"]["detection_confidence_level"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)
        result["details"]["detection_tags"] = snapshot.tags
        result["details"]["attack_surface"] = surface.to_dict()
        return VulnerabilityReport.from_mapping(result)

    def _framework_from_tags(self, tags) -> str | None:
        tag_set = set(tags or [])
        if TAG_WAKU in tag_set:
            return "waku"
        if TAG_NEXTJS in tag_set or TAG_NEXTJS_APP_ROUTER in tag_set:
            return "nextjs"
        if TAG_EXPO in tag_set:
            return "expo"
        if TAG_REACT_ROUTER_V7 in tag_set or TAG_REACT_ROUTER_V6 in tag_set:
            return "react-router"
        if TAG_RSC in tag_set:
            return "rsc"
        return None

    @staticmethod
    def _has_fatal_fetch_error(snapshot: DetectionSnapshot) -> bool:
        return bool(snapshot.signals.get(SIG_FETCH_ERROR_MESSAGE))

    def _assessor_for_framework(self, framework: str | None):
        if framework is None:
            return None
        return self.assessors.get(framework)


__all__ = ["CVE202555182VulnerabilityDetector"]
