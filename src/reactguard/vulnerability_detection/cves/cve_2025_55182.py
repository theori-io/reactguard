from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""CVE-2025-55182 detector (React2Shell)."""

from ...framework_detection.engine import FrameworkDetectionEngine
from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_FETCH_ERROR_MESSAGE,
    TAG_EXPO,
    TAG_NEXTJS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_REACT_ROUTER_V6,
    TAG_REACT_ROUTER_V7,
    TAG_REACT_STREAMING,
    TAG_RSC,
    TAG_WAKU,
)
from ...models import FrameworkDetectionResult, ScanRequest, VulnerabilityReport
from ...models.poc import PocStatus
from ...utils.context import get_scan_context, scan_context
from ..assessors import (
    ExpoAssessor,
    GenericRSCAssessor,
    NextJSAssessor,
    ReactRouterAssessor,
    WakuAssessor,
)
from ..plugin import PocPlugin
from ..snapshots import DetectionSnapshot
from ..surface import (
    build_missing_surface_report,
    compute_rsc_server_functions_surface,
)
from ._rsc_common import (
    RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY,
    build_fetch_failure_report,
    run_assessor_with_context,
)


class CVE202555182VulnerabilityDetector(PocPlugin):
    name = "cve-2025-55182"
    applicable_tags = [
        TAG_NEXTJS,
        TAG_NEXTJS_APP_ROUTER,
        TAG_WAKU,
        TAG_EXPO,
        TAG_REACT_ROUTER_V7,
        TAG_REACT_ROUTER_V6,
        TAG_RSC,
    ]

    def __init__(self, detection_engine: FrameworkDetectionEngine | None = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.assessors = {
            "nextjs": NextJSAssessor(),
            "waku": WakuAssessor(),
            "expo": ExpoAssessor(),
            "react-router": ReactRouterAssessor(),
            "rsc": GenericRSCAssessor(),
        }

    def evaluate(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None = None,
        proxy_profile: str | None = None,
        correlation_id: str | None = None,
    ) -> VulnerabilityReport:
        context = get_scan_context()
        if context.http_client is None:
            with scan_context(
                http_client=getattr(self.detection_engine, "http_client", None),
                proxy_profile=proxy_profile,
                correlation_id=correlation_id,
            ):
                return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)
        return self._evaluate_ctx(url, detection_result=detection_result, proxy_profile=proxy_profile, correlation_id=correlation_id)

    def _evaluate_ctx(
        self,
        url: str,
        *,
        detection_result: FrameworkDetectionResult | None,
        proxy_profile: str | None,
        correlation_id: str | None,
    ) -> VulnerabilityReport:
        context = get_scan_context()
        detection = detection_result or self.detection_engine.detect(
            ScanRequest(
                url=url,
                proxy_profile=proxy_profile,
                correlation_id=correlation_id,
            )
        )
        snapshot = DetectionSnapshot.from_detection(detection)
        surface = compute_rsc_server_functions_surface(snapshot)
        has_streaming_hint = TAG_REACT_STREAMING in set(snapshot.tags or [])

        if self._has_fatal_fetch_error(snapshot):
            return build_fetch_failure_report(
                cve_id="CVE-2025-55182",
                detection=detection,
            )

        framework = self._framework_from_tags(snapshot.tags)
        assessor = self._assessor_for_framework(framework)

        if not assessor:
            return VulnerabilityReport(
                status=PocStatus.NOT_APPLICABLE,
                details={
                    "cve_id": "CVE-2025-55182",
                    "confidence": "none",
                    "reason": "Framework not in scope for PoC",
                    "framework_detected": None,
                    "detection_confidence": detection.signals.get(SIG_DETECTION_CONFIDENCE),
                    "detection_confidence_level": detection.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
                },
                raw_data={"detection": detection.signals},
            )

        # When we have only weak "no surface" hints (e.g., generic React streaming markers),
        # allow the CVE-2025-55182 assessor to run at least once so it can confirm the absence
        # of a reachable Server Functions decode surface. Downstream CVEs can reuse that decision.
        if surface.server_functions_surface is False and not has_streaming_hint:
            return build_missing_surface_report(
                cve_id="CVE-2025-55182",
                snapshot=snapshot,
                surface=surface,
                status=PocStatus.NOT_VULNERABLE,
                reason="No RSC / Server Functions surface detected",
                framework_detected=framework,
            )

        result = run_assessor_with_context(
            assessor,
            url=url,
            snapshot=snapshot,
        )

        details = result.get("details") if isinstance(result, dict) else None
        if isinstance(details, dict):
            missing_surface = bool(details.get("not_affected")) and details.get("surface_detected") is False
            if missing_surface:
                if isinstance(context.extra, dict):
                    context.extra[RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY] = True
                return build_missing_surface_report(
                    cve_id="CVE-2025-55182",
                    snapshot=snapshot,
                    surface=surface,
                    status=PocStatus.NOT_VULNERABLE,
                    reason="No RSC / Server Functions surface detected",
                    framework_detected=framework,
                )

        result["details"]["framework_detected"] = framework
        result["details"]["detection_confidence"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE)
        result["details"]["detection_confidence_level"] = snapshot.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)
        result["details"]["detection_tags"] = snapshot.tags
        result["details"]["attack_surface"] = surface.to_dict()
        return VulnerabilityReport.from_mapping(result)

    def _framework_from_tags(self, tags) -> str | None:
        tag_set = set(tags or [])
        if TAG_WAKU in tag_set:
            return "waku"
        if TAG_NEXTJS in tag_set or TAG_NEXTJS_APP_ROUTER in tag_set:
            return "nextjs"
        if TAG_EXPO in tag_set:
            return "expo"
        if TAG_REACT_ROUTER_V7 in tag_set or TAG_REACT_ROUTER_V6 in tag_set:
            return "react-router"
        if TAG_RSC in tag_set:
            return "rsc"
        return None

    @staticmethod
    def _has_fatal_fetch_error(snapshot: DetectionSnapshot) -> bool:
        return bool(snapshot.signals.get(SIG_FETCH_ERROR_MESSAGE))

    def _assessor_for_framework(self, framework: str | None):
        if framework is None:
            return None
        return self.assessors.get(framework)


__all__ = ["CVE202555182VulnerabilityDetector"]
