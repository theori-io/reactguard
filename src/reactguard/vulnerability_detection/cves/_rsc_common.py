# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""
Shared helpers for RSC / Flight protocol CVE detectors.

Several detectors share the same plumbing:
- framework detection -> DetectionSnapshot
- "initial fetch failed" handling
- assessor execution with `detect_context` + `PocJournal` injected via ScanContext

Centralizing this keeps CVE implementations focused on their framework- or CVE-specific logic.
"""

from __future__ import annotations

from typing import Any, Protocol

from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_FETCH_ERROR_MESSAGE,
)
from ...models import FrameworkDetectionResult, VulnerabilityReport
from ...models.poc import PocStatus
from ...utils.context import get_scan_context, scan_cache, scan_context
from ..journal import PocJournal, journal_context
from ..snapshots import DetectContext, DetectionSnapshot

RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY = "rsc_server_functions_surface_missing"
RSC_SURFACE_CACHE_NAMESPACE = "rsc_surface"


def rsc_surface_cache() -> dict[str, Any]:
    return scan_cache(RSC_SURFACE_CACHE_NAMESPACE, legacy_key=RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY)


class Assessor(Protocol):
    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: DetectContext | None = None,
    ) -> dict[str, Any]: ...


def build_fetch_failure_report(*, cve_id: str, detection: FrameworkDetectionResult) -> VulnerabilityReport:
    """Build a consistent INCONCLUSIVE report for initial fetch failures."""
    error_message = detection.signals.get(SIG_FETCH_ERROR_MESSAGE)
    reason = error_message or "Initial fetch failed; cannot run detector probes"
    journal = PocJournal()
    journal.add_event(
        "fetch-failure",
        "Initial fetch failed; detector probes skipped",
        outcome=PocStatus.INCONCLUSIVE,
        data={"error_message": error_message, "cve_id": cve_id},
    )
    journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="initial_fetch_failed")
    return VulnerabilityReport(
        status=PocStatus.INCONCLUSIVE,
        details={
            "cve_id": cve_id,
            "confidence": "low",
            "reason": reason,
            "framework": None,
            "error_message": error_message,
            "detection_confidence": detection.signals.get(SIG_DETECTION_CONFIDENCE),
            "detection_confidence_level": detection.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
        },
        raw_data={"detection": detection.signals, "journal": journal.to_list()},
    )


def run_assessor_with_context(
    assessor: Assessor,
    *,
    url: str,
    snapshot: DetectionSnapshot,
) -> dict[str, Any]:
    """
    Run an assessor with:
    - `detect_context` and `detection_snapshot` injected into ScanContext.extra
    - a fresh `PocJournal` bound as the ambient journal
    """
    context = get_scan_context()
    detect_context = snapshot.to_detect_context()

    # IMPORTANT: do not clone `ScanContext.extra`.
    #
    # Several assessors (notably the Dec 2025 fingerprinting assessor) intentionally cache probe work
    # in `scan_context().extra` so multiple CVEs can reuse it in a single scan. Cloning here breaks
    # that contract and causes duplicated probing / inconsistent cross-CVE results.
    extra = context.extra if isinstance(context.extra, dict) else {}
    _sentinel = object()
    prev_detect_context = extra.get("detect_context", _sentinel)
    prev_snapshot = extra.get("detection_snapshot", _sentinel)
    extra["detect_context"] = detect_context
    extra["detection_snapshot"] = snapshot

    journal = PocJournal()
    with journal_context(journal):
        try:
            with scan_context(extra=extra):
                return assessor.evaluate(
                    url,
                    snapshot.detected_versions,
                )
        finally:
            if prev_detect_context is _sentinel:
                extra.pop("detect_context", None)
            else:
                extra["detect_context"] = prev_detect_context
            if prev_snapshot is _sentinel:
                extra.pop("detection_snapshot", None)
            else:
                extra["detection_snapshot"] = prev_snapshot


__all__ = [
    "RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY",
    "rsc_surface_cache",
    "Assessor",
    "build_fetch_failure_report",
    "run_assessor_with_context",
]
