# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""
Shared helpers for RSC Server Functions CVE detectors.

Several detectors share the same plumbing:
- framework detection -> DetectionSnapshot
- "initial fetch failed" handling
- assessor execution with `detect_context` + `PocJournal` injected via ScanContext

Centralizing this keeps CVE implementations focused on their framework- or CVE-specific logic.
"""

from __future__ import annotations

from typing import Any, Protocol

from ...framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_FETCH_ERROR_MESSAGE,
)
from ...models import FrameworkDetectionResult, VulnerabilityReport
from ...models.poc import PocStatus
from ...utils.context import get_scan_context, scan_context
from ..journal import PocJournal, journal_context
from ..snapshots import DetectionSnapshot

RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY = "rsc_server_functions_surface_missing"


class Assessor(Protocol):
    def evaluate(
        self,
        base_url: str,
        detected_versions: dict[str, Any],
        detect_context: dict | None = None,
    ) -> dict[str, Any]: ...


def build_fetch_failure_report(*, cve_id: str, detection: FrameworkDetectionResult) -> VulnerabilityReport:
    """Build a consistent INCONCLUSIVE report for initial fetch failures."""
    error_message = detection.signals.get(SIG_FETCH_ERROR_MESSAGE)
    return VulnerabilityReport(
        status=PocStatus.INCONCLUSIVE,
        details={
            "cve_id": cve_id,
            "confidence": "low",
            "reason": error_message or "Initial fetch failed; cannot run detector probes",
            "framework": None,
            "error_message": error_message,
            "detection_confidence": detection.signals.get(SIG_DETECTION_CONFIDENCE),
            "detection_confidence_level": detection.signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
        },
        raw_data={"detection": detection.signals},
    )


def run_assessor_with_context(
    assessor: Assessor,
    *,
    url: str,
    snapshot: DetectionSnapshot,
) -> dict[str, Any]:
    """
    Run an assessor with:
    - `detect_context` and `detection_snapshot` injected into ScanContext.extra
    - a fresh `PocJournal` bound as the ambient journal
    """
    context = get_scan_context()
    detect_context = snapshot.to_detect_context()
    merged_extra = dict(context.extra) if isinstance(context.extra, dict) else {}
    merged_extra.update({"detect_context": detect_context, "detection_snapshot": snapshot})

    journal = PocJournal()
    with journal_context(journal):
        with scan_context(extra=merged_extra):
            return assessor.evaluate(
                url,
                snapshot.detected_versions,
            )


__all__ = [
    "RSC_SERVER_FUNCTIONS_SURFACE_CACHE_KEY",
    "Assessor",
    "build_fetch_failure_report",
    "run_assessor_with_context",
]
