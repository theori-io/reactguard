from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Safe patch-fingerprint probes for Dec 2025 RSC advisories."""

import html
import json
import re
import secrets
from collections.abc import Iterable
from typing import Any
from urllib.parse import urlencode
from urllib.parse import urlparse

from ...config import load_http_settings
from ...http.models import HttpRequest, RetryConfig
from ...http.retry import send_with_retries
from ...http.utils import get_http_client
from ...http.crawl import crawl_same_origin_html
from ...http.url import build_endpoint_candidates
from ...utils.actions import generate_action_id
from ...utils.context import get_scan_context, scan_context


def _user_agent() -> str:
    return load_http_settings().user_agent


def _scan_once(
    url: str,
    *,
    method: str = "GET",
    headers: dict[str, str] | None = None,
    body: str | bytes | None = None,
    timeout: float | None = None,
    allow_redirects: bool = True,
    http_client=None,
) -> dict[str, Any]:
    """
    Issue a single HTTP request (no retries) and return a request_with_retries-compatible mapping.

    These probes are intended to be deterministic and bounded.
    """
    settings = load_http_settings()
    context = get_scan_context()
    request_headers = dict(headers or {})
    request_headers.setdefault("User-Agent", settings.user_agent)
    client = http_client or context.http_client or get_http_client()
    effective_timeout = timeout if timeout is not None else (context.timeout if context.timeout is not None else settings.timeout)

    request = HttpRequest(
        url=url,
        method=method,
        headers=request_headers,
        body=body,
        timeout=effective_timeout,
        allow_redirects=allow_redirects,
    )

    response = send_with_retries(
        client,
        request,
        retry_config=RetryConfig(max_attempts=1),
    )

    return {
        "ok": response.ok,
        "status_code": response.status_code,
        "headers": response.headers,
        "body": response.text,
        "body_snippet": response.body_snippet,
        "url": response.url or url,
        "error_category": response.error_category,
        "error_message": response.error_message,
        "error_type": response.error_type,
        "meta": dict(response.meta or {}),
    }


def _build_multipart_body(parts: Iterable[tuple[str, str]]) -> tuple[str, str]:
    boundary = f"----FormBoundary{secrets.token_hex(8)}"
    body = ""
    for name, value in parts:
        body += f'--{boundary}\r\nContent-Disposition: form-data; name="{name}"\r\n\r\n{value}\r\n'
    body += f"--{boundary}--\r\n"
    return boundary, body


def _send_multipart(
    url: str,
    *,
    action_id: str,
    parts: Iterable[tuple[str, str]],
    timeout: float | None,
    http_client=None,
) -> dict[str, Any]:
    boundary, body = _build_multipart_body(parts)
    headers = {
        "Content-Type": f"multipart/form-data; boundary={boundary}",
        "Accept": "text/x-component",
        "Next-Action": action_id,
        "User-Agent": _user_agent(),
    }
    scan = _scan_once(
        url,
        method="POST",
        headers=headers,
        body=body,
        timeout=timeout,
        http_client=http_client,
    )
    scan.setdefault("action_id", action_id)
    return scan


def _send_urlencoded(
    url: str,
    *,
    action_id: str,
    parts: Iterable[tuple[str, str]],
    timeout: float | None,
    http_client=None,
) -> dict[str, Any]:
    body = urlencode(list(parts))
    headers = {
        # Next.js determines `isURLEncodedAction` using strict equality:
        #   content-type === "application/x-www-form-urlencoded"
        # If we include a charset parameter, Next will route the request to the
        # `decodeReply(body: string)` path and `JSON.parse` the query string.
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "text/x-component",
        "Next-Action": action_id,
        "User-Agent": _user_agent(),
    }
    scan = _scan_once(
        url,
        method="POST",
        headers=headers,
        body=body,
        timeout=timeout,
        http_client=http_client,
    )
    scan.setdefault("action_id", action_id)
    return scan


def _send_json_reply(
    url: str,
    *,
    action_id: str,
    payload: str,
    timeout: float | None,
    http_client=None,
) -> dict[str, Any]:
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json, text/x-component",
        "Next-Action": action_id,
        "User-Agent": _user_agent(),
    }
    scan = _scan_once(
        url,
        method="POST",
        headers=headers,
        body=payload,
        timeout=timeout,
        http_client=http_client,
    )
    scan.setdefault("action_id", action_id)
    return scan


_NEXT_ACTION_VALUE_BEFORE_NAME_RE = re.compile(r'value=[\'"]([^\'"]+)[\'"][^>]*name=[\'"]\\$ACTION_[^\'"]+[\'"]')
_NEXT_ACTION_NAME_BEFORE_VALUE_RE = re.compile(r'name=[\'"]\\$ACTION_[^\'"]+[\'"][^>]*value=[\'"]([^\'"]+)[\'"]')
_NEXT_ACTION_JSON_ID_RE = re.compile(r'"id"\\s*:\\s*"([^"]+)"')
_NEXT_ACTION_ESCAPED_ID_RE = re.compile(r"&quot;id&quot;:&quot;([^&]+)&quot;")


def _extract_nextjs_action_id_from_html(html_text: str) -> str | None:
    if not html_text:
        return None

    # Fast path: look for the escaped JSON payload in the `$ACTION_*` hidden input value.
    match = _NEXT_ACTION_ESCAPED_ID_RE.search(html_text)
    if match:
        return match.group(1)

    for regex in (_NEXT_ACTION_NAME_BEFORE_VALUE_RE, _NEXT_ACTION_VALUE_BEFORE_NAME_RE):
        match = regex.search(html_text)
        if not match:
            continue

        raw_value = html.unescape(match.group(1)).strip()
        if not raw_value:
            continue

        try:
            parsed = json.loads(raw_value)
            if isinstance(parsed, dict) and parsed.get("id"):
                return str(parsed["id"])
        except Exception:
            fallback = _NEXT_ACTION_JSON_ID_RE.search(raw_value)
            if fallback:
                return fallback.group(1)

    return None


_NEXT_ACTION_HEADER_LITERAL_RE = re.compile(r'["\']next-action["\']\s*:\s*["\']([^"\']+)["\']', re.IGNORECASE)
_NEXT_ACTION_HEADER_SET_RE = re.compile(r'\.set\(\s*["\']next-action["\']\s*,\s*["\']([^"\']+)["\']\s*\)', re.IGNORECASE)
_NEXT_ACTION_HEADER_APPEND_RE = re.compile(r'\.append\(\s*["\']next-action["\']\s*,\s*["\']([^"\']+)["\']\s*\)', re.IGNORECASE)
_NEXT_ACTION_HEADER_BRACKET_RE = re.compile(r'\[\s*["\']next-action["\']\s*\]\s*=\s*["\']([^"\']+)["\']', re.IGNORECASE)

_SCRIPT_SRC_RE = re.compile(r"<script[^>]+src=[\"']([^\"']+)[\"']", re.IGNORECASE)
_LINK_HREF_RE = re.compile(r"<link[^>]+href=[\"']([^\"']+)[\"']", re.IGNORECASE)
_IMPORT_CALL_RE = re.compile(r'import\(\s*["\']([^"\']+)["\']\s*\)', re.IGNORECASE)


def _same_origin(a: str, b: str) -> bool:
    pa = urlparse(a)
    pb = urlparse(b)
    return (pa.scheme, pa.netloc) == (pb.scheme, pb.netloc)


def _looks_like_js_asset(path: str) -> bool:
    if not path:
        return False
    candidate = str(path).split("?", 1)[0].split("#", 1)[0].lower()
    return candidate.endswith((".js", ".mjs", ".ts", ".tsx", ".jsx"))


def _extract_next_action_header_ids(text: str) -> list[str]:
    if not text:
        return []

    candidates: list[str] = []
    for regex in (
        _NEXT_ACTION_HEADER_LITERAL_RE,
        _NEXT_ACTION_HEADER_SET_RE,
        _NEXT_ACTION_HEADER_APPEND_RE,
        _NEXT_ACTION_HEADER_BRACKET_RE,
    ):
        for match in regex.finditer(text):
            value = (match.group(1) or "").strip()
            if not value:
                continue
            if any(ch.isspace() for ch in value):
                continue
            if len(value) > 512:
                continue
            candidates.append(value)

    # De-dupe while preserving order.
    return list(dict.fromkeys(candidates))


def discover_next_action_ids(
    url: str,
    *,
    timeout: float | None = 5.0,
    http_client=None,
    max_pages: int = 6,
    max_depth: int = 2,
    max_assets: int = 16,
) -> list[str]:
    """
    Best-effort discovery of valid `Next-Action` IDs from same-origin content.

    Sources (GET-only, bounded):
    - Next.js `$ACTION_*` hidden input payloads in HTML
    - Literal `Next-Action` header values embedded in inline scripts / JS bundles
    """
    if not url:
        return []

    if http_client is not None:
        with scan_context(http_client=http_client):
            return discover_next_action_ids(
                url,
                timeout=timeout,
                http_client=None,
                max_pages=max_pages,
                max_depth=max_depth,
                max_assets=max_assets,
            )

    action_ids: list[str] = []
    asset_urls: list[str] = []

    pages = crawl_same_origin_html(url, max_pages=max_pages, max_depth=max_depth, timeout=timeout, http_client=http_client)
    for page in pages:
        body = page.body or ""
        if not body:
            continue

        next_id = _extract_nextjs_action_id_from_html(body)
        if next_id:
            action_ids.append(next_id)

        action_ids.extend(_extract_next_action_header_ids(body))

        for regex in (_SCRIPT_SRC_RE, _LINK_HREF_RE, _IMPORT_CALL_RE):
            for match in regex.finditer(body):
                raw = (match.group(1) or "").strip()
                if not raw:
                    continue
                if raw.startswith(("data:", "javascript:", "mailto:", "tel:")):
                    continue
                if raw.startswith(("http://", "https://")):
                    # Only follow same-origin absolute URLs.
                    if not _same_origin(url, raw):
                        continue
                    candidate_urls = [raw]
                else:
                    # Support both root-relative and base-relative paths.
                    candidate_urls = build_endpoint_candidates(page.url or url, raw)
                for candidate_url in candidate_urls:
                    if not candidate_url or not _same_origin(url, candidate_url):
                        continue
                    asset_urls.append(candidate_url)

    asset_urls = list(dict.fromkeys([u for u in asset_urls if u]))
    js_assets = [u for u in asset_urls if _looks_like_js_asset(u)]

    for asset_url in js_assets[:max_assets]:
        resp = _scan_once(
            asset_url,
            method="GET",
            headers={"Accept": "application/javascript, text/javascript, */*"},
            timeout=timeout,
            allow_redirects=True,
            http_client=http_client,
        )
        if not resp.get("ok"):
            continue
        body = str(resp.get("body") or resp.get("body_snippet") or "")
        if not body:
            continue
        action_ids.extend(_extract_next_action_header_ids(body))

    # De-dupe while preserving order.
    return list(dict.fromkeys([a for a in action_ids if a]))


def discover_nextjs_action_id(
    url: str,
    *,
    timeout: float | None = 5.0,
    http_client=None,
) -> str | None:
    """
    Best-effort extraction of a valid Next.js Server Action ID from the rendered HTML.

    Next.js Server Actions require a valid `Next-Action` header. When scanning in a lab we can scrape an
    action ID from the server-rendered form payload (hidden `$ACTION_*` inputs).
    """
    result = _scan_once(
        url,
        method="GET",
        headers={"Accept": "text/html, */*"},
        timeout=timeout,
        http_client=http_client,
    )
    body = str(result.get("body") or result.get("body_snippet") or "")
    return _extract_nextjs_action_id_from_html(body)


def discover_nextjs_action_entrypoint(
    url: str,
    *,
    timeout: float | None = 5.0,
    http_client=None,
    max_pages: int = 6,
    max_depth: int = 2,
) -> tuple[str, str] | None:
    """
    Discover a (page_url, action_id) pair for Next.js Server Actions.

    Many real apps don't expose an action form on the landing page. We use a bounded same-origin
    crawl (GET-only) and return the first page that contains a `$ACTION_*` form payload.
    """
    if not url:
        return None

    if http_client is not None:
        with scan_context(http_client=http_client):
            return discover_nextjs_action_entrypoint(
                url,
                timeout=timeout,
                http_client=None,
                max_pages=max_pages,
                max_depth=max_depth,
            )

    pages = crawl_same_origin_html(url, max_pages=max_pages, max_depth=max_depth, timeout=timeout, http_client=http_client)
    for page in pages:
        if not page.body:
            continue
        action_id = _extract_nextjs_action_id_from_html(page.body)
        if action_id:
            return page.url, action_id
    return None


def send_rsc_decode_control_probe(
    url: str,
    *,
    action_id: str | None = None,
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """Minimal decode-surface probe (multipart with `0=[]`)."""
    effective_action_id = action_id or generate_action_id()
    parts = [("0", "[]")]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)


def _nextjs_default_prev_state() -> dict[str, Any]:
    # Minimal ActionState shape for our Next.js lab Server Actions (useActionState-like signatures).
    # Keep this stable so probes remain deterministic across containers.
    return {
        "status": "reactguard probe",
        "queueLength": 0,
        "recent": [],
        "lastDetail": "",
    }


def send_nextjs_decode_control_probe(
    url: str,
    *,
    action_id: str,
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Next.js Server Action decode-surface probe (multipart) that supplies valid args.

    Many Next.js actions are built around `useActionState` and expect two arguments:
    (prevState, formData). Sending `0=[]` can cause the action to throw and Next.js to return an HTML error
    page, which makes patch fingerprinting unreliable.

    This probe keeps the action successful by sending:
    - prevState in chunk 1
    - FormData marker `$K3` backed by at least one `3_*` field
    - root args array in chunk 0: ["$1", "$K3"]
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js Server Action probes")

    parts = [
        ("1", json.dumps(_nextjs_default_prev_state())),
        ("3_title", "reactguard-probe"),
        ("0", json.dumps(["$1", "$K3"])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_nextjs_server_reference_marker_probe(
    url: str,
    *,
    action_id: str,
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Next.js variant of the PR #35345 fingerprint via server reference marker `$h`.

    Uses a valid (prevState, formData) prefix so the Server Action itself succeeds on patched runtimes, while
    the `$h` marker determines whether React's decode surface accepts/rejects the payload.
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js Server Action probes")

    parts = [
        ("1", json.dumps(_nextjs_default_prev_state())),
        ("4", json.dumps({"id": None})),
        ("3_title", "reactguard-probe"),
        ("0", json.dumps(["$1", "$K3", "$h4"])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_nextjs_proto_probe(
    url: str,
    *,
    action_id: str,
    server_ref_marker: str = "F",
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Next.js Server Action proto probe for CVE-2025-55182.

    Keeps typical two-argument actions successful by sending (prevState, formData) first and placing the
    proto traversal payload as a third argument so it is deserialized but usually ignored by app code.
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js Server Action probes")
    if server_ref_marker not in {"F", "h"}:
        raise ValueError("server_ref_marker must be 'F' or 'h'")

    parts = [
        ("1", json.dumps(_nextjs_default_prev_state())),
        ("4", json.dumps({"x": {}})),
        ("3_title", "reactguard-probe"),
        ("0", json.dumps(["$1", "$K3", f"${server_ref_marker}4:x:__proto__"])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_nextjs_control_probe(
    url: str,
    *,
    action_id: str,
    server_ref_marker: str = "F",
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """Next.js control probe paired with `send_nextjs_proto_probe` (uses a random safe property path)."""
    if not action_id:
        raise ValueError("action_id is required for Next.js Server Action probes")
    if server_ref_marker not in {"F", "h"}:
        raise ValueError("server_ref_marker must be 'F' or 'h'")

    safe_prop = f"z{secrets.token_hex(4)}"
    parts = [
        ("1", json.dumps(_nextjs_default_prev_state())),
        ("4", json.dumps({"x": {}})),
        ("3_title", "reactguard-probe"),
        ("0", json.dumps(["$1", "$K3", f"${server_ref_marker}4:x:{safe_prop}"])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def _nextjs_synthetic_action_fields(*, action_id: str) -> list[tuple[str, str]]:
    """
    Build minimal `$ACTION_*` fields that convince Next.js to treat a request as a Server Action POST even
    when the `Next-Action` id is unknown/invalid (common on RSC-only pages with no declared actions).

    The values mirror Next.js' progressive-enhancement form encoding:
    - `$ACTION_REF_1` indicates an action ref is present
    - `$ACTION_1:0` carries the action id and a `bound` pointer
    - `$ACTION_1:1` provides a placeholder bound args payload
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js synthetic Server Action probes")
    return [
        ("$ACTION_REF_1", ""),
        ("$ACTION_1:0", json.dumps({"id": action_id, "bound": "$@1"})),
        ("$ACTION_1:1", "[]"),
    ]


def send_nextjs_synthetic_proto_probe(
    url: str,
    *,
    action_id: str,
    server_ref_marker: str = "F",
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Next.js synthetic proto probe for CVE-2025-55182 when no valid action id can be discovered.

    This probe is designed to be side-effect-safe: it uses an (almost certainly) invalid action id but
    forces Next.js into the Server Actions request path by including `$ACTION_*` form fields. We then
    inject a prototype traversal marker so patched/vulnerable behaviors diverge before any app action
    code executes.
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js synthetic Server Action probes")
    if server_ref_marker not in {"F", "h"}:
        raise ValueError("server_ref_marker must be 'F' or 'h'")

    parts: list[tuple[str, str]] = [
        *_nextjs_synthetic_action_fields(action_id=action_id),
        ("1", json.dumps({"x": {}})),
        ("0", json.dumps([f"${server_ref_marker}1:x:__proto__"])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_nextjs_synthetic_control_probe(
    url: str,
    *,
    action_id: str,
    server_ref_marker: str = "F",
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """Control probe paired with `send_nextjs_synthetic_proto_probe` (random safe property path)."""
    if not action_id:
        raise ValueError("action_id is required for Next.js synthetic Server Action probes")
    if server_ref_marker not in {"F", "h"}:
        raise ValueError("server_ref_marker must be 'F' or 'h'")

    safe_prop = f"z{secrets.token_hex(4)}"
    parts: list[tuple[str, str]] = [
        *_nextjs_synthetic_action_fields(action_id=action_id),
        ("1", json.dumps({"x": {}})),
        ("0", json.dumps([f"${server_ref_marker}1:x:{safe_prop}"])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def _build_thenable_chain_parts(*, chain_depth: int, start_chunk_id: int) -> tuple[list[tuple[str, str]], str]:
    if chain_depth < 1:
        raise ValueError("chain_depth must be >= 1")
    if start_chunk_id < 1:
        raise ValueError("start_chunk_id must be >= 1")

    promise_count = chain_depth + 1
    promise_ids = [start_chunk_id + i for i in range(promise_count)]
    last_promise_id = promise_ids[-1]
    init_chunk_id = last_promise_id + 1
    root_object_id = init_chunk_id + 1

    parts: list[tuple[str, str]] = []
    parts.append((str(last_promise_id), "[]"))
    for index in range(promise_count - 2, -1, -1):
        promise_id = promise_ids[index]
        next_id = promise_ids[index + 1]
        parts.append((str(promise_id), f'"$@{next_id:x}"'))

    init_list = [f"${pid:x}" for pid in reversed(promise_ids)]
    parts.append((str(init_chunk_id), json.dumps(init_list)))
    parts.append((str(root_object_id), f'{{"a":"$@{promise_ids[0]:x}","b":"${init_chunk_id:x}"}}'))

    return parts, f"${root_object_id:x}:a"


def send_nextjs_promise_chain_probe(
    url: str,
    *,
    chain_depth: int,
    action_id: str,
    timeout: float | None = 8.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Next.js variant of the PR #35351 finite thenable-chain probe.

    We keep the Server Action invocation successful by providing (prevState, formData) as the first two args.
    The thenable-chain payload is added as a *third* argument so typical two-arg actions ignore it, while React's
    decode surface still has to deserialize it.
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js Server Action probes")

    chain_parts, chain_ref = _build_thenable_chain_parts(chain_depth=chain_depth, start_chunk_id=10)
    parts: list[tuple[str, str]] = [
        ("1", json.dumps(_nextjs_default_prev_state())),
        *chain_parts,
        ("3_title", "reactguard-probe"),
        ("0", json.dumps(["$1", "$K3", chain_ref])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_nextjs_promise_chain_root_probe(
    url: str,
    *,
    chain_depth: int,
    action_id: str,
    timeout: float | None = 8.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Next.js PR #35351 fingerprint probe that forces Next.js to await a ReactPromise chain.

    Unlike `send_nextjs_promise_chain_probe` (which embeds the chain as an *argument* and may never be awaited),
    this probe sets the **root** chunk (`0`) to a thenable chain so Next.js' `await decodeReply(...)` must
    assimilate it, triggering the `cycleProtection` traversal on patched runtimes.

    Safety:
    - Uses `application/x-www-form-urlencoded` so Next.js runs the non-busboy `decodeReply(formData, ...)` path.
    - The chain resolves to an argsArray-like object with `length: $n1` (BigInt), causing
      `actionHandler.apply(...)` to throw before invoking the app action function.
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js Server Action probes")
    if chain_depth < 1:
        raise ValueError("chain_depth must be >= 1")

    # See `send_rsc_promise_chain_probe` for a detailed rationale.
    promise_count = chain_depth + 1
    init_chunk_id = promise_count + 1
    wrapper_chunk_id = promise_count + 2

    parts: list[tuple[str, str]] = []

    # Terminal: produce an argsArray-like object with a BigInt length so `Function.prototype.apply` throws
    # before invoking the app action function.
    parts.append((str(promise_count), json.dumps({"length": "$n1"})))
    for promise_id in range(promise_count - 1, 0, -1):
        next_hex = f"{(promise_id + 1):x}"
        parts.append((str(promise_id), f'"$@{next_hex}"'))

    init_list = [f"${pid:x}" for pid in range(promise_count, 0, -1)]
    parts.append((str(init_chunk_id), json.dumps(init_list)))

    # Wrapper array: element 0 is the root thenable; element 1 forces initialization of the init-list chunk.
    #
    # NOTE: Avoid an object wrapper (`{"a":..., "b":...}`) here. The React decoder can lazily resolve
    # `"$<id>:a"` without parsing unrelated properties, which would skip the init-list side effect.
    # Arrays are parsed eagerly, so `"$<id>:0"` forces both elements to be processed.
    parts.append((str(wrapper_chunk_id), f'["$@1","${init_chunk_id:x}"]'))
    parts.append(("0", f'"${wrapper_chunk_id:x}:0"'))

    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_urlencoded(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_urlencoded(url, action_id=action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_rsc_decode_control_probe_json(
    url: str,
    *,
    action_id: str | None = None,
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """Minimal decode-surface probe (JSON reply with `[]`)."""
    effective_action_id = action_id or generate_action_id()
    payload = "[]"
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_json_reply(url, action_id=effective_action_id, payload=payload, timeout=timeout, http_client=http_client)
    return _send_json_reply(url, action_id=effective_action_id, payload=payload, timeout=timeout, http_client=http_client)


def send_rsc_legacy_reference_probe(
    url: str,
    *,
    action_id: str | None = None,
    timeout: float | None = 5.0,
    http_client=None,
    target_prop: str = "toString",
) -> dict[str, Any]:
    """
    Legacy reference probe (kept for research/backwards-compatibility).

    This probe is not used for the Dec 2025 patch fingerprint anymore, because it behaves inconsistently across
    19.0.0 vs 19.0.1+.
    """
    effective_action_id = action_id or generate_action_id()
    parts = [
        ("1", '{"x":{}}'),
        ("0", f'["$F1:x:{target_prop}"]'),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_rsc_server_reference_marker_probe(
    url: str,
    *,
    action_id: str | None = None,
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Fingerprint the PR #35345 patch via server reference marker `$h`.

    PR #35345 changed the server reference marker from `$F` to `$h`.

    This probe is designed to be:
    - deterministic (very small payload)
    - safe (never attempts to load a real server reference)
    - compatible across pre-/post-patch targets

    It works by sending a server reference marker that resolves to `null` on patched targets:
    - post-PR#35345 (has `$h` parsing): decodes to `null` and should return `< 400`
    - pre-PR#35345 (no `$h` parsing): fails decode and should return `>= 400`
    """
    effective_action_id = action_id or generate_action_id()
    parts = [
        ("1", json.dumps({"id": None})),
        ("0", json.dumps(["$h1"])),
    ]
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)


def send_rsc_server_reference_marker_probe_json(
    url: str,
    *,
    action_id: str | None = None,
    timeout: float | None = 5.0,
    http_client=None,
) -> dict[str, Any]:
    """
    JSON-body variant of the PR #35345 fingerprint via server reference marker `$h`.

    Uses an in-chunk outlined model (`$h0`) that should decode to `null` on post-PR#35345 runtimes.
    """
    effective_action_id = action_id or generate_action_id()
    payload = json.dumps([{"id": None}, "$h0"])
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_json_reply(url, action_id=effective_action_id, payload=payload, timeout=timeout, http_client=http_client)
    return _send_json_reply(url, action_id=effective_action_id, payload=payload, timeout=timeout, http_client=http_client)


def send_rsc_promise_chain_probe(
    url: str,
    *,
    chain_depth: int,
    action_id: str | None = None,
    timeout: float | None = 8.0,
    http_client=None,
) -> dict[str, Any]:
    """
    Finite "thenable chain" probe used to fingerprint the extra protection patch (PR #35351).

    This probe avoids creating true cyclic thenables (which can hang vulnerable targets). Instead, it constructs a
    *finite*, pre-initialized chain of fulfilled ReactPromises so that when React assimilates the thenable it runs
    the PR #35351 `cycleProtection` traversal.

    - `chain_depth=1000` should *not* trip the `cycleProtection > 1000` guard.
    - `chain_depth=1001` should trip it on patched runtimes, returning "Cannot have cyclic thenables."
    """
    if chain_depth < 1:
        raise ValueError("chain_depth must be >= 1")

    effective_action_id = action_id or generate_action_id()

    # IDs in `$@...` and outlined references are encoded in hex (serializePromiseID uses `id.toString(16)`).
    #
    # We avoid deep recursive initialization (which can overflow the JS call stack) by separating the concerns:
    #
    #   - Promise chunks: 1..chain_depth (each points to the next promise; the last is terminal `[]`)
    #   - Init chunk:     chain_depth + 1 (an array that forces initialization of every promise, deepest-first)
    #   - Root chunk:     0 (outlined reference into an object that triggers init and then returns `$@1`)
    #
    # Root (chunk 0) resolves via an outlined reference into object O0:
    #   chunk0 = "$<O0>:a"
    #   O0     = {"a":"$@1","b":"$<init_chunk>"}
    #
    # The init chunk value is a JSON array like: ["$<N>","$<N-1>",...,"$1"] which forces each promise chunk to
    # be initialized (fulfilled) without recursively walking the chain.
    # IMPORTANT: `Promise.resolve(reactPromiseChunk0)` first resolves chunk 0, then assimilates the *returned*
    # thenable (promise 1). The PR #35351 guard counts from `this.value` (promise 2 onward), so we build
    # `chain_depth + 1` promises total to make the boundary test behave as intended.
    promise_count = chain_depth + 1
    init_chunk_id = promise_count + 1
    root_object_id = promise_count + 2

    parts: list[tuple[str, str]] = []

    # Promise chunks (send before chunk 0 so all values are present in FormData before initialization begins).
    parts.append((str(promise_count), "[]"))
    for promise_id in range(promise_count - 1, 0, -1):
        next_hex = f"{(promise_id + 1):x}"
        parts.append((str(promise_id), f'"$@{next_hex}"'))

    # Init chunk: outlined refs to every promise, deepest-first (so promise i+1 is fulfilled before promise i).
    init_list = [f"${pid:x}" for pid in range(promise_count, 0, -1)]
    parts.append((str(init_chunk_id), json.dumps(init_list)))

    # Root object triggers init then returns promise 1.
    parts.append((str(root_object_id), f'{{"a":"$@1","b":"${init_chunk_id:x}"}}'))

    # Root: outlined reference into O0.a.
    parts.append(("0", f'"${root_object_id:x}:a"'))

    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)
    return _send_multipart(url, action_id=effective_action_id, parts=parts, timeout=timeout, http_client=http_client)


__all__ = [
    "discover_nextjs_action_id",
    "discover_next_action_ids",
    "send_rsc_decode_control_probe",
    "send_rsc_decode_control_probe_json",
    "send_rsc_legacy_reference_probe",
    "send_nextjs_decode_control_probe",
    "send_nextjs_proto_probe",
    "send_nextjs_control_probe",
    "send_nextjs_promise_chain_probe",
    "send_nextjs_promise_chain_root_probe",
    "send_nextjs_server_reference_marker_probe",
    "send_rsc_server_reference_marker_probe",
    "send_rsc_server_reference_marker_probe_json",
    "send_rsc_promise_chain_probe",
]
