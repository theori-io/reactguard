# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Next.js Server Action discovery and probe helpers."""

from __future__ import annotations

import html
import json
import re
from html.parser import HTMLParser
from ...http.crawl import crawl_same_origin_html
from ...http.heuristics import looks_like_html
from ...http.js import extract_js_asset_urls
from ...http.models import HttpResponse
from ...http.utils import request_once
from ...rsc.heuristics import extract_error_digest, is_action_not_found_response, response_looks_like_flight
from ...rsc.payloads import build_no_invoke_temp_ref_payload


def _scan_once(
    url: str,
    *,
    method: str = "GET",
    headers: dict[str, str] | None = None,
    body: str | bytes | None = None,
    allow_redirects: bool = True,
) -> HttpResponse:
    """
    Issue a single HTTP request (no retries) and return a request_with_retries-compatible mapping.

    These probes are intended to be deterministic and bounded.
    """
    return request_once(
        url,
        method=method,
        headers=headers,
        body=body,
        allow_redirects=allow_redirects,
    )




_NEXT_ACTION_VALUE_BEFORE_NAME_RE = re.compile(r'value=[\'"]([^\'"]+)[\'"][^>]*name=[\'"]\$ACTION_[^\'"]+[\'"]')
_NEXT_ACTION_NAME_BEFORE_VALUE_RE = re.compile(r'name=[\'"]\$ACTION_[^\'"]+[\'"][^>]*value=[\'"]([^\'"]+)[\'"]')
_NEXT_ACTION_JSON_ID_RE = re.compile(r'"id"\s*:\s*"([^"]+)"')
_NEXT_ACTION_ESCAPED_ID_RE = re.compile(r"&quot;id&quot;:&quot;([^&]+)&quot;")


class _NextActionInputParser(HTMLParser):
    def __init__(self) -> None:
        super().__init__()
        self.values: list[str] = []

    def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None:
        if tag.lower() != "input":
            return
        attr_map = {str(k).lower(): ("" if v is None else str(v)) for k, v in attrs if k}
        name = (attr_map.get("name") or "").strip()
        if not name.startswith("$ACTION_"):
            return
        value = attr_map.get("value")
        if value:
            self.values.append(value)


def _extract_nextjs_action_id_from_html(html_text: str) -> str | None:
    if not html_text:
        return None

    # Fast path: look for the escaped JSON payload in the `$ACTION_*` hidden input value.
    match = _NEXT_ACTION_ESCAPED_ID_RE.search(html_text)
    if match:
        return match.group(1)

    for regex in (_NEXT_ACTION_NAME_BEFORE_VALUE_RE, _NEXT_ACTION_VALUE_BEFORE_NAME_RE):
        match = regex.search(html_text)
        if not match:
            continue

        raw_value = html.unescape(match.group(1)).strip()
        if not raw_value:
            continue

        try:
            parsed = json.loads(raw_value)
            if isinstance(parsed, dict) and parsed.get("id"):
                return str(parsed["id"])
        except Exception:
            fallback = _NEXT_ACTION_JSON_ID_RE.search(raw_value)
            if fallback:
                return fallback.group(1)

    # Fallback: parse <input> tags to support attribute values containing quotes (e.g. single-quoted JSON).
    parser = _NextActionInputParser()
    try:
        parser.feed(html_text)
    except Exception:
        return None

    for value in parser.values:
        raw_value = html.unescape(value).strip()
        if not raw_value:
            continue
        try:
            parsed = json.loads(raw_value)
            if isinstance(parsed, dict) and parsed.get("id"):
                return str(parsed["id"])
        except Exception:
            fallback = _NEXT_ACTION_JSON_ID_RE.search(raw_value)
            if fallback:
                return fallback.group(1)

    return None


_NEXT_ACTION_HEADER_LITERAL_RE = re.compile(r'["\']next-action["\']\s*:\s*["\']([^"\']+)["\']', re.IGNORECASE)
_NEXT_ACTION_HEADER_SET_RE = re.compile(r'\.set\(\s*["\']next-action["\']\s*,\s*["\']([^"\']+)["\']\s*\)', re.IGNORECASE)
_NEXT_ACTION_HEADER_APPEND_RE = re.compile(r'\.append\(\s*["\']next-action["\']\s*,\s*["\']([^"\']+)["\']\s*\)', re.IGNORECASE)
_NEXT_ACTION_HEADER_BRACKET_RE = re.compile(r'\[\s*["\']next-action["\']\s*\]\s*=\s*["\']([^"\']+)["\']', re.IGNORECASE)
_NEXT_ACTION_HEX_TOKEN_RE = re.compile(r"\b[0-9a-f]{42}\b", re.IGNORECASE)
# Next.js dev bundles may embed RSC runtime sources inside string literals (e.g. `case \"h\":`), so
# accept an optional escaping backslash before each quote.
#
# To avoid false positives from unrelated switch statements, require the `case "T":` arm to appear
# shortly after the marker arm (this mirrors parseModelString-style switches in RSC runtimes).
_NEXT_RSC_MARKER_CASE_H_RE = re.compile(r"case\s*\\?[\"']h\\?[\"']\s*:.{0,2000}?case\s*\\?[\"']T\\?[\"']\s*:", re.DOTALL)
_NEXT_RSC_MARKER_CASE_F_RE = re.compile(r"case\s*\\?[\"']F\\?[\"']\s*:.{0,2000}?case\s*\\?[\"']T\\?[\"']\s*:", re.DOTALL)

def _collect_js_assets(pages, base_url: str, *, max_assets: int) -> list[str]:
    asset_urls: list[str] = []
    for page in pages:
        body = page.body or ""
        if not body:
            continue
        asset_urls.extend(extract_js_asset_urls(body, page.url or base_url, max_assets=max_assets))
    return list(dict.fromkeys([u for u in asset_urls if u]))


def _collect_js_asset_referrers(pages, base_url: str, *, max_assets: int) -> dict[str, str]:
    asset_referrers: dict[str, str] = {}
    for page in pages:
        body = page.body or ""
        if not body:
            continue
        for asset_url in extract_js_asset_urls(body, page.url or base_url, max_assets=max_assets):
            asset_referrers.setdefault(asset_url, page.url or base_url)
    return asset_referrers


def _extract_next_action_header_ids(text: str) -> list[str]:
    if not text:
        return []

    candidates: list[str] = []
    for regex in (
        _NEXT_ACTION_HEADER_LITERAL_RE,
        _NEXT_ACTION_HEADER_SET_RE,
        _NEXT_ACTION_HEADER_APPEND_RE,
        _NEXT_ACTION_HEADER_BRACKET_RE,
    ):
        for match in regex.finditer(text):
            value = (match.group(1) or "").strip()
            if not value:
                continue
            if any(ch.isspace() for ch in value):
                continue
            if len(value) > 512:
                continue
            candidates.append(value)

    # De-dupe while preserving order.
    return list(dict.fromkeys(candidates))


def _extract_next_action_hex_tokens(text: str) -> list[str]:
    if not text:
        return []
    candidates = [m.group(0) for m in _NEXT_ACTION_HEX_TOKEN_RE.finditer(text) if m.group(0)]

    # De-dupe while preserving order (case-insensitive).
    out: list[str] = []
    seen: set[str] = set()
    for token in candidates:
        key = token.lower()
        if key in seen:
            continue
        seen.add(key)
        out.append(token)
    return out


def _looks_like_nextjs_action_decode_response(resp: HttpResponse) -> bool:
    if not resp or not resp.ok or resp.status_code is None:
        return False
    headers = resp.headers or {}
    body = str(resp.text or resp.body_snippet or "")
    if response_looks_like_flight(headers, body):
        return True
    return bool(extract_error_digest(body))


def _validate_nextjs_action_id(page_url: str, action_id: str, *, fallback_urls: list[str] | None = None) -> bool:
    """
    Validate a candidate Next.js `Next-Action` ID with a bounded, no-invoke probe.

    Many Next.js deployments require a *valid* action ID to reach the Flight protocol deserializer.
    This helper avoids returning "best guess" IDs (e.g., unrelated 42-hex tokens) that can cause
    systematic false negatives in downstream probes.
    """
    page_url = str(page_url or "")
    action_id = str(action_id or "").strip()
    if not page_url or not action_id:
        return False

    # Use a no-invoke payload that forces decode errors before any server action invocation.
    payload = build_no_invoke_temp_ref_payload(meta={"probe_kind": "nextjs_action_id_validate"})
    candidate_urls = [page_url]
    for alt in fallback_urls or []:
        alt_str = str(alt or "").strip()
        if alt_str and alt_str not in candidate_urls:
            candidate_urls.append(alt_str)

    for candidate_url in candidate_urls:
        resp = _scan_once(
            candidate_url,
            method="POST",
            headers={
                "Accept": "text/x-component, */*",
                "Next-Action": action_id,
                **(payload.headers or {}),
            },
            body=payload.body,
            allow_redirects=True,
        )

        # Treat explicit "action not found" as a strong negative for this candidate.
        if is_action_not_found_response(resp):
            continue

        if _looks_like_nextjs_action_decode_response(resp):
            return True

        # Auth-gated or throttled endpoints can return HTML without exposing Flight/digest.
        status = resp.status_code
        headers = resp.headers or {}
        if status in (401, 403, 429):
            return True
        if response_looks_like_flight(headers, None):
            return True
        body_text = resp.text or resp.body_snippet or ""
        if looks_like_html(headers, body_text):
            vary = str(headers.get("vary") or "").lower()
            if "rsc" in vary:
                return True

    return False


def discover_next_action_ids(
    url: str,
    *,
    max_pages: int | None = None,
    max_depth: int | None = None,
    max_assets: int = 20,
) -> list[str]:
    """
    Best-effort discovery of valid `Next-Action` IDs from same-origin content.

    Sources (GET-only, bounded, landing-page only):
    - Next.js `$ACTION_*` hidden input payloads in HTML
    - Literal `Next-Action` header values embedded in inline scripts / JS bundles
    """
    if not url:
        return []

    action_ids: list[str] = []
    html_action_ids: list[str] = []
    asset_urls: list[str] = []

    effective_max_pages = 6 if max_pages is None else max_pages
    effective_max_depth = 2 if max_depth is None else max_depth
    pages = crawl_same_origin_html(
        url,
        max_pages=effective_max_pages,
        max_depth=effective_max_depth,
    )
    for page in pages:
        body = page.body or ""
        if not body:
            continue

        action_ids.extend(_extract_next_action_header_ids(body))
        action_ids.extend(_extract_next_action_hex_tokens(body))

        next_id = _extract_nextjs_action_id_from_html(body)
        if next_id:
            html_action_ids.append(next_id)

    asset_urls = _collect_js_assets(pages, url, max_assets=max_assets)

    for asset_url in asset_urls[:max_assets]:
        resp = _scan_once(
            asset_url,
            method="GET",
            headers={"Accept": "application/javascript, text/javascript, */*"},
            allow_redirects=True,
        )
        if not resp.ok:
            continue
        body = str(resp.text or resp.body_snippet or "")
        if not body:
            continue
        action_ids.extend(_extract_next_action_header_ids(body))
        action_ids.extend(_extract_next_action_hex_tokens(body))

    # De-dupe while preserving order.
    merged = [*action_ids, *html_action_ids]
    return list(dict.fromkeys([a for a in merged if a]))


def discover_nextjs_server_reference_marker(
    url: str,
    *,
    max_pages: int | None = None,
    max_depth: int | None = None,
    max_assets: int = 20,
) -> str | None:
    """
    Best-effort discovery of the React Server Components server-reference marker used by Next.js bundles.

    This is a bounded, GET-only heuristic that scans same-origin JS assets for a parseModelString-style
    switch case:
    - `case "F":` in pre-PR#35345 React builds
    - `case "h":` in post-PR#35345 React builds

    Returns: "F", "h", or None (ambiguous / not found).
    """
    if not url:
        return None

    effective_max_pages = 6 if max_pages is None else max_pages
    effective_max_depth = 2 if max_depth is None else max_depth

    pages = crawl_same_origin_html(
        url,
        max_pages=effective_max_pages,
        max_depth=effective_max_depth,
    )
    asset_urls = _collect_js_assets(pages, url, max_assets=max_assets)

    saw_h = False
    saw_f = False
    for asset_url in asset_urls[:max_assets]:
        resp = _scan_once(
            asset_url,
            method="GET",
            headers={"Accept": "application/javascript, text/javascript, */*"},
            allow_redirects=True,
        )
        if not resp.ok:
            continue
        body = str(resp.text or resp.body_snippet or "")
        if not body:
            continue
        if _NEXT_RSC_MARKER_CASE_H_RE.search(body):
            saw_h = True
        if _NEXT_RSC_MARKER_CASE_F_RE.search(body):
            saw_f = True
        if saw_h and saw_f:
            break

    if saw_h and not saw_f:
        return "h"
    if saw_f and not saw_h:
        return "F"
    return None


def discover_nextjs_action_id(
    url: str,
) -> str | None:
    """
    Best-effort extraction of a valid Next.js Server Action ID from the rendered HTML.

    Next.js Server Actions require a valid `Next-Action` header. Some targets embed an action ID in
    server-rendered form payloads (hidden `$ACTION_*` inputs), which we can scrape via a bounded GET.
    """
    result = _scan_once(
        url,
        method="GET",
        headers={"Accept": "text/html, */*"},
    )
    body = str(result.text or result.body_snippet or "")
    return _extract_nextjs_action_id_from_html(body)


def discover_nextjs_action_entrypoint(
    url: str,
    *,
    max_pages: int | None = None,
    max_depth: int | None = None,
) -> tuple[str, str] | None:
    """
    Discover a (page_url, action_id) pair for Next.js Server Actions.

    Attempts to find a (page_url, action_id) pair via a bounded, same-origin, GET-only crawl.

    Note: This uses a bounded, same-origin, GET-only crawl to discover action forms that may live on
    a non-root route (e.g., `/dashboard`). If action forms are not reachable within the crawl budget,
    this may return None.
    """
    if not url:
        return None

    effective_max_pages = 6 if max_pages is None else max_pages
    effective_max_depth = 2 if max_depth is None else max_depth
    pages = crawl_same_origin_html(url, max_pages=effective_max_pages, max_depth=effective_max_depth, follow_links=True)

    origin_url = pages[0].url if pages else url
    asset_referrers = _collect_js_asset_referrers(pages, url, max_assets=20)

    for page in pages:
        body = page.body or ""
        if not body:
            continue

        # Prefer server-rendered `$ACTION_*` hidden inputs and explicit `Next-Action` header assignment IDs.
        # Fall back to scanning raw 42-hex tokens only after higher-confidence sources fail validation.
        candidates: list[str] = []
        action_id = _extract_nextjs_action_id_from_html(body)
        if action_id:
            candidates.append(action_id)
        candidates.extend(_extract_next_action_header_ids(body))
        candidates.extend(_extract_next_action_hex_tokens(body))
        # De-dupe while preserving order and keep this bounded.
        candidates = list(dict.fromkeys([c for c in candidates if c]))[:8]
        fallback_urls = [url]
        page_url = page.url or url
        for candidate in candidates:
            if _validate_nextjs_action_id(page_url, candidate, fallback_urls=fallback_urls):
                return page.url, candidate

    for asset_url in list(asset_referrers)[:20]:
        resp = _scan_once(
            asset_url,
            method="GET",
            headers={"Accept": "application/javascript, text/javascript, */*"},
            allow_redirects=True,
        )
        if not resp.ok:
            continue
        body = str(resp.text or resp.body_snippet or "")
        if not body:
            continue
        candidates = [*_extract_next_action_header_ids(body), *_extract_next_action_hex_tokens(body)]
        candidates = list(dict.fromkeys([c for c in candidates if c]))[:8]
        page_url = asset_referrers.get(asset_url) or origin_url
        for candidate in candidates:
            if _validate_nextjs_action_id(page_url, candidate, fallback_urls=[url]):
                return page_url, candidate

    return None


__all__ = [
    "discover_nextjs_action_id",
    "discover_next_action_ids",
    "discover_nextjs_action_entrypoint",
    "discover_nextjs_server_reference_marker",
]
