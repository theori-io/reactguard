"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Prototype traversal probe for CVE-2025-55182."""

import secrets
from typing import Any

from ...config import load_http_settings
from ...framework_detection.signals.server_actions import probe_server_actions_support
from ...utils.actions import generate_action_id
from ...utils.context import scan_context
from ..http import request_with_retries


def _user_agent() -> str:
    return load_http_settings().user_agent


def _build_multipart_payload(action_id: str, target_prop: str) -> tuple[dict[str, str], str]:
    """Construct multipart body/headers for proto/control probes."""
    boundary_token = secrets.token_hex(8)
    boundary = f"----FormBoundary{boundary_token}"
    chunk1 = '{"x":{}}'
    args = f'["$F1:x:{target_prop}"]'

    body = (
        f"--{boundary}\r\n"
        f'Content-Disposition: form-data; name="1"\r\n\r\n{chunk1}\r\n'
        f"--{boundary}\r\n"
        f'Content-Disposition: form-data; name="0"\r\n\r\n{args}\r\n'
        f"--{boundary}--\r\n"
    )

    headers = {
        "Content-Type": f"multipart/form-data; boundary={boundary}",
        "Next-Action": action_id,
        "Accept": "text/x-component",
        "User-Agent": _user_agent(),
    }
    return headers, body


def _send_multipart_probe_ctx(
    url: str,
    action_id: str,
    target_prop: str,
) -> dict[str, Any]:
    headers, body = _build_multipart_payload(action_id, target_prop)

    scan = request_with_retries(
        url,
        method="POST",
        headers=headers,
        body=body,
    )

    if scan.get("ok") is False:
        if scan.get("error_message") and scan.get("error") is None:
            scan["error"] = scan.get("error_message")
    return scan


def _send_multipart_probe(
    url: str,
    action_id: str,
    target_prop: str,
    *,
    http_client=None,
) -> dict[str, Any]:
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_multipart_probe_ctx(url, action_id, target_prop)
    return _send_multipart_probe_ctx(url, action_id, target_prop)


def send_proto_probe(
    url: str,
    action_id: str = "proto_probe",
    http_client=None,
) -> dict[str, Any]:
    return _send_multipart_probe(
        url,
        action_id,
        "__proto__",
        http_client=http_client,
    )


def _check_server_actions_ctx(url: str, action_id: str) -> dict[str, Any]:
    result = probe_server_actions_support(
        url,
        action_id=action_id,
        payload_style="multipart",
    )

    if not result.get("ok") and not result.get("supported"):
        return {
            "supported": False,
            "reason": result.get("error_message"),
            "error_type": result.get("error_type"),
        }

    return {
        "supported": bool(result.get("supported")),
        "status_code": result.get("status_code"),
        "content_type": result.get("content_type"),
        "has_action_keywords": result.get("has_action_keywords"),
        "has_flight_marker": result.get("has_flight_marker"),
    }


def check_server_actions(
    url: str,
    action_id: str | None = None,
    http_client=None,
) -> dict[str, Any]:
    if action_id is None:
        action_id = generate_action_id()

    if http_client is not None:
        with scan_context(http_client=http_client):
            return _check_server_actions_ctx(url, action_id)
    return _check_server_actions_ctx(url, action_id)


def send_control_probe(
    url: str,
    action_id: str = "control_probe",
    http_client=None,
) -> dict[str, Any]:
    rand_prop = "z" + secrets.token_hex(4)
    return _send_multipart_probe(
        url,
        action_id,
        rand_prop,
        http_client=http_client,
    )
