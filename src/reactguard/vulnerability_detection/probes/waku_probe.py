"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Waku RSC probe for CVE-2025-55182."""

import secrets
from typing import Any

from ...config import load_http_settings
from ...utils.context import scan_context
from ..http import request_with_retries


def _user_agent() -> str:
    return load_http_settings().user_agent


_FORCE_FAIL_TRAILER = ("reactguard_missing", "probe")


def _send_waku_probe_ctx(
    endpoint: str,
    *,
    target_prop: str = "__proto__",
    force_fail: bool = False,
) -> dict[str, Any]:
    boundary = f"----FormBoundary{secrets.token_hex(8)}"
    chunk1 = '{"x":{}}'
    ref = f"$1:x:{target_prop}"
    if force_fail:
        # Ensure the decode surface throws before the action/function is invoked (avoids side effects).
        # We intentionally add a trailing property access that will not exist on decoded values.
        trailer = ":".join(_FORCE_FAIL_TRAILER)
        ref = f"{ref}:{trailer}"
    args = f'["{ref}"]'

    body = (
        f"--{boundary}\r\n"
        f'Content-Disposition: form-data; name="1"\r\n\r\n{chunk1}\r\n'
        f"--{boundary}\r\n"
        f'Content-Disposition: form-data; name="0"\r\n\r\n{args}\r\n'
        f"--{boundary}--\r\n"
    )

    headers = {
        "Content-Type": f"multipart/form-data; boundary={boundary}",
        "Accept": "text/x-component",
        "User-Agent": _user_agent(),
    }

    scan = request_with_retries(
        endpoint,
        method="POST",
        headers=headers,
        body=body,
    )

    if scan.get("ok") is False:
        if scan.get("error_message") and scan.get("error") is None:
            scan["error"] = scan.get("error_message")
    return scan


def send_waku_probe(
    endpoint: str,
    http_client=None,
    target_prop: str = "__proto__",
    force_fail: bool = False,
) -> dict[str, Any]:
    if http_client is not None:
        with scan_context(http_client=http_client):
            return _send_waku_probe_ctx(endpoint, target_prop=target_prop, force_fail=force_fail)
    return _send_waku_probe_ctx(endpoint, target_prop=target_prop, force_fail=force_fail)
