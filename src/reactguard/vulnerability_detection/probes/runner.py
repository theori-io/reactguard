from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Shared orchestration helpers for running multi-action probes."""

import logging
from collections.abc import Callable, Iterable
from dataclasses import dataclass
from typing import Any

from ...utils.context import scan_context

ProbeFunc = Callable[..., dict[str, Any]]

logger = logging.getLogger(__name__)


@dataclass
class ActionProbeRunner:
    """Stateful runner for a series of action probes plus one control probe."""

    base_url: str
    action_probe: ProbeFunc
    control_probe: ProbeFunc
    control_action_id: str = "control_probe"
    probe_kwargs: dict[str, Any] | None = None
    control_kwargs: dict[str, Any] | None = None
    action_urls: list[str] | None = None
    control_url: str | None = None
    http_client: Any = None

    def run(self, action_ids: Iterable[str], *, control_action_id: str | None = None) -> tuple[list[dict[str, Any]], dict[str, Any]]:
        def _run_inner() -> tuple[list[dict[str, Any]], dict[str, Any]]:
            results: list[dict[str, Any]] = []
            extra_probe_kwargs = dict(self.probe_kwargs or {})
            extra_control_kwargs = dict(self.control_kwargs or {})
            if self.http_client is not None:
                extra_probe_kwargs.setdefault("http_client", self.http_client)
                extra_control_kwargs.setdefault("http_client", self.http_client)
            action_targets = list(self.action_urls or [])
            effective_control_action_id = control_action_id or self.control_action_id

            for index, action_id in enumerate(action_ids):
                target_url = action_targets[index] if index < len(action_targets) else self.base_url
                try:
                    probe_call_kwargs = {**extra_probe_kwargs, "action_id": action_id}
                    result = self.action_probe(target_url, **probe_call_kwargs)
                except Exception as exc:  # noqa: BLE001
                    if isinstance(exc, (KeyboardInterrupt, SystemExit)):
                        raise
                    logger.debug("Action probe failed for %s (action_id=%s): %s", target_url, action_id, exc, exc_info=True)
                    result = {"ok": False, "error": str(exc)}

                if result.get("action_id") is None:
                    result["action_id"] = action_id
                results.append(result)

            control_target = self.control_url or (action_targets[0] if action_targets else self.base_url)

            try:
                control_call_kwargs = {**extra_control_kwargs, "action_id": effective_control_action_id}
                control_result = self.control_probe(control_target, **control_call_kwargs)
            except Exception as exc:  # noqa: BLE001
                if isinstance(exc, (KeyboardInterrupt, SystemExit)):
                    raise
                logger.debug("Control probe failed for %s: %s", control_target, exc, exc_info=True)
                control_result = {"ok": False, "error": str(exc)}

            if control_result.get("action_id") is None:
                control_result["action_id"] = effective_control_action_id

            return results, control_result

        if self.http_client is not None:
            with scan_context(http_client=self.http_client):
                return _run_inner()
        return _run_inner()


def run_action_probes(
    base_url: str,
    action_ids: Iterable[str],
    *,
    action_probe: ProbeFunc,
    control_probe: ProbeFunc,
    control_action_id: str = "control_probe",
    probe_kwargs: dict[str, Any] | None = None,
    control_kwargs: dict[str, Any] | None = None,
    action_urls: Iterable[str] | None = None,
    control_url: str | None = None,
    http_client: Any = None,
) -> tuple[list[dict[str, Any]], dict[str, Any]]:
    runner = ActionProbeRunner(
        base_url=base_url,
        action_probe=action_probe,
        control_probe=control_probe,
        control_action_id=control_action_id,
        probe_kwargs=probe_kwargs,
        control_kwargs=control_kwargs,
        action_urls=list(action_urls) if action_urls is not None else None,
        control_url=control_url,
        http_client=http_client,
    )
    return runner.run(action_ids)


__all__ = ["ActionProbeRunner", "run_action_probes"]
