from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Bundle-scanning helpers for high-signal RSC patch fingerprinting (GET-only, same-origin)."""

import re
from typing import Any
from urllib.parse import urlparse

from ...config import load_http_settings
from ...http.crawl import crawl_same_origin_html
from ...http.models import HttpRequest, RetryConfig
from ...http.retry import send_with_retries
from ...http.url import build_endpoint_candidates
from ...http.utils import get_http_client
from ...utils.context import get_scan_context, scan_context

_SCRIPT_SRC_RE = re.compile(r"<script[^>]+src=[\"']([^\"']+)[\"']", re.IGNORECASE)
_LINK_HREF_RE = re.compile(r"<link[^>]+href=[\"']([^\"']+)[\"']", re.IGNORECASE)

# React DOM bundles often embed a devtools injection snippet:
#   inject({ ..., version:"19.2.3", rendererPackageName:"react-dom", ... })
_REACT_DOM_DEVTOOLS_VERSION_RE = re.compile(
    r'version\s*:\s*["\'](?P<ver>\d+\.\d+\.\d+(?:-[0-9A-Za-z.-]+)?)["\']\s*,\s*rendererPackageName\s*:\s*["\']react-dom["\']',
    re.IGNORECASE,
)
_RENDERER_PACKAGE_REACT_DOM_RE = re.compile(r'rendererPackageName\s*:\s*["\']react-dom["\']', re.IGNORECASE)
_GENERIC_VERSION_STRING_RE = re.compile(r'\b(?P<ver>\d+\.\d+\.\d+(?:-[0-9A-Za-z.-]+)?)\b')

# Server reference marker changed in PR#35345: "$F" -> "$h"
_SERVER_REFERENCE_MARKER_H_RE = re.compile(r'["\']\$(?:h)["\']', re.IGNORECASE)
_SERVER_REFERENCE_MARKER_F_RE = re.compile(r'["\']\$(?:F)["\']')
_SERVER_REFERENCE_MARKER_H_ID_RE = re.compile(r"\$h[0-9a-f]", re.IGNORECASE)
_SERVER_REFERENCE_MARKER_F_ID_RE = re.compile(r"\$F[0-9a-f]")

# PR#35351 adds a "cycleProtection" guard.
_CYCLE_PROTECTION_RE = re.compile(r"\bcycleProtection\b")
_CYCLE_THENABLES_RE = re.compile(r"Cannot have cyclic thenables", re.IGNORECASE)
_REACT_ERROR_569_RE = re.compile(r"react\.dev/errors/569|minified react error #569", re.IGNORECASE)


def _same_origin(a: str, b: str) -> bool:
    pa = urlparse(a)
    pb = urlparse(b)
    return (pa.scheme, pa.netloc) == (pb.scheme, pb.netloc)


def _looks_like_js_asset(path: str) -> bool:
    if not path:
        return False
    candidate = str(path).split("?", 1)[0].split("#", 1)[0].lower()
    return candidate.endswith((".js", ".mjs"))


def _scan_once(
    url: str,
    *,
    headers: dict[str, str] | None,
    timeout: float | None,
    http_client=None,
) -> dict[str, Any]:
    settings = load_http_settings()
    context = get_scan_context()
    client = http_client or context.http_client or get_http_client()
    effective_timeout = timeout if timeout is not None else (context.timeout if context.timeout is not None else settings.timeout)

    request_headers = dict(headers or {})
    request_headers.setdefault("User-Agent", settings.user_agent)

    request = HttpRequest(
        url=url,
        method="GET",
        headers=request_headers,
        timeout=effective_timeout,
        allow_redirects=True,
    )
    response = send_with_retries(client, request, retry_config=RetryConfig(max_attempts=1))

    return {
        "ok": response.ok,
        "status_code": response.status_code,
        "headers": response.headers,
        "body": response.text,
        "body_snippet": response.body_snippet,
        "url": response.url or url,
        "error_category": response.error_category,
        "error_message": response.error_message,
        "error_type": response.error_type,
    }


def _extract_react_dom_versions(text: str) -> list[str]:
    if not text:
        return []

    versions: list[str] = []
    for match in _REACT_DOM_DEVTOOLS_VERSION_RE.finditer(text):
        versions.append(match.group("ver"))

    # Fallback: if this bundle contains react-dom devtools metadata, accept any nearby semver-ish token
    # as a version candidate (React bundles always include `t.version="..."` but the variable name is minified).
    if not versions and _RENDERER_PACKAGE_REACT_DOM_RE.search(text):
        # Collect a handful to keep output bounded.
        for match in _GENERIC_VERSION_STRING_RE.finditer(text):
            versions.append(match.group("ver"))
            if len(versions) >= 8:
                break

    # De-dupe while preserving order.
    return list(dict.fromkeys([v for v in versions if v]))


def _extract_marker_flags(text: str) -> dict[str, bool]:
    if not text:
        return {"has_marker_h": False, "has_marker_f": False}

    has_h = bool(_SERVER_REFERENCE_MARKER_H_RE.search(text) or _SERVER_REFERENCE_MARKER_H_ID_RE.search(text))
    has_f = bool(_SERVER_REFERENCE_MARKER_F_RE.search(text) or _SERVER_REFERENCE_MARKER_F_ID_RE.search(text))
    return {"has_marker_h": has_h, "has_marker_f": has_f}


def _extract_cycle_protection_flags(text: str) -> dict[str, bool]:
    if not text:
        return {"has_cycle_protection": False, "has_cycle_thenables_error": False}
    return {
        "has_cycle_protection": bool(_CYCLE_PROTECTION_RE.search(text)),
        "has_cycle_thenables_error": bool(_CYCLE_THENABLES_RE.search(text) or _REACT_ERROR_569_RE.search(text)),
    }


def probe_rsc_bundle_fingerprint(
    url: str,
    *,
    timeout: float | None = 5.0,
    http_client=None,
    max_pages: int = 4,
    max_depth: int = 1,
    max_assets: int = 16,
    max_asset_bytes: int = 600_000,
) -> dict[str, Any]:
    """
    Crawl same-origin HTML and scan JS bundles for stable fingerprint signals.

    Safety properties:
    - GET-only requests
    - same-origin only
    - bounded by max_pages/max_depth/max_assets
    - uses `Range` to cap asset downloads when supported
    """
    if not url:
        return {"reason": "missing_url"}

    if http_client is not None:
        with scan_context(http_client=http_client):
            return probe_rsc_bundle_fingerprint(
                url,
                timeout=timeout,
                http_client=None,
                max_pages=max_pages,
                max_depth=max_depth,
                max_assets=max_assets,
                max_asset_bytes=max_asset_bytes,
            )

    pages = crawl_same_origin_html(url, max_pages=max_pages, max_depth=max_depth, timeout=timeout, http_client=http_client)

    asset_urls: list[str] = []
    react_dom_versions: list[str] = []
    marker = {"has_marker_h": False, "has_marker_f": False}
    cycle = {"has_cycle_protection": False, "has_cycle_thenables_error": False}
    evidence_assets: list[dict[str, Any]] = []

    for page in pages:
        body = page.body or ""
        if not body:
            continue

        marker_update = _extract_marker_flags(body)
        marker["has_marker_h"] = marker["has_marker_h"] or marker_update["has_marker_h"]
        marker["has_marker_f"] = marker["has_marker_f"] or marker_update["has_marker_f"]

        cycle_update = _extract_cycle_protection_flags(body)
        cycle["has_cycle_protection"] = cycle["has_cycle_protection"] or cycle_update["has_cycle_protection"]
        cycle["has_cycle_thenables_error"] = cycle["has_cycle_thenables_error"] or cycle_update["has_cycle_thenables_error"]

        react_dom_versions.extend(_extract_react_dom_versions(body))

        for regex in (_SCRIPT_SRC_RE, _LINK_HREF_RE):
            for match in regex.finditer(body):
                raw = (match.group(1) or "").strip()
                if not raw:
                    continue
                if raw.startswith(("data:", "javascript:", "mailto:", "tel:")):
                    continue
                if raw.startswith(("http://", "https://")):
                    if not _same_origin(url, raw):
                        continue
                    candidates = [raw]
                else:
                    candidates = build_endpoint_candidates(page.url or url, raw)
                for candidate in candidates:
                    if not candidate or not _same_origin(url, candidate):
                        continue
                    if _looks_like_js_asset(candidate):
                        asset_urls.append(candidate)

    asset_urls = list(dict.fromkeys([u for u in asset_urls if u]))[:max_assets]

    range_header = f"bytes=0-{max(0, max_asset_bytes - 1)}"
    for asset_url in asset_urls:
        resp = _scan_once(
            asset_url,
            headers={"Accept": "application/javascript, text/javascript, */*", "Range": range_header},
            timeout=timeout,
            http_client=http_client,
        )
        if not resp.get("ok"):
            continue
        body = str(resp.get("body") or resp.get("body_snippet") or "")
        if not body:
            continue

        asset_versions = _extract_react_dom_versions(body)
        if asset_versions:
            react_dom_versions.extend(asset_versions)

        marker_update = _extract_marker_flags(body)
        cycle_update = _extract_cycle_protection_flags(body)

        marker["has_marker_h"] = marker["has_marker_h"] or marker_update["has_marker_h"]
        marker["has_marker_f"] = marker["has_marker_f"] or marker_update["has_marker_f"]
        cycle["has_cycle_protection"] = cycle["has_cycle_protection"] or cycle_update["has_cycle_protection"]
        cycle["has_cycle_thenables_error"] = cycle["has_cycle_thenables_error"] or cycle_update["has_cycle_thenables_error"]

        if asset_versions or any(marker_update.values()) or any(cycle_update.values()):
            evidence_assets.append(
                {
                    "url": resp.get("url") or asset_url,
                    "status_code": resp.get("status_code"),
                    "react_dom_versions": asset_versions,
                    **marker_update,
                    **cycle_update,
                }
            )

    # De-dupe while preserving order.
    react_dom_versions = list(dict.fromkeys([v for v in react_dom_versions if v]))

    return {
        "ok": True,
        "react_dom_versions": react_dom_versions,
        **marker,
        **cycle,
        "assets_scanned": asset_urls,
        "evidence_assets": evidence_assets,
    }


__all__ = ["probe_rsc_bundle_fingerprint"]

