from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Safe RSC patch-fingerprint probe payloads for the Dec 2025 CVE family."""

import json

from ...rsc.payloads import (
    NO_INVOKE_TEMP_REF_STRATEGY,
    NO_INVOKE_TEMP_REF_TOKEN,
    SAFE_ARGS_LENGTH_TOKEN,
    SAFE_ARGS_STRATEGY,
    build_multipart_form_payload,
    build_no_invoke_args_container,
)
from ...rsc.send import send_rsc_request
from ...rsc.types import RscHttpResult, RscRequestConfig


def _json_dumps(value: object) -> str:
    return json.dumps(value, separators=(",", ":"))


def send_dec2025_payload(
    url: str,
    *,
    request_config: RscRequestConfig,
    payload_parts: list[tuple[str, str]],
    prefix_parts: list[tuple[str, str]] | None = None,
    action_id: str | None,
    meta: dict[str, object],
) -> RscHttpResult:
    parts = list(prefix_parts or [])
    parts.extend(payload_parts)
    payload = build_multipart_form_payload(parts, meta=dict(meta))
    return send_rsc_request(url, request_config, payload, action_id=action_id)


def send_dec2025_safe_control_probe(
    url: str,
    *,
    request_config: RscRequestConfig,
    action_id: str | None,
    prefix_parts: list[tuple[str, str]] | None = None,
) -> RscHttpResult:
    return send_dec2025_payload(
        url,
        request_config=request_config,
        payload_parts=[("0", _json_dumps([NO_INVOKE_TEMP_REF_TOKEN]))],
        prefix_parts=prefix_parts,
        action_id=action_id,
        meta={"probe_kind": "dec2025_control_safe", "probe_strategy": NO_INVOKE_TEMP_REF_STRATEGY},
    )


def send_dec2025_missing_chunk_probe(
    url: str,
    *,
    request_config: RscRequestConfig,
    action_id: str | None,
    missing_chunk_id_hex: str = "ffff",
    prefix_parts: list[tuple[str, str]] | None = None,
) -> RscHttpResult:
    missing = (missing_chunk_id_hex or "").lower().strip()
    if not missing or any(ch not in "0123456789abcdef" for ch in missing):
        raise ValueError("missing_chunk_id_hex must be a hex string")
    return send_dec2025_payload(
        url,
        request_config=request_config,
        payload_parts=[("0", f'"$@{missing}"')],
        prefix_parts=prefix_parts,
        action_id=action_id,
        meta={"probe_kind": "dec2025_missing_chunk", "missing_chunk": missing, "probe_strategy": "missing_chunk_root_thenable"},
    )


def send_dec2025_server_reference_marker_root_probe(
    url: str,
    *,
    request_config: RscRequestConfig,
    action_id: str | None,
    server_ref_marker: str,
    prefix_parts: list[tuple[str, str]] | None = None,
) -> RscHttpResult:
    if server_ref_marker not in {"F", "h"}:
        raise ValueError("server_ref_marker must be 'F' or 'h'")
    return send_dec2025_payload(
        url,
        request_config=request_config,
        payload_parts=[
            ("1", _json_dumps({"id": None})),
            ("0", _json_dumps({"x": f"${server_ref_marker}1"})),
        ],
        prefix_parts=prefix_parts,
        action_id=action_id,
        meta={"probe_kind": "dec2025_marker_root", "server_ref_marker": server_ref_marker, "probe_strategy": "marker_root_decode_error"},
    )


def send_dec2025_nextjs_promise_chain_root_probe(
    url: str,
    *,
    request_config: RscRequestConfig,
    action_id: str,
    chain_depth: int,
    start_promise_id: int = 10,
    missing_chunk_id_hex: str = "ffff",
    prefix_parts: list[tuple[str, str]] | None = None,
) -> RscHttpResult:
    """
    Next.js-friendly PR#35351 fingerprint probe that forces the decoded root value to be a thenable chain.

    The chain resolves to a missing-chunk thenable so decode always terminates in a deterministic error
    before any Server Action invocation ("no-invoke").
    """
    if not action_id:
        raise ValueError("action_id is required for Next.js Server Action probes")
    if chain_depth < 1:
        raise ValueError("chain_depth must be >= 1")

    missing = (missing_chunk_id_hex or "").lower().strip()
    if not missing or any(ch not in "0123456789abcdef" for ch in missing):
        raise ValueError("missing_chunk_id_hex must be a hex string")

    promise_count = chain_depth + 1
    promise_ids = [start_promise_id + idx for idx in range(promise_count)]
    first_promise_id = promise_ids[0]
    last_promise_id = promise_ids[-1]
    wrapper_chunk_id = last_promise_id + 1

    parts: list[tuple[str, str]] = []

    # Terminal: missing chunk thenable (ensures decode fails before any server action execution).
    parts.append((str(last_promise_id), f'"$@{missing}"'))
    for index in range(len(promise_ids) - 2, -1, -1):
        promise_id = promise_ids[index]
        next_id = promise_ids[index + 1]
        parts.append((str(promise_id), f'"$@{next_id:x}"'))

    # Wrapper: element 0 is the root thenable; later elements are outlined model references that force
    # the server to initialize/fulfill each promise chunk before evaluating element 0.
    wrapper_items: list[str] = [f"$@{first_promise_id:x}"]
    wrapper_items.extend([f"${pid:x}" for pid in promise_ids])
    parts.append((str(wrapper_chunk_id), _json_dumps(wrapper_items)))

    # Root: outlined reference to wrapper element 0 (the now-fulfilled ReactPromise chain root).
    parts.append(("0", f'"${wrapper_chunk_id:x}:0"'))

    return send_dec2025_payload(
        url,
        request_config=request_config,
        payload_parts=parts,
        prefix_parts=prefix_parts,
        action_id=action_id,
        meta={
            "probe_kind": "dec2025_chain_root",
            "chain_depth": chain_depth,
            "missing_chunk": missing,
            "probe_strategy": "missing_chunk_chain_terminal",
        },
    )


def send_dec2025_promise_chain_probe(
    url: str,
    *,
    request_config: RscRequestConfig,
    action_id: str | None,
    chain_depth: int,
    prefix_parts: list[tuple[str, str]] | None = None,
) -> RscHttpResult:
    """
    Generic PR#35351 finite thenable-chain probe.

    Builds a finite ReactPromise chain and returns `$@1` via an outlined reference. This exercises
    the PR#35351 cycleProtection traversal without constructing true cycles (DoS-safe).
    """
    if chain_depth < 1:
        raise ValueError("chain_depth must be >= 1")

    promise_count = chain_depth + 1
    init_chunk_id = promise_count + 1
    root_object_id = promise_count + 2

    parts: list[tuple[str, str]] = []

    # Terminal: argsArray-like object with a BigInt length (ensures no server action execution).
    terminal = build_no_invoke_args_container([], length_token=SAFE_ARGS_LENGTH_TOKEN)
    parts.append((str(promise_count), _json_dumps(terminal)))
    for promise_id in range(promise_count - 1, 0, -1):
        next_hex = f"{(promise_id + 1):x}"
        parts.append((str(promise_id), f'"$@{next_hex}"'))

    init_list = [f"${pid:x}" for pid in range(promise_count, 0, -1)]
    parts.append((str(init_chunk_id), _json_dumps(init_list)))
    parts.append((str(root_object_id), f'{{"a":"$@1","b":"${init_chunk_id:x}"}}'))
    parts.append(("0", f'"${root_object_id:x}:a"'))

    return send_dec2025_payload(
        url,
        request_config=request_config,
        payload_parts=parts,
        prefix_parts=prefix_parts,
        action_id=action_id,
        meta={"probe_kind": "dec2025_chain", "chain_depth": chain_depth, "probe_strategy": SAFE_ARGS_STRATEGY},
    )


__all__ = [
    "send_dec2025_missing_chunk_probe",
    "send_dec2025_nextjs_promise_chain_root_probe",
    "send_dec2025_payload",
    "send_dec2025_promise_chain_probe",
    "send_dec2025_safe_control_probe",
    "send_dec2025_server_reference_marker_root_probe",
]
