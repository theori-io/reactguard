# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Shared attack-surface detection for React Server Components (RSC) and Flight protocol payload deserialization."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Literal

from ..framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_INVOCATION_ENDPOINTS,
    SIG_REACT_BUNDLE_ONLY,
    SIG_RSC_CONTENT_TYPE,
    SIG_RSC_DEPENDENCY_ONLY,
    SIG_RSC_ENDPOINT_FOUND,
    SIG_RSC_FLIGHT_PAYLOAD,
    TAG_EXPO_RSC,
    TAG_EXPO_SERVER_ACTIONS,
    TAG_NEXTJS_APP_ROUTER,
    TAG_NEXTJS_PAGES_ROUTER,
    TAG_REACT_ROUTER_V6_RSC,
    TAG_REACT_ROUTER_V7_RSC,
    TAG_REACT_ROUTER_V7_SERVER_ACTIONS,
    TAG_WAKU,
)
from ..models.poc import PocStatus
from ..models.report import VulnerabilityReport
from ..utils.confidence import confidence_at_least
from .journal import PocJournal
from .snapshots import DetectContext, DetectionSnapshot

SurfaceConfidence = Literal["none", "low", "medium", "high"]
TriState = bool | None

MISSING_SURFACE_REASON_CODE = "missing_rsc_server_functions_surface"
ENTRYPOINT_NOT_FOUND_REASON_CODE = "server_functions_entrypoint_not_found"
ENTRYPOINT_EXPECTED_NOT_FOUND_REASON_CODE = "server_functions_entrypoint_expected_but_not_found"


@dataclass(frozen=True)
class RscServerFunctionsSurface:
    """
    Normalized view of the relevant attack surface for the React Server Components (RSC) / Flight protocol CVE family.

    CVE-2025-55182 (React2Shell) is described in public writeups as an insecure deserialization issue
    in the RSC "Flight" protocol payload handling logic. Frameworks may expose that request surface
    via branded features like "Server Actions" (Next.js) or "Server Functions" (e.g., Expo/React Router).
    React's advisory notes that apps may be affected even if they do not define any explicit "server function"
    endpoints, as frameworks can provide default/internal endpoints when RSC is supported.

    Field intent:
    - rsc_surface: evidence the target serves RSC Flight (e.g., `text/x-component` / Flight rows).
    - invocation_surface: evidence of a framework feature for remotely calling server logic
      (often branded as "Server Actions") that implies a reachable Flight protocol payload deserialization surface.
    - server_functions_surface: derived "in-scope" surface for these CVEs; may be True even when
      `invocation_surface` is unknown (active probes determine reachability).

    Tri-state values:
    - True: detected
    - False: confidently absent (tested closed)
    - None: unknown / not enough evidence / untestable
    """

    rsc_surface: TriState
    invocation_surface: TriState
    server_functions_surface: TriState
    confidence: SurfaceConfidence
    entrypoint_required: bool = False
    entrypoint_expected: TriState = None
    entrypoint_available: TriState = None
    invocation_endpoints: list[str] = field(default_factory=list)
    evidence: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        return {
            "rsc_surface": self.rsc_surface,
            "invocation_surface": self.invocation_surface,
            "server_functions_surface": self.server_functions_surface,
            "confidence": self.confidence,
            "entrypoint_required": self.entrypoint_required,
            "entrypoint_expected": self.entrypoint_expected,
            "entrypoint_available": self.entrypoint_available,
            "invocation_endpoints": list(self.invocation_endpoints),
            "evidence": dict(self.evidence),
        }


def compute_rsc_server_functions_surface(snapshot: DetectionSnapshot) -> RscServerFunctionsSurface:
    """
    Compute whether the target exposes an attack surface that routes into RSC Flight protocol payload deserialization.

    This is shared between CVE-2025-55182 and the Dec-2025 CVEs to keep "missing surface" decisions consistent.
    """

    tags = list(snapshot.tags or [])
    signals = snapshot.signals or {}
    tag_set = set(tags)

    invocation_endpoints = list(snapshot.invocation_endpoints or [])
    if not invocation_endpoints:
        endpoints_from_signal = signals.get(SIG_INVOCATION_ENDPOINTS)
        if isinstance(endpoints_from_signal, list):
            invocation_endpoints = [str(ep) for ep in endpoints_from_signal if ep]

    invocation_surface: TriState = snapshot.invocation_enabled
    invocation_confidence = snapshot.invocation_confidence

    if invocation_surface is None:
        if TAG_EXPO_SERVER_ACTIONS in tag_set or TAG_REACT_ROUTER_V7_SERVER_ACTIONS in tag_set:
            invocation_surface = True
            if not invocation_confidence:
                invocation_confidence = "medium"
    detection_confidence_level = signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)
    framework_confident = confidence_at_least(detection_confidence_level, "medium")

    # Evidence that the target processes RSC Flight / exposes an RSC surface.
    # Note: we intentionally do *not* treat generic React streaming SSR markers as RSC evidence.
    has_rsc_evidence = bool(
        signals.get(SIG_RSC_ENDPOINT_FOUND)
        or signals.get(SIG_RSC_CONTENT_TYPE)
        or signals.get(SIG_RSC_FLIGHT_PAYLOAD)
        or TAG_NEXTJS_APP_ROUTER in tag_set
        or TAG_REACT_ROUTER_V7_RSC in tag_set
        or TAG_REACT_ROUTER_V6_RSC in tag_set
        or TAG_EXPO_RSC in tag_set
    )

    # "Dependency only" means we found RSC runtime usage in bundles but did not observe an RSC entrypoint.
    rsc_dependency_only = bool(signals.get(SIG_RSC_DEPENDENCY_ONLY)) and not has_rsc_evidence and invocation_surface is not True
    react_bundle_only = bool(signals.get(SIG_REACT_BUNDLE_ONLY)) and not has_rsc_evidence and invocation_surface is not True

    if has_rsc_evidence:
        rsc_surface: TriState = True
    else:
        rsc_surface = None

    # Some targets are known to be out of scope for this CVE family.
    is_next_pages_only = TAG_NEXTJS_PAGES_ROUTER in tag_set and TAG_NEXTJS_APP_ROUTER not in tag_set

    # Waku requires a concrete endpoint path (base_url is not a Server Function endpoint).
    entrypoint_required = TAG_WAKU in tag_set
    entrypoint_expected: TriState = None
    if entrypoint_required:
        if invocation_surface is True or invocation_endpoints:
            entrypoint_expected = True
        elif invocation_surface is False and confidence_at_least(invocation_confidence, "high"):
            entrypoint_expected = False

        if invocation_endpoints:
            entrypoint_available: TriState = True
        else:
            # Waku action endpoints may not be discoverable from the landing page (or at all without crawling/auth).
            # Treat this as "unknown" rather than a definitive missing entrypoint.
            entrypoint_available = None
    else:
        entrypoint_available = None

    server_functions_surface: TriState
    confidence: SurfaceConfidence

    # Waku requires a concrete action endpoint path. If we don't have one, we cannot directly
    # test reachability, even if the framework is confidently detected.
    if entrypoint_required and entrypoint_available is not True:
        if invocation_surface is False and confidence_at_least(invocation_confidence, "high") and not has_rsc_evidence:
            server_functions_surface = False
            confidence = "high"
        else:
            server_functions_surface = None
            confidence = "medium" if framework_confident else "low"
    # RSC evidence indicates an RSC-capable stack. This does not guarantee a reachable Flight request
    # deserialization surface, but it is sufficient to treat these CVEs as in-scope and let active probes
    # confirm reachability.
    elif has_rsc_evidence or invocation_surface is True:
        server_functions_surface = True
        confidence = "high" if has_rsc_evidence or confidence_at_least(invocation_confidence, "high") else "medium"
    # Confident negative: actions explicitly absent and no RSC evidence.
    elif is_next_pages_only and framework_confident:
        server_functions_surface = False
        confidence = "high"
    elif invocation_surface is False and confidence_at_least(invocation_confidence, "high") and not has_rsc_evidence:
        server_functions_surface = False
        confidence = "high"
    elif rsc_dependency_only:
        # RSC runtime present in bundles, but we did not observe a concrete Flight protocol payload deserialization endpoint.
        # Treat as "unknown" rather than a confident negative.
        server_functions_surface = None
        confidence = "medium" if framework_confident else "low"
    elif react_bundle_only:
        # React detected but no RSC/server action evidence observed; too weak to call absent.
        server_functions_surface = None
        confidence = "low"
    else:
        server_functions_surface = None
        confidence = "low" if invocation_surface is False else "none"

    evidence: dict[str, Any] = {
        "tags": tags,
        "detection_confidence": signals.get(SIG_DETECTION_CONFIDENCE),
        "detection_confidence_level": signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
        "signals": {
            SIG_RSC_ENDPOINT_FOUND: signals.get(SIG_RSC_ENDPOINT_FOUND),
            SIG_RSC_CONTENT_TYPE: signals.get(SIG_RSC_CONTENT_TYPE),
            SIG_RSC_FLIGHT_PAYLOAD: signals.get(SIG_RSC_FLIGHT_PAYLOAD),
            SIG_RSC_DEPENDENCY_ONLY: signals.get(SIG_RSC_DEPENDENCY_ONLY),
            SIG_REACT_BUNDLE_ONLY: signals.get(SIG_REACT_BUNDLE_ONLY),
            "invocation_enabled": invocation_surface,
            "invocation_confidence": invocation_confidence,
            SIG_INVOCATION_ENDPOINTS: invocation_endpoints,
        },
    }

    return RscServerFunctionsSurface(
        rsc_surface=rsc_surface,
        invocation_surface=invocation_surface,
        server_functions_surface=server_functions_surface,
        confidence=confidence,
        entrypoint_required=entrypoint_required,
        entrypoint_expected=entrypoint_expected,
        entrypoint_available=entrypoint_available,
        invocation_endpoints=invocation_endpoints,
        evidence=evidence,
    )


def surface_from_detect_context(detect_context: DetectContext | None) -> RscServerFunctionsSurface:
    """
    Convenience helper to compute the RSC/Server Functions surface directly from detect_context.
    """
    if detect_context is None:
        empty_snapshot = DetectionSnapshot(
            tags=[],
            signals={},
            detected_versions={},
            react_major=None,
            react_major_confidence=None,
            invocation_enabled=None,
            invocation_confidence=None,
            invocation_endpoints=[],
        )
        return compute_rsc_server_functions_surface(empty_snapshot)
    snapshot = DetectionSnapshot.from_detect_context(detect_context)
    return compute_rsc_server_functions_surface(snapshot)


def build_missing_surface_report(
    *,
    cve_id: str,
    snapshot: DetectionSnapshot,
    surface: RscServerFunctionsSurface,
    status: PocStatus,
    reason: str,
    confidence_override: str | None = None,
    reason_code: str = MISSING_SURFACE_REASON_CODE,
    framework_detected: str | None = None,
    decision_rule: str | None = None,
    journal: PocJournal | None = None,
    raw_data: dict[str, Any] | None = None,
) -> VulnerabilityReport:
    decision_confidence = str(confidence_override or surface.confidence or "none")
    effective_status = status
    if reason_code == MISSING_SURFACE_REASON_CODE and status == PocStatus.NOT_VULNERABLE:
        effective_status = missing_surface_status(decision_confidence)

    attack_surface = surface.to_dict()
    if reason_code == MISSING_SURFACE_REASON_CODE and effective_status == PocStatus.NOT_VULNERABLE:
        # If we are emitting a definitive "missing surface" verdict, normalize the tri-state surface
        # to a concrete negative for downstream consumers. This keeps downstream CVE gating and UI
        # output consistent even when framework detection heuristics suggested an RSC surface.
        attack_surface["server_functions_surface"] = False

    details: dict[str, Any] = {
        "cve_id": cve_id,
        "confidence": decision_confidence,
        "reason": reason,
        "reason_code": reason_code,
        "decision_rule": decision_rule,
        "surface_detected": False,
        "attack_surface": attack_surface,
        "framework_detected": framework_detected,
        "detection_confidence": (snapshot.signals or {}).get(SIG_DETECTION_CONFIDENCE),
        "detection_confidence_level": (snapshot.signals or {}).get(SIG_DETECTION_CONFIDENCE_LEVEL),
        "detection_tags": list(snapshot.tags or []),
    }

    if effective_status == PocStatus.NOT_APPLICABLE:
        # Mapping contract: "not affected" is represented via NOT_APPLICABLE.
        details["not_affected"] = True

    effective_journal = journal
    if effective_journal is None:
        # When upstream passed an already-serialized journal list via raw_data, rehydrate it so
        # we can append a final decision without losing truncation guarantees.
        effective_journal = PocJournal()
        if isinstance(raw_data, dict):
            existing = raw_data.get("journal")
            if isinstance(existing, list) and all(isinstance(entry, dict) for entry in existing):
                effective_journal.entries = list(existing)

    effective_journal.add_event(
        "surface",
        "Computed Flight protocol payload deserialization surface",
        data={
            "server_functions_surface": surface.server_functions_surface,
            "invocation_surface": surface.invocation_surface,
            "rsc_surface": surface.rsc_surface,
            "confidence": surface.confidence,
            "entrypoint_required": surface.entrypoint_required,
            "entrypoint_expected": surface.entrypoint_expected,
            "entrypoint_available": surface.entrypoint_available,
            "invocation_endpoints": len(surface.invocation_endpoints or []),
        },
    )
    effective_journal.add_decision(
        effective_status,
        reason,
        rule=decision_rule or "missing_surface",
        data={"reason_code": reason_code, "cve_id": cve_id},
    )

    merged_raw_data = dict(raw_data or {})
    merged_raw_data["detection"] = dict(snapshot.signals or {})
    merged_raw_data["journal"] = effective_journal.to_list()

    return VulnerabilityReport(status=effective_status, details=details, raw_data=merged_raw_data)


def missing_surface_status(confidence: str | None) -> PocStatus:
    """
    Map missing-surface confidence to an aligned status.

    High confidence => NOT_VULNERABLE
    Medium confidence => LIKELY_NOT_VULNERABLE
    Low/none => INCONCLUSIVE
    """
    if confidence_at_least(confidence, "high"):
        return PocStatus.NOT_VULNERABLE
    if confidence_at_least(confidence, "medium"):
        return PocStatus.LIKELY_NOT_VULNERABLE
    return PocStatus.INCONCLUSIVE


__all__ = [
    "ENTRYPOINT_EXPECTED_NOT_FOUND_REASON_CODE",
    "ENTRYPOINT_NOT_FOUND_REASON_CODE",
    "MISSING_SURFACE_REASON_CODE",
    "RscServerFunctionsSurface",
    "TriState",
    "compute_rsc_server_functions_surface",
    "missing_surface_status",
    "surface_from_detect_context",
    "build_missing_surface_report",
]
