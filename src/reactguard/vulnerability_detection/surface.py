from __future__ import annotations

"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Shared attack-surface detection for React Server Components Server Functions."""

from dataclasses import dataclass, field
from typing import Any, Literal

from ..framework_detection.keys import (
    SIG_DETECTION_CONFIDENCE,
    SIG_DETECTION_CONFIDENCE_LEVEL,
    SIG_REACT_BUNDLE_ONLY,
    SIG_RSC_CONTENT_TYPE,
    SIG_RSC_DEPENDENCY_ONLY,
    SIG_RSC_ENDPOINT_FOUND,
    SIG_RSC_FLIGHT_PAYLOAD,
    SIG_SERVER_ACTION_ENDPOINTS,
    TAG_EXPO_RSC,
    TAG_NEXTJS_APP_ROUTER,
    TAG_NEXTJS_PAGES_ROUTER,
    TAG_REACT_ROUTER_V6_RSC,
    TAG_REACT_ROUTER_V7_RSC,
    TAG_WAKU,
)
from ..models.poc import PocStatus
from ..models.report import VulnerabilityReport
from ..utils.confidence import confidence_at_least
from .snapshots import DetectionSnapshot

SurfaceConfidence = Literal["none", "low", "medium", "high"]
TriState = bool | None

MISSING_SURFACE_REASON_CODE = "missing_rsc_server_functions_surface"
ENTRYPOINT_NOT_FOUND_REASON_CODE = "server_functions_entrypoint_not_found"
ENTRYPOINT_EXPECTED_NOT_FOUND_REASON_CODE = "server_functions_entrypoint_expected_but_not_found"


@dataclass(frozen=True)
class RscServerFunctionsSurface:
    """
    Normalized view of the relevant attack surface for the RSC Server Functions CVE family.

    Tri-state values:
    - True: detected
    - False: confidently absent (tested closed)
    - None: unknown / not enough evidence / untestable
    """

    rsc_surface: TriState
    server_actions_surface: TriState
    server_functions_surface: TriState
    confidence: SurfaceConfidence
    entrypoint_required: bool = False
    entrypoint_expected: TriState = None
    entrypoint_available: TriState = None
    server_action_endpoints: list[str] = field(default_factory=list)
    evidence: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        return {
            "rsc_surface": self.rsc_surface,
            "server_actions_surface": self.server_actions_surface,
            "server_functions_surface": self.server_functions_surface,
            "confidence": self.confidence,
            "entrypoint_required": self.entrypoint_required,
            "entrypoint_expected": self.entrypoint_expected,
            "entrypoint_available": self.entrypoint_available,
            "server_action_endpoints": list(self.server_action_endpoints),
            "evidence": dict(self.evidence),
        }


def compute_rsc_server_functions_surface(snapshot: DetectionSnapshot) -> RscServerFunctionsSurface:
    """
    Compute whether the target exposes an attack surface that routes into React Server Functions decoding.

    This is shared between CVE-2025-55182 and the Dec-2025 CVEs to keep "missing surface" decisions consistent.
    """

    tags = list(snapshot.tags or [])
    signals = snapshot.signals or {}
    tag_set = set(tags)

    server_action_endpoints = list(snapshot.server_action_endpoints or [])
    if not server_action_endpoints:
        endpoints_from_signal = signals.get(SIG_SERVER_ACTION_ENDPOINTS)
        if isinstance(endpoints_from_signal, list):
            server_action_endpoints = [str(ep) for ep in endpoints_from_signal if ep]

    server_actions_surface: TriState = snapshot.server_actions_enabled
    server_actions_confidence = snapshot.server_actions_confidence
    detection_confidence_level = signals.get(SIG_DETECTION_CONFIDENCE_LEVEL)
    framework_confident = confidence_at_least(detection_confidence_level, "medium")

    # Evidence that the target processes RSC Flight / exposes an RSC surface.
    # Note: we intentionally do *not* treat generic React streaming SSR markers as RSC evidence.
    has_rsc_evidence = bool(
        signals.get(SIG_RSC_ENDPOINT_FOUND)
        or signals.get(SIG_RSC_CONTENT_TYPE)
        or signals.get(SIG_RSC_FLIGHT_PAYLOAD)
        or TAG_NEXTJS_APP_ROUTER in tag_set
        or TAG_REACT_ROUTER_V7_RSC in tag_set
        or TAG_REACT_ROUTER_V6_RSC in tag_set
        or TAG_EXPO_RSC in tag_set
    )

    # "Dependency only" means we found RSC runtime usage in bundles but did not observe an RSC entrypoint.
    rsc_dependency_only = bool(signals.get(SIG_RSC_DEPENDENCY_ONLY)) and not has_rsc_evidence and server_actions_surface is not True
    react_bundle_only = bool(signals.get(SIG_REACT_BUNDLE_ONLY)) and not has_rsc_evidence and server_actions_surface is not True

    if has_rsc_evidence:
        rsc_surface: TriState = True
    else:
        rsc_surface = None

    # Some targets are known to be out of scope for Server Functions.
    is_next_pages_only = TAG_NEXTJS_PAGES_ROUTER in tag_set and TAG_NEXTJS_APP_ROUTER not in tag_set

    # Waku requires a concrete endpoint path (base_url is not a Server Function endpoint).
    entrypoint_required = TAG_WAKU in tag_set
    entrypoint_expected: TriState = None
    if entrypoint_required:
        if server_actions_surface is True or server_action_endpoints:
            entrypoint_expected = True
        elif server_actions_surface is False and confidence_at_least(server_actions_confidence, "high"):
            entrypoint_expected = False

        if server_action_endpoints:
            entrypoint_available: TriState = True
        else:
            # Waku action endpoints may not be discoverable from the landing page (or at all without crawling/auth).
            # Treat this as "unknown" rather than a definitive missing entrypoint.
            entrypoint_available = None
    else:
        entrypoint_available = None

    server_functions_surface: TriState
    confidence: SurfaceConfidence

    # Waku requires a concrete action endpoint path. If we don't have one, we cannot directly
    # test reachability, even if the framework is confidently detected.
    if entrypoint_required and entrypoint_available is not True:
        if server_actions_surface is False and confidence_at_least(server_actions_confidence, "high") and not has_rsc_evidence:
            server_functions_surface = False
            confidence = "high"
        else:
            server_functions_surface = None
            confidence = "medium" if framework_confident else "low"
    # RSC or server actions evidence implies the Server Functions decode surface may be reachable.
    elif has_rsc_evidence or server_actions_surface is True:
        server_functions_surface = True
        confidence = "high" if has_rsc_evidence or confidence_at_least(server_actions_confidence, "high") else "medium"
    # Confident negative: actions explicitly absent and no RSC evidence.
    elif is_next_pages_only and framework_confident:
        server_functions_surface = False
        confidence = "high"
    elif server_actions_surface is False and confidence_at_least(server_actions_confidence, "high") and not has_rsc_evidence:
        server_functions_surface = False
        confidence = "high"
    elif rsc_dependency_only:
        # RSC runtime present in bundles, but we did not observe a concrete decode endpoint.
        # Treat as "unknown" rather than a confident negative.
        server_functions_surface = None
        confidence = "medium" if framework_confident else "low"
    elif react_bundle_only:
        # React detected but no RSC/server action evidence observed; too weak to call absent.
        server_functions_surface = None
        confidence = "low"
    else:
        server_functions_surface = None
        confidence = "low" if server_actions_surface is False else "none"

    evidence: dict[str, Any] = {
        "tags": tags,
        "detection_confidence": signals.get(SIG_DETECTION_CONFIDENCE),
        "detection_confidence_level": signals.get(SIG_DETECTION_CONFIDENCE_LEVEL),
        "signals": {
            SIG_RSC_ENDPOINT_FOUND: signals.get(SIG_RSC_ENDPOINT_FOUND),
            SIG_RSC_CONTENT_TYPE: signals.get(SIG_RSC_CONTENT_TYPE),
            SIG_RSC_FLIGHT_PAYLOAD: signals.get(SIG_RSC_FLIGHT_PAYLOAD),
            SIG_RSC_DEPENDENCY_ONLY: signals.get(SIG_RSC_DEPENDENCY_ONLY),
            SIG_REACT_BUNDLE_ONLY: signals.get(SIG_REACT_BUNDLE_ONLY),
            "server_actions_enabled": server_actions_surface,
            "server_actions_confidence": server_actions_confidence,
            SIG_SERVER_ACTION_ENDPOINTS: server_action_endpoints,
        },
    }

    return RscServerFunctionsSurface(
        rsc_surface=rsc_surface,
        server_actions_surface=server_actions_surface,
        server_functions_surface=server_functions_surface,
        confidence=confidence,
        entrypoint_required=entrypoint_required,
        entrypoint_expected=entrypoint_expected,
        entrypoint_available=entrypoint_available,
        server_action_endpoints=server_action_endpoints,
        evidence=evidence,
    )


def build_missing_surface_report(
    *,
    cve_id: str,
    snapshot: DetectionSnapshot,
    surface: RscServerFunctionsSurface,
    status: PocStatus,
    reason: str,
    reason_code: str = MISSING_SURFACE_REASON_CODE,
    framework_detected: str | None = None,
) -> VulnerabilityReport:
    attack_surface = surface.to_dict()
    if reason_code == MISSING_SURFACE_REASON_CODE and attack_surface.get("server_functions_surface") is None:
        # If we are emitting a definitive "missing surface" verdict, normalize the tri-state surface
        # to a concrete negative for downstream consumers.
        attack_surface["server_functions_surface"] = False

    details: dict[str, Any] = {
        "cve_id": cve_id,
        "confidence": surface.confidence,
        "reason": reason,
        "reason_code": reason_code,
        "surface_detected": False,
        "attack_surface": attack_surface,
        "framework_detected": framework_detected,
        "detection_confidence": (snapshot.signals or {}).get(SIG_DETECTION_CONFIDENCE),
        "detection_confidence_level": (snapshot.signals or {}).get(SIG_DETECTION_CONFIDENCE_LEVEL),
        "detection_tags": list(snapshot.tags or []),
    }

    if status == PocStatus.NOT_VULNERABLE:
        details["not_affected"] = True

    return VulnerabilityReport(
        status=status,
        details=details,
        raw_data={"detection": dict(snapshot.signals or {})},
    )


__all__ = [
    "ENTRYPOINT_EXPECTED_NOT_FOUND_REASON_CODE",
    "ENTRYPOINT_NOT_FOUND_REASON_CODE",
    "MISSING_SURFACE_REASON_CODE",
    "RscServerFunctionsSurface",
    "TriState",
    "compute_rsc_server_functions_surface",
    "build_missing_surface_report",
]
