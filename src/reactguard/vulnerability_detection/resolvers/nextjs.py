# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

from __future__ import annotations

from typing import Any

from ...http.headers import header_value, normalize_headers
from ...http.heuristics import response_looks_like_html
from ...rsc.heuristics import is_action_not_found, response_body_text
from ..journal import PocJournal
from ..probes.rsc_patch_fingerprint_probe import discover_nextjs_action_entrypoint
from .cache import cache_key, resolver_cache
from .types import ActionEndpoint, ActionResolution


def _looks_like_next_action_not_found(result: dict[str, Any] | None) -> bool:
    if not result:
        return False
    headers_lower = normalize_headers(result.get("headers"))
    body = response_body_text(result)
    return is_action_not_found(headers_lower, body)


def _looks_like_html(result: dict[str, Any] | None) -> bool:
    return response_looks_like_html(result)


def _looks_like_html_with_rsc_vary(result: dict[str, Any] | None) -> bool:
    if not result or not _looks_like_html(result):
        return False
    vary = header_value(result.get("headers") or {}, "vary").lower()
    if not vary:
        return False
    vary_parts = [part.strip().lower() for part in vary.split(",") if part.strip()]
    return any(part == "rsc" for part in vary_parts)


def nextjs_needs_valid_action_id(results: list[dict[str, Any]] | None) -> bool:
    """
    Heuristic: detect when Next.js Server Actions are reachable but the provided `Next-Action` is invalid,
    or when the endpoint returned HTML that strongly suggests a Server Actions route but did not return Flight.

    Used to decide whether to escalate to bounded crawl-based discovery (`discover_nextjs_action_entrypoint`).
    """
    for result in results or []:
        if _looks_like_next_action_not_found(result):
            return True
        if _looks_like_html_with_rsc_vary(result):
            return True
    return False


def discover_nextjs_action_entrypoint_cached(
    base_url: str,
    *,
    journal: PocJournal | None = None,
) -> ActionResolution | None:
    """
    Return a cached (entrypoint_url, action_id) pair for Next.js Server Actions, discovering it via
    a bounded same-origin crawl only when needed.
    """
    if not base_url:
        return None

    cache = resolver_cache()
    ck = cache_key("nextjs_action_entrypoint", str(base_url))
    cached = cache.get(ck)
    if isinstance(cached, ActionResolution):
        if journal is not None:
            journal.add_event(
                "nextjs-entrypoint-cache-hit",
                "Reused cached Next.js action entrypoint",
                data={"cache_key": ck, "entrypoint_url": cached.entrypoint_url},
            )
        return cached

    if journal is not None:
        journal.add_event("nextjs-entrypoint-cache-miss", "No cached Next.js action entrypoint; running bounded discovery crawl", data={"cache_key": ck})

    discovered = discover_nextjs_action_entrypoint(base_url)
    if not discovered:
        cache[ck] = None
        if journal is not None:
            journal.add_event("nextjs-entrypoint-discovery-miss", "Failed to discover Next.js action entrypoint", data={"cache_key": ck})
        return None

    entrypoint_url, action_id = discovered
    if not entrypoint_url or not action_id:
        cache[ck] = None
        if journal is not None:
            journal.add_event(
                "nextjs-entrypoint-discovery-error",
                "Discovered Next.js entrypoint missing URL or action ID",
                data={"cache_key": ck, "entrypoint_url": entrypoint_url, "action_id_present": bool(action_id)},
            )
        return None

    entrypoint_str = str(entrypoint_url)
    out = ActionResolution(
        endpoints=[ActionEndpoint(url=entrypoint_str)],
        entrypoint_url=entrypoint_str,
        discovery_method="bounded_crawl",
        has_actions=True,
        action_id=str(action_id),
        evidence={"cache_key": ck},
    )
    cache[ck] = out
    if journal is not None:
        journal.add_event(
            "nextjs-entrypoint-discovered",
            "Discovered Next.js action entrypoint via bounded crawl",
            data={"entrypoint_url": out.entrypoint_url},
        )
    return out


__all__ = ["discover_nextjs_action_entrypoint_cached", "nextjs_needs_valid_action_id"]
