# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any


@dataclass(frozen=True)
class ActionEndpoint:
    """Normalized action endpoint description."""

    url: str
    action_name: str | None = None

    def to_tuple(self) -> tuple[str, str]:
        return (self.url, self.action_name or "")


@dataclass(frozen=True)
class ActionResolution:
    """
    Standardized resolver output shared across frameworks.

    - endpoints: concrete URLs (plus optional action names)
    - entrypoint_url: base route used to discover endpoints (if any)
    - discovery_method: free-form label (e.g., detect_context, probe, crawl_probe)
    - has_actions: whether actions were detected on the surface
    - action_id: wire action/function identifier when applicable
    - prefix_parts: multipart prefix parts for frameworks like React Router
    - synthetic_action_id: True when action_id is generated (not discovered)
    - evidence/error_info: raw resolver detail for journaling/debug
    """

    endpoints: list[ActionEndpoint] = field(default_factory=list)
    entrypoint_url: str | None = None
    discovery_method: str | None = None
    has_actions: bool | None = None
    error_info: dict[str, Any] | None = None
    action_id: str | None = None
    prefix_parts: list[tuple[str, str]] | None = None
    synthetic_action_id: bool = False
    evidence: dict[str, Any] = field(default_factory=dict)

    @property
    def urls(self) -> list[str]:
        return [endpoint.url for endpoint in self.endpoints]

    @property
    def endpoint_pairs(self) -> list[tuple[str, str]]:
        return [endpoint.to_tuple() for endpoint in self.endpoints]


__all__ = ["ActionEndpoint", "ActionResolution"]
