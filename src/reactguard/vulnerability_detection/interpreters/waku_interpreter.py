# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Waku-specific result interpreter for CVE-2025-55182."""

import hashlib
import re
from typing import Any

from ...framework_detection.constants import WAKU_SERVER_ACTION_ENDPOINT_PATTERN
from ...http.headers import header_value
from ...models.poc import PocStatus
from ...rsc.payloads import NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY, NO_INVOKE_ROOT_REF_STRATEGY, SAFE_ARGS_STRATEGY
from ...utils.confidence import confidence_score
from ...utils.react_major import apply_react_major_conflict_penalty, react19_possible
from ...utils.version import is_react_version_vulnerable
from ..journal import PocJournal, get_current_journal
from .digest import ERROR_DIGEST_PATTERN

CVE_ID = "CVE-2025-55182"

WAKU_VULN_ERROR_PATTERN = re.compile(r'\d+:E\{"digest":"[^"]*"\}')
WAKU_VULN_TYPEERROR_PATTERN = re.compile(
    r"(object is not iterable|reference\.arrayBuffer is not a function|Unexpected non-whitespace character after JSON|null prototypes are not supported)",
    re.IGNORECASE,
)
WAKU_VULN_STRUCTURAL_PATTERN = re.compile(r'"name"\s*:\s*"typeerror"', re.IGNORECASE)
WAKU_VULN_STACK_PATTERN = re.compile(r"processticksandrejections", re.IGNORECASE)

WAKU_PATCHED_PATTERN = re.compile(r'"\$T\d*:')
WAKU_PATCHED_PARSE_PATTERN = re.compile(r"(Failed to parse body as FormData)", re.IGNORECASE)
WAKU_PATCHED_TYPEERROR_PATTERN = re.compile(r"formData\.get is not a function", re.IGNORECASE)
_TYPEERROR_READING_KEY_RE = re.compile(r"reading ['\"]([^'\"]+)['\"]", re.IGNORECASE)


def _body_structure_hash(body: str) -> str | None:
    if not body:
        return None
    structure = re.sub(r'"[^"]*"', '"S"', body)
    structure = re.sub(r"'[^']*'", "'S'", structure)
    structure = re.sub(r"\b\d+\b", "N", structure)
    structure = re.sub(r"\s+", "", structure)
    if not structure:
        return None
    return hashlib.sha256(structure.encode()).hexdigest()[:16]


def analyze_waku_results(
    probe_results: list[dict],
    endpoints: list[tuple[str, str]],
    control_results: list[dict] | None = None,
    cve_id: str = CVE_ID,
    react_major: int | None = None,
    react_version: str | None = None,
    react_major_confidence: str | None = None,
    react_major_conflict: bool | None = None,
    react_major_conflict_confidence: str | None = None,
    react_major_conflict_majors: list[int] | None = None,
    journal: PocJournal | None = None,
) -> dict[str, Any]:
    journal = journal or get_current_journal() or PocJournal()
    journal.add_event(
        "analysis-start",
        "Analyzing Waku probe responses",
        data={
            "probes": len(probe_results),
            "endpoints": len(endpoints),
            "react_version": react_version,
        },
    )
    react_major_conf_level = confidence_score(react_major_confidence)

    no_invoke_strategies = {SAFE_ARGS_STRATEGY, NO_INVOKE_ROOT_REF_STRATEGY, NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY}
    safe_args_mode = any(
        isinstance((res.get("payload_meta") or {}), dict) and (res.get("payload_meta") or {}).get("probe_strategy") == SAFE_ARGS_STRATEGY
        for res in list(probe_results or []) + list(control_results or [])
    )
    no_invoke_mode = any(
        isinstance((res.get("payload_meta") or {}), dict) and (res.get("payload_meta") or {}).get("probe_strategy") in no_invoke_strategies
        for res in list(probe_results or []) + list(control_results or [])
    )

    all_results: list[dict[str, Any]] = list(probe_results or [])
    if control_results:
        all_results.extend(list(control_results))
    failed_results = [res for res in all_results if res.get("ok") is False]
    if all_results and len(failed_results) == len(all_results):
        reason = "Probe requests failed after retries; network state unknown"
        error_message = next((res.get("error_message") for res in failed_results if res.get("error_message")), None)
        error_type = next((res.get("error_type") for res in failed_results if res.get("error_type")), None)
        for result in probe_results:
            body = result.get("body") or result.get("body_snippet", "")
            m = ERROR_DIGEST_PATTERN.search(body or "")
            digest = m.group(1) if m else None
            journal.add_probe_result("proto", result, digest=digest)
        for result in control_results or []:
            body = result.get("body") or result.get("body_snippet", "")
            m = ERROR_DIGEST_PATTERN.search(body or "")
            digest = m.group(1) if m else None
            journal.add_probe_result("control", result, digest=digest)
        decision_rule = "all_probes_failed"
        journal.add_decision(
            PocStatus.INCONCLUSIVE,
            reason,
            rule=decision_rule,
            data={
                "total_results": len(all_results),
                "failed_results": len(failed_results),
                "endpoints": len(endpoints),
                "error_message": error_message,
                "error_type": error_type,
            },
        )
        return {
            "status": PocStatus.INCONCLUSIVE,
            "details": {
                "cve_id": cve_id,
                "confidence": "low",
                "reason": reason,
                "decision_rule": decision_rule,
                "surface_detected": True,
                "decode_surface_reached": None,
                "error_message": error_message,
                "error_type": error_type,
            },
            "raw_data": {
                "probe_results": probe_results,
                "control_results": control_results,
                "journal": journal.to_list(),
            },
        }

    vulnerable_indicators = 0
    patched_indicators = 0
    masked_internal_error_matches = 0
    rsc_responses = 0
    empty_500_responses = 0
    surface_detected = True
    success_with_t = False
    success_without_t = False
    has_t_reference = False
    force_fail_trailer_mode = False

    for idx, result in enumerate(probe_results):
        status_code = result.get("status_code")
        body = result.get("body") or result.get("body_snippet", "")
        content_type = header_value(result.get("headers") or {}, "content-type") or ""
        content_type_lower = str(content_type).lower()
        endpoint = result.get("endpoint", "")
        ctrl_body = None
        proto_digest = None
        m = ERROR_DIGEST_PATTERN.search(body or "")
        if m:
            proto_digest = m.group(1)
        journal.add_probe_result("proto", result, digest=proto_digest)

        is_valid_waku_endpoint = bool(WAKU_SERVER_ACTION_ENDPOINT_PATTERN.search(str(endpoint or "")))

        if control_results and idx < len(control_results):
            ctrl = control_results[idx] or {}
            ctrl_body = ctrl.get("body") or ctrl.get("body_snippet", "")
            ctrl_status = ctrl.get("status_code")
            ctrl_digest = None
            m = ERROR_DIGEST_PATTERN.search(ctrl_body or "")
            if m:
                ctrl_digest = m.group(1)

            ctrl_result = dict(ctrl)
            ctrl_result.setdefault("endpoint", endpoint)
            journal.add_probe_result("control", ctrl_result, digest=ctrl_digest)

            if (isinstance((result.get("payload_meta") or {}), dict) and (result.get("payload_meta") or {}).get("probe_strategy") == NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY) or (
                isinstance((ctrl.get("payload_meta") or {}), dict) and (ctrl.get("payload_meta") or {}).get("probe_strategy") == NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY
            ):
                force_fail_trailer_mode = True

            if no_invoke_mode and status_code and ctrl_status:
                rsc_responses += 1
                if (
                    status_code == 500
                    and ctrl_status == 500
                    and not str(body or "").strip()
                    and not str(ctrl_body or "").strip()
                    and "/RSC/" in str(endpoint or "")
                    and is_valid_waku_endpoint
                ):
                    empty_500_responses += 1
                    continue

                proto_digest = None
                m = ERROR_DIGEST_PATTERN.search(body or "")
                if m:
                    proto_digest = m.group(1)
                if proto_digest and ctrl_digest:
                    if proto_digest == ctrl_digest:
                        if safe_args_mode:
                            vulnerable_indicators += 1
                        else:
                            patched_indicators += 1
                    else:
                        if safe_args_mode:
                            patched_indicators += 1
                        else:
                            vulnerable_indicators += 1
                    continue

                # Force-fail trailer probes use deliberate missing path segments; prefer the
                # TypeError "reading '<key>'" token over structural hashing to distinguish
                # proto vs control without being too sensitive to stack trace noise.
                if force_fail_trailer_mode:
                    proto_norm = str(body or "").strip().lower()
                    ctrl_norm = str(ctrl_body or "").strip().lower()
                    if proto_norm == ctrl_norm and proto_norm == "internal server error":
                        # Production Waku builds commonly redact errors to "Internal Server Error".
                        # Treat this as an ambiguous-but-suspicious outcome, and use the runtime
                        # version as a *supportive* hint only (never a hard gate).
                        hint = is_react_version_vulnerable(react_version)
                        if hint is False:
                            patched_indicators += 1
                        else:
                            masked_internal_error_matches += 1
                        continue

                    proto_reading = None
                    ctrl_reading = None
                    m = _TYPEERROR_READING_KEY_RE.search(body or "")
                    if m:
                        proto_reading = m.group(1)
                    m = _TYPEERROR_READING_KEY_RE.search(ctrl_body or "")
                    if m:
                        ctrl_reading = m.group(1)
                    if proto_reading and ctrl_reading:
                        if proto_reading == ctrl_reading:
                            if safe_args_mode:
                                vulnerable_indicators += 1
                            else:
                                patched_indicators += 1
                        else:
                            if safe_args_mode:
                                patched_indicators += 1
                            else:
                                vulnerable_indicators += 1
                        continue

                proto_struct = _body_structure_hash(body or "")
                ctrl_struct = _body_structure_hash(ctrl_body or "")
                if proto_struct and ctrl_struct:
                    if proto_struct == ctrl_struct:
                        if safe_args_mode:
                            vulnerable_indicators += 1
                        else:
                            patched_indicators += 1
                    else:
                        if safe_args_mode:
                            patched_indicators += 1
                        else:
                            vulnerable_indicators += 1
                    continue

                if body == ctrl_body:
                    if safe_args_mode:
                        vulnerable_indicators += 1
                    else:
                        patched_indicators += 1
                else:
                    if safe_args_mode:
                        patched_indicators += 1
                    else:
                        vulnerable_indicators += 1
                continue

            if status_code and ctrl_status and status_code == ctrl_status:
                rsc_responses += 1
                if body == ctrl_body:
                    if (
                        WAKU_VULN_ERROR_PATTERN.search(body)
                        or WAKU_VULN_TYPEERROR_PATTERN.search(body)
                        or WAKU_VULN_STRUCTURAL_PATTERN.search(body)
                        or WAKU_VULN_STACK_PATTERN.search(body)
                    ):
                        vulnerable_indicators += 1
                    else:
                        patched_indicators += 1
                    continue

                vulnerable_indicators += 1
                continue
        if status_code == 500 and not body.strip() and "/RSC/" in endpoint:
            if is_valid_waku_endpoint:
                empty_500_responses += 1
                rsc_responses += 1
            continue

        if "$T" in body:
            has_t_reference = True
            patched_indicators += 1

        # Waku endpoints commonly respond with `text/plain` (or missing content-type); treating all `text/*`
        # as Flight can cause false positives when an HTML error page is returned. Prefer a Flight-row
        # shape and exclude `text/html` unless Flight markers are present.
        looks_flight = bool(re.search(r"^\d+:(?:I\[|\[|\{)", body, re.MULTILINE))
        is_text_like = content_type_lower.startswith("text/") and not content_type_lower.startswith("text/html")

        if status_code in (200, 500) and (is_text_like or looks_flight or is_valid_waku_endpoint):
            rsc_responses += 1

            if status_code == 200 and (looks_flight or is_text_like):
                if has_t_reference:
                    success_with_t = True
                else:
                    success_without_t = True
                    if (
                        WAKU_VULN_ERROR_PATTERN.search(body)
                        or WAKU_VULN_TYPEERROR_PATTERN.search(body)
                        or WAKU_VULN_STRUCTURAL_PATTERN.search(body)
                        or WAKU_VULN_STACK_PATTERN.search(body)
                    ):
                        vulnerable_indicators += 1
                # 200 RSC counts toward vulnerability unless patched markers are present
                continue

            if (
                WAKU_VULN_ERROR_PATTERN.search(body)
                or WAKU_VULN_TYPEERROR_PATTERN.search(body)
                or WAKU_VULN_STRUCTURAL_PATTERN.search(body)
                or WAKU_VULN_STACK_PATTERN.search(body)
            ):
                vulnerable_indicators += 1

            if WAKU_PATCHED_PATTERN.search(body) or WAKU_PATCHED_PARSE_PATTERN.search(body):
                patched_indicators += 1
                continue
            if WAKU_PATCHED_TYPEERROR_PATTERN.search(body):
                matches_control = ctrl_body is not None and ctrl_body == body
                if matches_control or has_t_reference:
                    patched_indicators += 1
                else:
                    vulnerable_indicators += 1
                continue

            if body.strip().lower() == "internal server error":
                patched_indicators += 1
                continue

    if rsc_responses == 0:
        reason = "No RSC Flight responses detected from Waku endpoints"
        status = PocStatus.NOT_VULNERABLE
        confidence = "medium"
        surface_detected = False
        decode_surface_reached = False if probe_results else None
        react19_maybe = react19_possible(
            react_major=react_major,
            react_major_confidence=react_major_confidence,
            react_version=react_version,
            react_major_conflict=react_major_conflict,
            react_major_conflict_majors=react_major_conflict_majors,
        )
        if react_major is not None and react_major != 19 and react_major_conf_level >= confidence_score("high") and not react19_maybe:
            confidence = (
                "high"
                if react_major_conf_level >= confidence_score("high")
                else "medium"
                if react_major_conf_level >= confidence_score("medium")
                else "low"
            )
            status = PocStatus.NOT_APPLICABLE
            reason = "React !=19 with no RSC Flight responses; React2Shell requires React 19.x"
        confidence = apply_react_major_conflict_penalty(
            confidence,
            react_major_conflict=react_major_conflict,
            react_major_conflict_confidence=react_major_conflict_confidence,
        )
        decision_rule = "no_rsc_responses_react_out_of_scope" if status == PocStatus.NOT_APPLICABLE else "no_rsc_responses"
        journal.add_decision(
            status,
            reason,
            rule=decision_rule,
            data={
                "rsc_responses": rsc_responses,
                "endpoints": len(endpoints),
                "vulnerable_indicators": vulnerable_indicators,
                "patched_indicators": patched_indicators,
                "masked_internal_error_matches": masked_internal_error_matches,
                "empty_500_responses": empty_500_responses,
                "safe_args_mode": safe_args_mode,
                "no_invoke_mode": no_invoke_mode,
                "react_major": react_major,
                "react_major_confidence": react_major_confidence,
            },
        )
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "decision_rule": decision_rule,
                "surface_detected": surface_detected,
                "decode_surface_reached": decode_surface_reached,
                "react_major_conflict": react_major_conflict,
                "react_major_conflict_confidence": react_major_conflict_confidence,
                "react_major_conflict_majors": react_major_conflict_majors,
            },
            "raw_data": {
                "probe_results": probe_results,
                "control_results": control_results,
                "journal": journal.to_list(),
            },
        }

    if empty_500_responses == rsc_responses and rsc_responses > 0:
        react19_maybe = react19_possible(
            react_major=react_major,
            react_major_confidence=react_major_confidence,
            react_version=react_version,
            react_major_conflict=react_major_conflict,
            react_major_conflict_majors=react_major_conflict_majors,
        )
        if react_major == 19:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Empty 500 responses from Waku Server Actions with React 19 (likely prototype-triggered error)"
        elif react19_maybe:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Empty 500 responses from Waku Server Actions (possible prototype-triggered error); React 19 evidence present but inconsistent"
        elif react_major == 18:
            confidence = (
                "high"
                if react_major_conf_level >= confidence_score("high")
                else "medium"
                if react_major_conf_level >= confidence_score("medium")
                else "low"
            )
            status = PocStatus.NOT_APPLICABLE
            reason = "Empty 500 responses from Waku Server Actions with React 18 (outside CVE scope)"
        else:
            status = PocStatus.INCONCLUSIVE
            confidence = "low"
            reason = "Empty 500 responses from Waku Server Actions; React version unknown"

        confidence = apply_react_major_conflict_penalty(
            confidence,
            react_major_conflict=react_major_conflict,
            react_major_conflict_confidence=react_major_conflict_confidence,
        )
        if status == PocStatus.NOT_APPLICABLE:
            decision_rule = "empty_500_responses_react_out_of_scope"
        elif status == PocStatus.INCONCLUSIVE:
            decision_rule = "empty_500_responses_react_unknown"
        else:
            decision_rule = "empty_500_responses"
        journal.add_decision(
            status,
            reason,
            rule=decision_rule,
            data={
                "rsc_responses": rsc_responses,
                "empty_500_responses": empty_500_responses,
                "endpoints": len(endpoints),
                "react_major": react_major,
                "react_major_confidence": react_major_confidence,
            },
        )
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "decision_rule": decision_rule,
                "surface_detected": surface_detected,
                "decode_surface_reached": True,
                "react_major": react_major,
                "react_major_conflict": react_major_conflict,
                "react_major_conflict_confidence": react_major_conflict_confidence,
                "react_major_conflict_majors": react_major_conflict_majors,
            },
            "raw_data": {
                "probe_results": probe_results,
                "control_results": control_results,
                "journal": journal.to_list(),
            },
        }

    if no_invoke_mode and control_results:
        if vulnerable_indicators > 0:
            if vulnerable_indicators > 1:
                status = PocStatus.VULNERABLE
                confidence = "high"
            else:
                status = PocStatus.LIKELY_VULNERABLE
                confidence = "medium"
            reason = (
                "Safe-args no-invoke probing observed proto/control match (traversal likely reachable)"
                if safe_args_mode
                else "No-invoke probing observed proto/control divergence (traversal likely reachable)"
            )
        elif masked_internal_error_matches > 0:
            react19_maybe = react19_possible(
                react_major=react_major,
                react_major_confidence=react_major_confidence,
                react_version=react_version,
                react_major_conflict=react_major_conflict,
                react_major_conflict_majors=react_major_conflict_majors,
            )
            if react_major is not None and react_major != 19 and not react19_maybe:
                confidence = (
                    "high"
                    if react_major_conf_level >= confidence_score("high")
                    else "medium"
                    if react_major_conf_level >= confidence_score("medium")
                    else "low"
                )
                status = PocStatus.NOT_APPLICABLE
                reason = f"Redacted 'Internal Server Error' responses observed but React {react_major}.x detected; React2Shell requires React 19.x"
            else:
                status = PocStatus.LIKELY_VULNERABLE
                confidence = "medium" if (react19_maybe or is_react_version_vulnerable(react_version) is True) else "low"
                reason = "No-invoke probing hit redacted 'Internal Server Error' responses; treating as likely vulnerable under error masking"
        elif patched_indicators > 0:
            status = PocStatus.LIKELY_NOT_VULNERABLE
            confidence = "medium"
            reason = (
                "Safe-args no-invoke probing observed proto/control divergence (traversal likely blocked)"
                if safe_args_mode
                else "No-invoke probing observed proto/control match (traversal likely blocked)"
            )
        else:
            status = PocStatus.INCONCLUSIVE
            confidence = "low"
            reason = "No-invoke probing detected but insufficient comparable proto/control evidence"

        confidence = apply_react_major_conflict_penalty(
            confidence,
            react_major_conflict=react_major_conflict,
            react_major_conflict_confidence=react_major_conflict_confidence,
        )
        if vulnerable_indicators > 0:
            decision_rule = "no_invoke_vulnerable_indicators"
        elif masked_internal_error_matches > 0 and status == PocStatus.NOT_APPLICABLE:
            decision_rule = "no_invoke_masked_internal_error_react_out_of_scope"
        elif masked_internal_error_matches > 0:
            decision_rule = "no_invoke_masked_internal_error"
        elif patched_indicators > 0:
            decision_rule = "no_invoke_patched_indicators"
        else:
            decision_rule = "no_invoke_insufficient_evidence"
        journal.add_decision(
            status,
            reason,
            rule=decision_rule,
            data={
                "vulnerable_indicators": vulnerable_indicators,
                "patched_indicators": patched_indicators,
                "masked_internal_error_matches": masked_internal_error_matches,
                "rsc_responses": rsc_responses,
                "empty_500_responses": empty_500_responses,
                "safe_args_mode": safe_args_mode,
                "no_invoke_mode": no_invoke_mode,
                "force_fail_trailer_mode": force_fail_trailer_mode,
                "react_major": react_major,
                "react_major_confidence": react_major_confidence,
            },
        )
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "decision_rule": decision_rule,
                "surface_detected": surface_detected,
                "decode_surface_reached": True,
                "react_major": react_major,
                "react_major_conflict": react_major_conflict,
                "react_major_conflict_confidence": react_major_conflict_confidence,
                "react_major_conflict_majors": react_major_conflict_majors,
            },
            "raw_data": {
                "probe_results": probe_results,
                "control_results": control_results,
                "journal": journal.to_list(),
            },
        }

    if has_t_reference or success_with_t:
        status = PocStatus.LIKELY_NOT_VULNERABLE
        confidence = "high"
        reason = "Detected $T reference pattern; hasOwnProperty guard blocked traversal"
    elif success_without_t or vulnerable_indicators > 0:
        if vulnerable_indicators > 1 or (success_without_t and rsc_responses > 1):
            status = PocStatus.VULNERABLE
            confidence = "high"
            if vulnerable_indicators > 1:
                reason = f"Multiple vulnerable indicators ({vulnerable_indicators}) detected; confirmed vulnerable"
            else:
                reason = "Multiple RSC action responses without $T/patch markers; confirmed vulnerable action surface"
        else:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Vulnerable indicators observed in Waku Server Actions responses, but evidence is not yet corroborated"
    elif patched_indicators > 0:
        status = PocStatus.LIKELY_NOT_VULNERABLE
        confidence = "medium"
        reason = "Patched indicators detected without vulnerable errors"
    else:
        status = PocStatus.INCONCLUSIVE
        confidence = "low"
        reason = "RSC Flight responses detected but no clear vulnerable or patched patterns"

    confidence = apply_react_major_conflict_penalty(
        confidence,
        react_major_conflict=react_major_conflict,
        react_major_conflict_confidence=react_major_conflict_confidence,
    )
    if has_t_reference or success_with_t:
        decision_rule = "t_reference_guard"
    elif status == PocStatus.VULNERABLE:
        decision_rule = "vulnerable_indicators_confirmed"
    elif status == PocStatus.LIKELY_VULNERABLE:
        decision_rule = "vulnerable_indicators_observed"
    elif patched_indicators > 0:
        decision_rule = "patched_indicators"
    else:
        decision_rule = "no_clear_markers"
    journal.add_decision(
        status,
        reason,
        rule=decision_rule,
        data={
            "vulnerable_indicators": vulnerable_indicators,
            "patched_indicators": patched_indicators,
            "masked_internal_error_matches": masked_internal_error_matches,
            "rsc_responses": rsc_responses,
            "empty_500_responses": empty_500_responses,
            "safe_args_mode": safe_args_mode,
            "no_invoke_mode": no_invoke_mode,
            "force_fail_trailer_mode": force_fail_trailer_mode,
            "has_t_reference": has_t_reference,
            "success_with_t": success_with_t,
            "success_without_t": success_without_t,
            "react_major": react_major,
            "react_major_confidence": react_major_confidence,
        },
    )
    return {
        "status": status,
        "details": {
            "cve_id": cve_id,
            "confidence": confidence,
            "reason": reason,
            "decision_rule": decision_rule,
            "surface_detected": surface_detected,
            "decode_surface_reached": True,
            "react_major": react_major,
            "react_major_conflict": react_major_conflict,
            "react_major_conflict_confidence": react_major_conflict_confidence,
            "react_major_conflict_majors": react_major_conflict_majors,
        },
        "raw_data": {
            "probe_results": probe_results,
            "control_results": control_results,
            "journal": journal.to_list(),
        },
    }
