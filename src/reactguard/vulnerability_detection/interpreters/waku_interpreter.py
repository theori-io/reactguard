"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Waku-specific result interpreter for CVE-2025-55182."""

import re
from typing import Any

from ...models.poc import PocStatus
from ..journal import PocJournal

CVE_ID = "CVE-2025-55182"

WAKU_VULN_ERROR_PATTERN = re.compile(r'\d+:E\{"digest":"[^"]*"\}')
WAKU_VULN_TYPEERROR_PATTERN = re.compile(
    r"(object is not iterable|reference\.arrayBuffer is not a function|Unexpected non-whitespace character after JSON|null prototypes are not supported)",
    re.IGNORECASE,
)

WAKU_PATCHED_PATTERN = re.compile(r'"\$T\d*:')
WAKU_PATCHED_PARSE_PATTERN = re.compile(r"(Failed to parse body as FormData)", re.IGNORECASE)
WAKU_PATCHED_TYPEERROR_PATTERN = re.compile(r"formData\.get is not a function", re.IGNORECASE)

CONFIDENCE_ORDER = {"none": 0, "low": 1, "medium": 2, "high": 3}


def _confidence_score(confidence: str | None) -> int:
    return CONFIDENCE_ORDER.get(str(confidence or "").lower(), 0)


def analyze_waku_results(
    probe_results: list[dict],
    endpoints: list[tuple[str, str]],
    control_results: list[dict] | None = None,
    cve_id: str = CVE_ID,
    react_major: int | None = None,
    react_version: str | None = None,
    react_major_confidence: str | None = None,
    journal: PocJournal | None = None,
) -> dict[str, Any]:
    journal = journal or PocJournal()
    journal.add_event(
        "analysis-start",
        "Analyzing Waku probe responses",
        data={
            "probes": len(probe_results),
            "endpoints": len(endpoints),
            "react_version": react_version,
        },
    )
    react_major_conf_level = _confidence_score(react_major_confidence)

    vulnerable_indicators = 0
    patched_indicators = 0
    rsc_responses = 0
    empty_500_responses = 0
    surface_detected = True
    success_with_t = False
    success_without_t = False
    has_t_reference = False

    waku_endpoint_pattern = re.compile(r"(/RSC/F/[a-f0-9]{12,}/[A-Za-z_]\w*\.txt$)|(/RSC/F/_/.+/[A-Za-z_]\w*\.txt$)|(/RSC/ACTION_.+/[A-Za-z_]\w*\.txt$)")

    for idx, result in enumerate(probe_results):
        status_code = result.get("status_code")
        body = result.get("body") or result.get("body_snippet", "")
        content_type = result.get("headers", {}).get("content-type", "") or ""
        endpoint = result.get("endpoint", "")
        ctrl_body = None
        journal.add_probe(
            "proto",
            endpoint=endpoint,
            action_id=result.get("action_name"),
            status_code=status_code,
            body_snippet=body,
            headers=result.get("headers", {}),
        )

        is_valid_waku_endpoint = bool(waku_endpoint_pattern.search(endpoint))

        if control_results and idx < len(control_results):
            ctrl = control_results[idx] or {}
            ctrl_body = ctrl.get("body") or ctrl.get("body_snippet", "")
            ctrl_status = ctrl.get("status_code")
            ctrl_digest = None
            m = re.search(r'"digest"\s*:\s*"([0-9a-fA-F-]+)"', ctrl_body)
            if m:
                ctrl_digest = m.group(1)

            journal.add_probe(
                "control",
                endpoint=ctrl.get("endpoint", endpoint),
                action_id=ctrl.get("action_name"),
                status_code=ctrl_status,
                body_snippet=ctrl_body,
                headers=ctrl.get("headers", {}),
                digest=ctrl_digest,
            )

            if status_code and ctrl_status and status_code == ctrl_status:
                rsc_responses += 1
                if body == ctrl_body:
                    if WAKU_PATCHED_TYPEERROR_PATTERN.search(body):
                        patched_indicators += 1
                    else:
                        vulnerable_indicators += 1
                    continue
                vulnerable_indicators += 1
                continue
        if status_code == 500 and not body.strip() and "/RSC/" in endpoint:
            if is_valid_waku_endpoint:
                empty_500_responses += 1
                rsc_responses += 1
            continue

        if "$T" in body:
            has_t_reference = True
            patched_indicators += 1

        if status_code in (200, 500) and (content_type.startswith("text/") or body.startswith("0:") or is_valid_waku_endpoint):
            rsc_responses += 1

            if status_code == 200 and (body.startswith("0:") or content_type.startswith("text/")):
                if has_t_reference:
                    success_with_t = True
                else:
                    success_without_t = True
                if WAKU_VULN_ERROR_PATTERN.search(body) or WAKU_VULN_TYPEERROR_PATTERN.search(body):
                    vulnerable_indicators += 1
                # 200 RSC counts toward vulnerability unless patched markers are present
                continue

            if WAKU_VULN_ERROR_PATTERN.search(body) or WAKU_VULN_TYPEERROR_PATTERN.search(body):
                vulnerable_indicators += 1

            if WAKU_PATCHED_PATTERN.search(body) or WAKU_PATCHED_PARSE_PATTERN.search(body):
                patched_indicators += 1
                continue
            if WAKU_PATCHED_TYPEERROR_PATTERN.search(body):
                matches_control = ctrl_body is not None and ctrl_body == body
                if matches_control or has_t_reference:
                    patched_indicators += 1
                else:
                    vulnerable_indicators += 1
                continue

            if body.strip().lower() == "internal server error":
                patched_indicators += 1
                continue

    if rsc_responses == 0:
        reason = "No RSC responses detected from Waku endpoints"
        status = PocStatus.NOT_APPLICABLE
        confidence = "high"
        surface_detected = False
        if react_major is not None and react_major < 19:
            confidence = "high" if react_major_conf_level >= CONFIDENCE_ORDER["high"] else "medium" if react_major_conf_level >= CONFIDENCE_ORDER["medium"] else "low"
            status = PocStatus.NOT_VULNERABLE if confidence in {"high", "medium"} else PocStatus.LIKELY_NOT_VULNERABLE
            reason = "React <19 with no RSC responses; React2Shell requires React 19.x"
        journal.add_decision(status, reason)
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "surface_detected": surface_detected,
            },
            "raw_data": {"journal": journal.to_list()},
        }

    if empty_500_responses == rsc_responses and rsc_responses > 0:
        if react_major == 19:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Empty 500 responses from Waku actions with React 19 (likely prototype crash)"
        elif react_major == 18:
            confidence = "high" if react_major_conf_level >= CONFIDENCE_ORDER["high"] else "medium" if react_major_conf_level >= CONFIDENCE_ORDER["medium"] else "low"
            status = PocStatus.NOT_VULNERABLE if confidence in {"high", "medium"} else PocStatus.LIKELY_NOT_VULNERABLE
            reason = "Empty 500 responses from Waku actions with React 18 (outside CVE scope)"
            surface_detected = False
        else:
            status = PocStatus.INCONCLUSIVE
            confidence = "low"
            reason = "Empty 500 responses from Waku actions; React version unknown"

        journal.add_decision(status, reason)
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "surface_detected": surface_detected,
                "react_major": react_major,
            },
            "raw_data": {"journal": journal.to_list()},
        }

    if has_t_reference or success_with_t:
        status = PocStatus.LIKELY_NOT_VULNERABLE
        confidence = "high"
        reason = "$T reference pattern detected - hasOwnProperty blocked traversal"
    elif success_without_t or vulnerable_indicators > 0:
        status = PocStatus.VULNERABLE
        confidence = "high"
        if vulnerable_indicators > 1:
            reason = f"Multiple vulnerable indicators ({vulnerable_indicators}) detected - confirmed vulnerable"
        elif success_without_t:
            reason = "RSC action responses without $T/patch markers - confirmed vulnerable action surface"
        else:
            reason = "Vulnerable error indicators observed in Waku action responses"
    elif patched_indicators > 0:
        status = PocStatus.LIKELY_NOT_VULNERABLE
        confidence = "medium"
        reason = "Patched indicators detected without vulnerable errors"
    else:
        status = PocStatus.INCONCLUSIVE
        confidence = "low"
        reason = "RSC responses detected but no clear vulnerable or patched patterns"

    journal.add_decision(status, reason)
    return {
        "status": status,
        "details": {
            "cve_id": cve_id,
            "confidence": confidence,
            "reason": reason,
            "surface_detected": surface_detected,
            "react_major": react_major,
        },
        "raw_data": {
            "probe_results": probe_results,
            "journal": journal.to_list(),
        },
    }
