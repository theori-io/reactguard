"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Waku-specific result interpreter for CVE-2025-55182."""

import hashlib
import re
from typing import Any

from ...framework_detection.constants import WAKU_SERVER_ACTION_ENDPOINT_PATTERN
from ...models.poc import PocStatus
from ...rsc.payloads import NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY, NO_INVOKE_ROOT_REF_STRATEGY, SAFE_ARGS_STRATEGY
from ...utils.version import is_react_version_vulnerable
from ..journal import PocJournal, get_current_journal
from .digest import ERROR_DIGEST_PATTERN

CVE_ID = "CVE-2025-55182"

WAKU_VULN_ERROR_PATTERN = re.compile(r'\d+:E\{"digest":"[^"]*"\}')
WAKU_VULN_TYPEERROR_PATTERN = re.compile(
    r"(object is not iterable|reference\.arrayBuffer is not a function|Unexpected non-whitespace character after JSON|null prototypes are not supported)",
    re.IGNORECASE,
)
WAKU_VULN_STRUCTURAL_PATTERN = re.compile(r'"name"\s*:\s*"typeerror"', re.IGNORECASE)
WAKU_VULN_STACK_PATTERN = re.compile(r"processticksandrejections", re.IGNORECASE)

WAKU_PATCHED_PATTERN = re.compile(r'"\$T\d*:')
WAKU_PATCHED_PARSE_PATTERN = re.compile(r"(Failed to parse body as FormData)", re.IGNORECASE)
WAKU_PATCHED_TYPEERROR_PATTERN = re.compile(r"formData\.get is not a function", re.IGNORECASE)
_TYPEERROR_READING_KEY_RE = re.compile(r"reading ['\"]([^'\"]+)['\"]", re.IGNORECASE)

CONFIDENCE_ORDER = {"none": 0, "low": 1, "medium": 2, "high": 3}


def _confidence_score(confidence: str | None) -> int:
    return CONFIDENCE_ORDER.get(str(confidence or "").lower(), 0)


def _body_structure_hash(body: str) -> str | None:
    if not body:
        return None
    structure = re.sub(r'"[^"]*"', '"S"', body)
    structure = re.sub(r"'[^']*'", "'S'", structure)
    structure = re.sub(r"\b\d+\b", "N", structure)
    structure = re.sub(r"\s+", "", structure)
    if not structure:
        return None
    return hashlib.sha256(structure.encode()).hexdigest()[:16]


def analyze_waku_results(
    probe_results: list[dict],
    endpoints: list[tuple[str, str]],
    control_results: list[dict] | None = None,
    cve_id: str = CVE_ID,
    react_major: int | None = None,
    react_version: str | None = None,
    react_major_confidence: str | None = None,
    journal: PocJournal | None = None,
) -> dict[str, Any]:
    journal = journal or get_current_journal() or PocJournal()
    journal.add_event(
        "analysis-start",
        "Analyzing Waku probe responses",
        data={
            "probes": len(probe_results),
            "endpoints": len(endpoints),
            "react_version": react_version,
        },
    )
    react_major_conf_level = _confidence_score(react_major_confidence)

    no_invoke_strategies = {SAFE_ARGS_STRATEGY, NO_INVOKE_ROOT_REF_STRATEGY, NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY}
    safe_args_mode = any(
        isinstance((res.get("payload_meta") or {}), dict) and (res.get("payload_meta") or {}).get("probe_strategy") == SAFE_ARGS_STRATEGY
        for res in list(probe_results or []) + list(control_results or [])
    )
    no_invoke_mode = any(
        isinstance((res.get("payload_meta") or {}), dict) and (res.get("payload_meta") or {}).get("probe_strategy") in no_invoke_strategies
        for res in list(probe_results or []) + list(control_results or [])
    )

    all_results: list[dict[str, Any]] = list(probe_results or [])
    if control_results:
        all_results.extend(list(control_results))
    failed_results = [res for res in all_results if res.get("ok") is False]
    if all_results and len(failed_results) == len(all_results):
        reason = "Probe requests failed after retries; network state unknown"
        error_message = next((res.get("error_message") for res in failed_results if res.get("error_message")), None)
        error_type = next((res.get("error_type") for res in failed_results if res.get("error_type")), None)
        journal.add_decision(PocStatus.INCONCLUSIVE, reason)
        return {
            "status": PocStatus.INCONCLUSIVE,
            "details": {
                "cve_id": cve_id,
                "confidence": "low",
                "reason": reason,
                "surface_detected": True,
                "decode_surface_reached": None,
                "error_message": error_message,
                "error_type": error_type,
            },
            "raw_data": {"journal": journal.to_list()},
        }

    vulnerable_indicators = 0
    patched_indicators = 0
    masked_internal_error_matches = 0
    rsc_responses = 0
    empty_500_responses = 0
    surface_detected = True
    success_with_t = False
    success_without_t = False
    has_t_reference = False
    force_fail_trailer_mode = False

    for idx, result in enumerate(probe_results):
        status_code = result.get("status_code")
        body = result.get("body") or result.get("body_snippet", "")
        content_type = result.get("headers", {}).get("content-type", "") or ""
        endpoint = result.get("endpoint", "")
        ctrl_body = None
        journal.add_probe(
            "proto",
            endpoint=endpoint,
            action_id=result.get("action_name"),
            status_code=status_code,
            body_snippet=body,
            headers=result.get("headers", {}),
        )

        is_valid_waku_endpoint = bool(WAKU_SERVER_ACTION_ENDPOINT_PATTERN.search(str(endpoint or "")))

        if control_results and idx < len(control_results):
            ctrl = control_results[idx] or {}
            ctrl_body = ctrl.get("body") or ctrl.get("body_snippet", "")
            ctrl_status = ctrl.get("status_code")
            ctrl_digest = None
            m = ERROR_DIGEST_PATTERN.search(ctrl_body or "")
            if m:
                ctrl_digest = m.group(1)

            journal.add_probe(
                "control",
                endpoint=ctrl.get("endpoint", endpoint),
                action_id=ctrl.get("action_name"),
                status_code=ctrl_status,
                body_snippet=ctrl_body,
                headers=ctrl.get("headers", {}),
                digest=ctrl_digest,
            )

            if (isinstance((result.get("payload_meta") or {}), dict) and (result.get("payload_meta") or {}).get("probe_strategy") == NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY) or (
                isinstance((ctrl.get("payload_meta") or {}), dict) and (ctrl.get("payload_meta") or {}).get("probe_strategy") == NO_INVOKE_FORCE_FAIL_TRAILER_STRATEGY
            ):
                force_fail_trailer_mode = True

            if no_invoke_mode and status_code and ctrl_status:
                rsc_responses += 1
                if (
                    status_code == 500
                    and ctrl_status == 500
                    and not str(body or "").strip()
                    and not str(ctrl_body or "").strip()
                    and "/RSC/" in str(endpoint or "")
                    and is_valid_waku_endpoint
                ):
                    empty_500_responses += 1
                    continue

                proto_digest = None
                m = ERROR_DIGEST_PATTERN.search(body or "")
                if m:
                    proto_digest = m.group(1)
                if proto_digest and ctrl_digest:
                    if proto_digest == ctrl_digest:
                        if safe_args_mode:
                            vulnerable_indicators += 1
                        else:
                            patched_indicators += 1
                    else:
                        if safe_args_mode:
                            patched_indicators += 1
                        else:
                            vulnerable_indicators += 1
                    continue

                # Force-fail trailer probes use deliberate missing path segments; prefer the
                # TypeError "reading '<key>'" token over structural hashing to distinguish
                # proto vs control without being too sensitive to stack trace noise.
                if force_fail_trailer_mode:
                    proto_norm = str(body or "").strip().lower()
                    ctrl_norm = str(ctrl_body or "").strip().lower()
                    if proto_norm == ctrl_norm and proto_norm == "internal server error":
                        # Production Waku builds commonly redact errors to "Internal Server Error".
                        # Treat this as an ambiguous-but-suspicious outcome, and use the runtime
                        # version as a *supportive* hint only (never a hard gate).
                        hint = is_react_version_vulnerable(react_version)
                        if hint is False:
                            patched_indicators += 1
                        else:
                            masked_internal_error_matches += 1
                        continue

                    proto_reading = None
                    ctrl_reading = None
                    m = _TYPEERROR_READING_KEY_RE.search(body or "")
                    if m:
                        proto_reading = m.group(1)
                    m = _TYPEERROR_READING_KEY_RE.search(ctrl_body or "")
                    if m:
                        ctrl_reading = m.group(1)
                    if proto_reading and ctrl_reading:
                        if proto_reading == ctrl_reading:
                            if safe_args_mode:
                                vulnerable_indicators += 1
                            else:
                                patched_indicators += 1
                        else:
                            if safe_args_mode:
                                patched_indicators += 1
                            else:
                                vulnerable_indicators += 1
                        continue

                proto_struct = _body_structure_hash(body or "")
                ctrl_struct = _body_structure_hash(ctrl_body or "")
                if proto_struct and ctrl_struct:
                    if proto_struct == ctrl_struct:
                        if safe_args_mode:
                            vulnerable_indicators += 1
                        else:
                            patched_indicators += 1
                    else:
                        if safe_args_mode:
                            patched_indicators += 1
                        else:
                            vulnerable_indicators += 1
                    continue

                if body == ctrl_body:
                    if safe_args_mode:
                        vulnerable_indicators += 1
                    else:
                        patched_indicators += 1
                else:
                    if safe_args_mode:
                        patched_indicators += 1
                    else:
                        vulnerable_indicators += 1
                continue

            if status_code and ctrl_status and status_code == ctrl_status:
                rsc_responses += 1
                if body == ctrl_body:
                    if (
                        WAKU_VULN_ERROR_PATTERN.search(body)
                        or WAKU_VULN_TYPEERROR_PATTERN.search(body)
                        or WAKU_VULN_STRUCTURAL_PATTERN.search(body)
                        or WAKU_VULN_STACK_PATTERN.search(body)
                    ):
                        vulnerable_indicators += 1
                    else:
                        patched_indicators += 1
                    continue

                vulnerable_indicators += 1
                continue
        if status_code == 500 and not body.strip() and "/RSC/" in endpoint:
            if is_valid_waku_endpoint:
                empty_500_responses += 1
                rsc_responses += 1
            continue

        if "$T" in body:
            has_t_reference = True
            patched_indicators += 1

        if status_code in (200, 500) and (content_type.startswith("text/") or body.startswith("0:") or is_valid_waku_endpoint):
            rsc_responses += 1

            if status_code == 200 and (body.startswith("0:") or content_type.startswith("text/")):
                if has_t_reference:
                    success_with_t = True
                else:
                    success_without_t = True
                    if (
                        WAKU_VULN_ERROR_PATTERN.search(body)
                        or WAKU_VULN_TYPEERROR_PATTERN.search(body)
                        or WAKU_VULN_STRUCTURAL_PATTERN.search(body)
                        or WAKU_VULN_STACK_PATTERN.search(body)
                    ):
                        vulnerable_indicators += 1
                # 200 RSC counts toward vulnerability unless patched markers are present
                continue

            if (
                WAKU_VULN_ERROR_PATTERN.search(body)
                or WAKU_VULN_TYPEERROR_PATTERN.search(body)
                or WAKU_VULN_STRUCTURAL_PATTERN.search(body)
                or WAKU_VULN_STACK_PATTERN.search(body)
            ):
                vulnerable_indicators += 1

            if WAKU_PATCHED_PATTERN.search(body) or WAKU_PATCHED_PARSE_PATTERN.search(body):
                patched_indicators += 1
                continue
            if WAKU_PATCHED_TYPEERROR_PATTERN.search(body):
                matches_control = ctrl_body is not None and ctrl_body == body
                if matches_control or has_t_reference:
                    patched_indicators += 1
                else:
                    vulnerable_indicators += 1
                continue

            if body.strip().lower() == "internal server error":
                patched_indicators += 1
                continue

    if rsc_responses == 0:
        reason = "No RSC Flight responses detected from Waku endpoints"
        status = PocStatus.NOT_VULNERABLE
        confidence = "medium"
        surface_detected = False
        decode_surface_reached = False if probe_results else None
        if react_major is not None and react_major != 19:
            confidence = (
                "high"
                if react_major_conf_level >= CONFIDENCE_ORDER["high"]
                else "medium"
                if react_major_conf_level >= CONFIDENCE_ORDER["medium"]
                else "low"
            )
            status = PocStatus.NOT_APPLICABLE
            reason = "React !=19 with no RSC Flight responses; React2Shell requires React 19.x"
        journal.add_decision(status, reason)
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "surface_detected": surface_detected,
                "decode_surface_reached": decode_surface_reached,
            },
            "raw_data": {"journal": journal.to_list()},
        }

    if empty_500_responses == rsc_responses and rsc_responses > 0:
        if react_major == 19:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Empty 500 responses from Waku Server Actions with React 19 (likely prototype-triggered error)"
        elif react_major == 18:
            confidence = (
                "high"
                if react_major_conf_level >= CONFIDENCE_ORDER["high"]
                else "medium"
                if react_major_conf_level >= CONFIDENCE_ORDER["medium"]
                else "low"
            )
            status = PocStatus.NOT_APPLICABLE
            reason = "Empty 500 responses from Waku Server Actions with React 18 (outside CVE scope)"
        else:
            status = PocStatus.INCONCLUSIVE
            confidence = "low"
            reason = "Empty 500 responses from Waku Server Actions; React version unknown"

        journal.add_decision(status, reason)
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "surface_detected": surface_detected,
                "decode_surface_reached": True,
                "react_major": react_major,
            },
            "raw_data": {"journal": journal.to_list()},
        }

    if no_invoke_mode and control_results:
        if vulnerable_indicators > 0:
            if vulnerable_indicators > 1:
                status = PocStatus.VULNERABLE
                confidence = "high"
            else:
                status = PocStatus.LIKELY_VULNERABLE
                confidence = "medium"
            reason = (
                "Safe-args no-invoke probing observed proto/control match (traversal likely reachable)"
                if safe_args_mode
                else "No-invoke probing observed proto/control divergence (traversal likely reachable)"
            )
        elif masked_internal_error_matches > 0:
            if react_major is not None and react_major != 19:
                confidence = (
                    "high"
                    if react_major_conf_level >= CONFIDENCE_ORDER["high"]
                    else "medium"
                    if react_major_conf_level >= CONFIDENCE_ORDER["medium"]
                    else "low"
                )
                status = PocStatus.NOT_APPLICABLE
            else:
                status = PocStatus.LIKELY_VULNERABLE
                confidence = "medium" if (react_major == 19 or is_react_version_vulnerable(react_version) is True) else "low"
            reason = "No-invoke probing hit redacted 'Internal Server Error' responses; treating as likely vulnerable under error masking"
        elif patched_indicators > 0:
            status = PocStatus.LIKELY_NOT_VULNERABLE
            confidence = "medium"
            reason = (
                "Safe-args no-invoke probing observed proto/control divergence (traversal likely blocked)"
                if safe_args_mode
                else "No-invoke probing observed proto/control match (traversal likely blocked)"
            )
        else:
            status = PocStatus.INCONCLUSIVE
            confidence = "low"
            reason = "No-invoke probing detected but insufficient comparable proto/control evidence"

        journal.add_decision(status, reason)
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "surface_detected": surface_detected,
                "decode_surface_reached": True,
                "react_major": react_major,
            },
            "raw_data": {
                "probe_results": probe_results,
                "control_results": control_results,
                "journal": journal.to_list(),
            },
        }

    if has_t_reference or success_with_t:
        status = PocStatus.LIKELY_NOT_VULNERABLE
        confidence = "high"
        reason = "Detected $T reference pattern; hasOwnProperty guard blocked traversal"
    elif success_without_t or vulnerable_indicators > 0:
        if vulnerable_indicators > 1 or (success_without_t and rsc_responses > 1):
            status = PocStatus.VULNERABLE
            confidence = "high"
            if vulnerable_indicators > 1:
                reason = f"Multiple vulnerable indicators ({vulnerable_indicators}) detected; confirmed vulnerable"
            else:
                reason = "Multiple RSC action responses without $T/patch markers; confirmed vulnerable action surface"
        else:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Vulnerable indicators observed in Waku Server Actions responses, but evidence is not yet corroborated"
    elif patched_indicators > 0:
        status = PocStatus.LIKELY_NOT_VULNERABLE
        confidence = "medium"
        reason = "Patched indicators detected without vulnerable errors"
    else:
        status = PocStatus.INCONCLUSIVE
        confidence = "low"
        reason = "RSC Flight responses detected but no clear vulnerable or patched patterns"

    journal.add_decision(status, reason)
    return {
        "status": status,
        "details": {
            "cve_id": cve_id,
            "confidence": confidence,
            "reason": reason,
            "surface_detected": surface_detected,
            "decode_surface_reached": True,
            "react_major": react_major,
        },
        "raw_data": {
            "probe_results": probe_results,
            "journal": journal.to_list(),
        },
    }
