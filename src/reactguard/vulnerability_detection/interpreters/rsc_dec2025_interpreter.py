# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Dec 2025 CVE mapping logic from a patch-fingerprint outcome."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal

from ...models.poc import PocStatus
from ...utils.version import parse_semver
from ..journal import PocJournal

Dec2025CveId = Literal["CVE-2025-55184", "CVE-2025-67779", "CVE-2025-55183"]
PatchFingerprint = Literal["pre_35345", "post_35345_pre_35351", "post_35351"]
PatchFingerprintWithUnknown = PatchFingerprint | Literal["post_35345_unknown"]
Confidence = Literal["low", "medium", "high"]


def _normalize_confidence(value: str | None) -> Confidence:
    raw = str(value or "").strip().lower()
    if raw == "high":
        return "high"
    if raw in {"med", "medium"}:
        return "medium"
    return "low"


def _infer_patch_fingerprint_from_version(detected_versions: dict[str, Any] | None) -> tuple[PatchFingerprint | None, Confidence | None, dict[str, Any]]:
    if not isinstance(detected_versions, dict):
        return None, None, {}

    raw_version = detected_versions.get("rsc_runtime_version") or detected_versions.get("react_version")
    if not raw_version:
        return None, None, {}

    parsed = parse_semver(str(raw_version))
    if not parsed or parsed.major != 19:
        return None, None, {}

    inferred: PatchFingerprint | None = None
    if parsed.minor == 0:
        if parsed.patch <= 1:
            inferred = "pre_35345"
        elif parsed.patch == 2:
            inferred = "post_35345_pre_35351"
        else:
            inferred = "post_35351"
    elif parsed.minor == 1:
        if parsed.patch <= 2:
            inferred = "pre_35345"
        elif parsed.patch == 3:
            inferred = "post_35345_pre_35351"
        else:
            inferred = "post_35351"
    elif parsed.minor == 2:
        if parsed.patch <= 1:
            inferred = "pre_35345"
        elif parsed.patch == 2:
            inferred = "post_35345_pre_35351"
        else:
            inferred = "post_35351"
    elif parsed.suffix and "canary" in parsed.suffix:
        # Canary builds include a YYYYMMDD suffix; use advisory windows as a fallback heuristic.
        date_token = None
        for token in reversed(parsed.suffix.split("-")):
            if len(token) == 8 and token.isdigit():
                date_token = int(token)
                break
        if date_token is not None:
            if date_token < 20251203:
                inferred = "pre_35345"
            elif date_token < 20251211:
                inferred = "post_35345_pre_35351"
            else:
                inferred = "post_35351"

    if inferred is None:
        return None, None, {}

    confidence: Confidence = "medium"
    return inferred, confidence, {
        "patch_fingerprint_inferred": True,
        "patch_fingerprint_inferred_from": "rsc_runtime_version" if detected_versions.get("rsc_runtime_version") else "react_version",
        "patch_fingerprint_inferred_version": str(raw_version),
        "patch_fingerprint_inferred_confidence": confidence,
    }


def _positive_status(confidence: Confidence, *, definite: PocStatus, likely: PocStatus) -> PocStatus:
    if confidence == "high":
        return definite
    if confidence == "medium":
        return likely
    return PocStatus.INCONCLUSIVE


def _negative_status(confidence: Confidence) -> PocStatus:
    if confidence == "high":
        return PocStatus.NOT_VULNERABLE
    if confidence == "medium":
        return PocStatus.LIKELY_NOT_VULNERABLE
    return PocStatus.INCONCLUSIVE


def _has_marker_evidence(evidence: dict[str, Any] | None) -> bool:
    if not isinstance(evidence, dict):
        return False
    return "marker_h_sig" in evidence and "marker_f_sig" in evidence and "conn_sig" in evidence


def _fingerprint_confidence_pr35345(patch_fingerprint: PatchFingerprintWithUnknown | None, evidence: dict[str, Any] | None) -> Confidence:
    if patch_fingerprint is None:
        return "low"

    if not isinstance(evidence, dict):
        return "low"

    if evidence.get("patch_fingerprint_inferred") is True:
        return _normalize_confidence(str(evidence.get("patch_fingerprint_inferred_confidence")))

    strength = str(evidence.get("pr35345_evidence_strength") or "").strip().lower()
    stable = evidence.get("pr35345_marker_stable") is True

    if strength == "strong":
        confidence: Confidence = "high"
    elif strength == "medium":
        confidence = "medium"
    elif strength == "weak":
        confidence = "medium" if stable else "low"
    elif _has_marker_evidence(evidence):
        # Legacy evidence shape without an explicit strength label.
        confidence = "medium"
    else:
        confidence = "low"

    if not stable:
        if confidence == "high":
            confidence = "medium"
        elif confidence == "medium":
            confidence = "low"
    return confidence


def _min_confidence(*values: Confidence) -> Confidence:
    if any(v == "low" for v in values):
        return "low"
    if any(v == "medium" for v in values):
        return "medium"
    return "high"


def _journal_has_cycle_protection_signature(journal: PocJournal) -> bool:
    for entry in list(getattr(journal, "entries", []) or []):
        if not isinstance(entry, dict):
            continue
        summary = str(entry.get("summary") or "").lower()
        if "explicit cycleprotection" in summary or "cycleprotection signature" in summary:
            return True
    return False


def _fingerprint_confidence_pr35351(
    patch_fingerprint: PatchFingerprintWithUnknown | None,
    *,
    evidence: dict[str, Any] | None,
    journal: PocJournal,
) -> Confidence:
    if patch_fingerprint is None:
        return "low"

    evidence = evidence if isinstance(evidence, dict) else {}
    if evidence.get("patch_fingerprint_inferred") is True:
        return _normalize_confidence(str(evidence.get("patch_fingerprint_inferred_confidence")))
    has_cycle_sig = bool(evidence.get("pr35351_cycle_signature")) or _journal_has_cycle_protection_signature(journal)
    threshold_like = bool(evidence.get("pr35351_threshold_behavior"))
    decode_evidence = bool(evidence.get("pr35351_decode_evidence"))
    has_digest = bool(evidence.get("pr35351_chain_has_digest"))

    if patch_fingerprint == "post_35351":
        if has_cycle_sig:
            return "high"
        if threshold_like and decode_evidence and has_digest:
            return "medium"
        if threshold_like and decode_evidence:
            return "medium"
        return "low"

    if patch_fingerprint == "post_35345_pre_35351":
        if decode_evidence:
            return "medium"
        return "low"

    if patch_fingerprint == "post_35345_unknown":
        return "low"
    return "low"


def _react_major_from_flight_evidence(evidence: dict[str, Any] | None) -> tuple[int | None, Confidence, bool]:
    if not isinstance(evidence, dict):
        return None, "low", False

    majors_raw = evidence.get("react_major_from_flight_majors")
    majors: set[int] = set()
    if isinstance(majors_raw, list):
        for item in majors_raw:
            try:
                majors.add(int(item))
            except (TypeError, ValueError):
                continue

    major: int | None = None
    if not majors:
        raw = evidence.get("react_major_from_flight")
        if raw is not None:
            try:
                major = int(raw)
                majors.add(major)
            except (TypeError, ValueError):
                major = None
    else:
        if len(majors) == 1:
            major = next(iter(majors))

    conflict = bool(evidence.get("react_major_from_flight_conflict")) or (len(majors) > 1)
    confidence = _normalize_confidence(str(evidence.get("react_major_from_flight_confidence") or "low"))
    if major is None and majors:
        confidence = "medium" if confidence == "high" else confidence
    return major, confidence, conflict


def _react_major_from_detected_versions(detected_versions: dict[str, Any] | None) -> int | None:
    if not isinstance(detected_versions, dict):
        return None

    raw_major = detected_versions.get("react_major")
    if raw_major is not None:
        try:
            return int(raw_major)
        except (TypeError, ValueError):
            pass

    for key in ("react_version", "rsc_runtime_version"):
        raw = detected_versions.get(key)
        if not raw:
            continue
        parsed = parse_semver(str(raw))
        if parsed:
            return parsed.major

    return None


@dataclass(frozen=True)
class RscDec2025Interpreter:
    """
    Interpreter for the Dec 2025 CVE family.

    This is intentionally CVE- and framework-aware (cve_id, framework tuple) so callers can
    keep transport/probing separate from verdict mapping.
    """

    cve_id: Dec2025CveId
    framework: str

    def to_report(
        self,
        *,
        patch_fingerprint: PatchFingerprintWithUnknown | None,
        detected_versions: dict[str, Any],
        evidence: dict[str, Any],
        journal: PocJournal,
        invocation_enabled: bool | None,
        invocation_confidence: str | None,
    ) -> dict[str, Any]:
        flight_major, flight_confidence, flight_conflict = _react_major_from_flight_evidence(evidence)
        detected_major = _react_major_from_detected_versions(detected_versions)
        if detected_major == 19 and flight_major is not None and flight_major != 19:
            flight_conflict = True

        if flight_major is not None and flight_major != 19 and not flight_conflict and detected_major != 19 and flight_confidence == "high":
            reason = f"Flight payload indicates React {flight_major}.x; {self.cve_id} applies to React 19.x only"
            decision_rule = "flight_react_major_gate"
            journal.add_decision(
                PocStatus.NOT_APPLICABLE,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "react_major_from_flight": flight_major, "react_major_from_flight_confidence": flight_confidence},
            )
            return {
                "status": PocStatus.NOT_APPLICABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": flight_confidence,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "not_affected": True,
                    "react_major_from_flight": flight_major,
                    "react_major_from_flight_confidence": flight_confidence,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if patch_fingerprint is None:
            inferred, inferred_confidence, inferred_evidence = _infer_patch_fingerprint_from_version(detected_versions)
            if inferred is not None:
                patch_fingerprint = inferred
                if not isinstance(evidence, dict):
                    evidence = {}
                evidence = {**evidence, **inferred_evidence}
                journal.add_event(
                    "dec2025-fingerprint-inferred",
                    "Inferred Dec 2025 patch fingerprint from detected React runtime version",
                    data={
                        "cve_id": self.cve_id,
                        "patch_fingerprint": inferred,
                        "confidence": inferred_confidence,
                        "version": inferred_evidence.get("patch_fingerprint_inferred_version"),
                    },
                )

        if patch_fingerprint is None:
            reason = "Could not fingerprint Dec 2025 patch level on a reachable Flight protocol payload deserialization surface"
            decision_rule = "fingerprint_missing"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule=decision_rule, data={"cve_id": self.cve_id})
            return {
                "status": PocStatus.INCONCLUSIVE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "low",
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": None,
                    "patch_fingerprint_confidence": "low",
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        fp_conf_35345 = _fingerprint_confidence_pr35345(patch_fingerprint, evidence)
        fp_conf_35351 = _fingerprint_confidence_pr35351(patch_fingerprint, evidence=evidence, journal=journal)

        if self.cve_id == "CVE-2025-55184":
            if patch_fingerprint == "pre_35345":
                if fp_conf_35345 == "high":
                    status = PocStatus.VULNERABLE
                    reason = "Patch fingerprint indicates pre-PR#35345 (missing initial RSC DoS mitigation)"
                elif fp_conf_35345 == "medium":
                    status = PocStatus.LIKELY_VULNERABLE
                    reason = "Patch fingerprint suggests pre-PR#35345 (missing initial RSC DoS mitigation)"
                else:
                    status = PocStatus.INCONCLUSIVE
                    reason = "Patch fingerprint suggests pre-PR#35345, but evidence confidence is low"
                decision_rule = "cve_55184_pre_35345"
                journal.add_decision(
                    status,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                )
                return {
                    "status": status,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35345,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if fp_conf_35345 == "high":
                status = PocStatus.NOT_VULNERABLE
                reason = "Patch fingerprint indicates post-PR#35345 (initial DoS mitigation present)"
            elif fp_conf_35345 == "medium":
                status = PocStatus.LIKELY_NOT_VULNERABLE
                reason = "Patch fingerprint suggests post-PR#35345 (initial DoS mitigation present)"
            else:
                status = PocStatus.INCONCLUSIVE
                reason = "Patch fingerprint suggests post-PR#35345, but evidence confidence is low"
            decision_rule = "cve_55184_post_35345"
            journal.add_decision(
                status,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
            )
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": fp_conf_35345,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if self.cve_id == "CVE-2025-67779":
            if patch_fingerprint == "pre_35345":
                if fp_conf_35345 == "low":
                    reason = "Patch fingerprint suggests pre-PR#35345, but evidence confidence is low (cannot map CVE applicability)"
                    decision_rule = "cve_67779_pre_35345_low_confidence"
                    journal.add_decision(
                        PocStatus.INCONCLUSIVE,
                        reason,
                        rule=decision_rule,
                        data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                    )
                    return {
                        "status": PocStatus.INCONCLUSIVE,
                        "details": {
                            "cve_id": self.cve_id,
                            "confidence": fp_conf_35345,
                            "reason": reason,
                            "decision_rule": decision_rule,
                            "patch_fingerprint": patch_fingerprint,
                            "patch_fingerprint_confidence": fp_conf_35345,
                            "detected_versions": detected_versions,
                            "framework_detected": self.framework,
                        },
                        "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                    }

                reason = "Patch fingerprint indicates pre-PR#35345 (CVE-2025-55184 vulnerable); CVE-2025-67779 applies to incomplete-fix versions only"
                decision_rule = "cve_67779_pre_35345_not_affected"
                journal.add_decision(
                    PocStatus.NOT_APPLICABLE,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                )
                return {
                    "status": PocStatus.NOT_APPLICABLE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35345,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                        "not_affected": True,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if patch_fingerprint == "post_35345_unknown":
                overall_confidence: Confidence = "low"
                reason = "Patch fingerprint indicates post-PR#35345, but PR#35351 fingerprint is inconclusive on this endpoint"
                decision_rule = "cve_67779_post_35345_unknown"
                journal.add_decision(
                    PocStatus.INCONCLUSIVE,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                )
                return {
                    "status": PocStatus.INCONCLUSIVE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": overall_confidence,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if patch_fingerprint == "post_35351":
                overall_confidence = _min_confidence(fp_conf_35345, fp_conf_35351)
                status = _negative_status(overall_confidence)
                if overall_confidence == "high":
                    reason = "Patch fingerprint indicates PR#35351 present (cycleProtection guard present)"
                elif overall_confidence == "medium":
                    reason = "Patch fingerprint suggests PR#35351 present (cycleProtection guard present)"
                else:
                    reason = "Patch fingerprint suggests PR#35351 present, but evidence confidence is low"
                decision_rule = "cve_67779_post_35351"
                journal.add_decision(
                    status,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35351},
                )
                return {
                    "status": status,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": overall_confidence,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35351,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            overall_confidence = _min_confidence(fp_conf_35345, fp_conf_35351)
            status = _positive_status(overall_confidence, definite=PocStatus.VULNERABLE, likely=PocStatus.LIKELY_VULNERABLE)
            if overall_confidence == "high":
                reason = "Patch fingerprint indicates post-PR#35345 but pre-PR#35351 (incomplete DoS fix)"
            elif overall_confidence == "medium":
                reason = "Patch fingerprint suggests post-PR#35345 but pre-PR#35351 (incomplete DoS fix)"
            else:
                reason = "Patch fingerprint suggests post-PR#35345 but pre-PR#35351, but evidence confidence is low"
            decision_rule = "cve_67779_post_35345_pre_35351"
            journal.add_decision(
                status,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35351},
            )
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": overall_confidence,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35351,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        # CVE-2025-55183 (source exposure) is configuration-dependent, but fixed by PR#35345.
        if patch_fingerprint != "pre_35345":
            status = _negative_status(fp_conf_35345)
            if fp_conf_35345 == "high":
                reason = "Patch fingerprint indicates post-PR#35345 (server reference source-hiding present)"
            elif fp_conf_35345 == "medium":
                reason = "Patch fingerprint suggests post-PR#35345 (server reference source-hiding present)"
            else:
                reason = "Patch fingerprint suggests post-PR#35345, but evidence confidence is low"
            decision_rule = "cve_55183_post_35345"
            journal.add_decision(
                status,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
            )
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": fp_conf_35345,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if invocation_enabled is False and _normalize_confidence(invocation_confidence) == "high":
            reason = (
                "No reachable Flight protocol payload deserialization surface detected; CVE requires a "
                "Server Action/Server Function that stringifies attacker-controlled input"
            )
            decision_rule = "cve_55183_surface_closed"
            journal.add_decision(
                PocStatus.NOT_VULNERABLE,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "invocation_enabled": invocation_enabled},
            )
            return {
                "status": PocStatus.NOT_VULNERABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "high",
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                    "surface_detected": False,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "invocation_enabled": invocation_enabled,
                    "invocation_confidence": invocation_confidence,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        overall_confidence: Confidence = "medium" if fp_conf_35345 in {"high", "medium"} else "low"
        status = _positive_status(overall_confidence, definite=PocStatus.VULNERABLE, likely=PocStatus.LIKELY_VULNERABLE)
        if overall_confidence == "medium":
            reason = "Patch fingerprint indicates pre-PR#35345; exploitation still depends on Server Action/Server Function behavior (explicit/implicit stringify)"
        else:
            reason = "Patch fingerprint suggests pre-PR#35345, but evidence confidence is low; exploitation still depends on Server Action/Server Function behavior"
        decision_rule = "cve_55183_pre_35345_dependent"
        journal.add_decision(
            status,
            reason,
            rule=decision_rule,
            data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
        )
        return {
            "status": status,
            "details": {
                "cve_id": self.cve_id,
                "confidence": overall_confidence,
                "reason": reason,
                "decision_rule": decision_rule,
                "patch_fingerprint": patch_fingerprint,
                "patch_fingerprint_confidence": fp_conf_35345,
                "invocation_enabled": invocation_enabled,
                "invocation_confidence": invocation_confidence,
                "detected_versions": detected_versions,
                "framework_detected": self.framework,
            },
            "raw_data": {"evidence": evidence, "journal": journal.to_list()},
        }


__all__ = [
    "Dec2025CveId",
    "PatchFingerprint",
    "PatchFingerprintWithUnknown",
    "RscDec2025Interpreter",
]
