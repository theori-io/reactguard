# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Dec 2025 CVE mapping logic from a patch-fingerprint outcome."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal

from ...models.poc import PocStatus
from ..journal import PocJournal

Dec2025CveId = Literal["CVE-2025-55184", "CVE-2025-67779", "CVE-2025-55183"]
PatchFingerprint = Literal["pre_35345", "post_35345_pre_35351", "post_35351"]
PatchFingerprintWithUnknown = PatchFingerprint | Literal["post_35345_unknown"]
Confidence = Literal["low", "medium", "high"]


def _normalize_confidence(value: str | None) -> Confidence:
    raw = str(value or "").strip().lower()
    if raw == "high":
        return "high"
    if raw in {"med", "medium"}:
        return "medium"
    return "low"


def _has_marker_evidence(evidence: dict[str, Any] | None) -> bool:
    if not isinstance(evidence, dict):
        return False
    return "marker_h_sig" in evidence and "marker_f_sig" in evidence and "conn_sig" in evidence


def _fingerprint_confidence_pr35345(patch_fingerprint: PatchFingerprintWithUnknown | None, evidence: dict[str, Any] | None) -> Confidence:
    if patch_fingerprint is None:
        return "low"
    # If we have a concrete patch fingerprint (including "post_35345_unknown"), we have already
    # observed deterministic marker behavior for PR#35345. Treat as strong evidence.
    if patch_fingerprint in {"pre_35345", "post_35345_pre_35351", "post_35351", "post_35345_unknown"}:
        return "high"
    # Fallbacks: treat bundle-only hints as medium.
    if _has_marker_evidence(evidence):
        return "high"
    if isinstance(evidence, dict) and evidence.get("nextjs_server_ref_marker") in {"F", "h"}:
        return "medium"
    return "medium"


def _journal_has_cycle_protection_signature(journal: PocJournal) -> bool:
    for entry in list(getattr(journal, "entries", []) or []):
        if not isinstance(entry, dict):
            continue
        summary = str(entry.get("summary") or "").lower()
        if "explicit cycleprotection" in summary or "cycleprotection signature" in summary:
            return True
    return False


def _fingerprint_confidence_pr35351(patch_fingerprint: PatchFingerprintWithUnknown | None, *, journal: PocJournal) -> Confidence:
    # The PR#35351 fingerprint is derived from bounded chain probing; when we classify to a concrete
    # bracket, treat it as strong evidence.
    if patch_fingerprint == "post_35351":
        # Prefer distinguishing explicit cycleProtection signatures when present, but still treat
        # the threshold-based fingerprint as strong enough for a definitive verdict.
        return "high" if _journal_has_cycle_protection_signature(journal) else "high"
    if patch_fingerprint == "post_35345_pre_35351":
        return "high"
    if patch_fingerprint == "post_35345_unknown":
        return "medium"
    return "low"


@dataclass(frozen=True)
class RscDec2025Interpreter:
    """
    Interpreter for the Dec 2025 CVE family.

    This is intentionally CVE- and framework-aware (cve_id, framework tuple) so callers can
    keep transport/probing separate from verdict mapping.
    """

    cve_id: Dec2025CveId
    framework: str

    def to_report(
        self,
        *,
        patch_fingerprint: PatchFingerprintWithUnknown | None,
        detected_versions: dict[str, Any],
        evidence: dict[str, Any],
        journal: PocJournal,
        server_actions_enabled: bool | None,
        server_actions_confidence: str | None,
    ) -> dict[str, Any]:
        if patch_fingerprint is None:
            return {
                "status": PocStatus.INCONCLUSIVE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "low",
                    "reason": "Could not fingerprint Dec 2025 patch level on a reachable Server Functions decode surface",
                    "patch_fingerprint": None,
                    "patch_fingerprint_confidence": "low",
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        fp_conf_35345 = _fingerprint_confidence_pr35345(patch_fingerprint, evidence)
        fp_conf_35351 = _fingerprint_confidence_pr35351(patch_fingerprint, journal=journal)

        if self.cve_id == "CVE-2025-55184":
            if patch_fingerprint == "pre_35345":
                status = PocStatus.VULNERABLE if fp_conf_35345 == "high" else PocStatus.LIKELY_VULNERABLE
                return {
                    "status": status,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35345,
                        "reason": "Patch fingerprint indicates pre-PR#35345 (missing initial RSC DoS mitigation)",
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            status = PocStatus.NOT_VULNERABLE if fp_conf_35345 == "high" else PocStatus.LIKELY_NOT_VULNERABLE
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": fp_conf_35345,
                    "reason": "Patch fingerprint indicates post-PR#35345 (initial DoS mitigation present)",
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if self.cve_id == "CVE-2025-67779":
            if patch_fingerprint == "pre_35345":
                return {
                    "status": PocStatus.NOT_APPLICABLE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35345,
                        "reason": "Patch fingerprint indicates pre-PR#35345 (CVE-2025-55184 vulnerable); CVE-2025-67779 applies to incomplete-fix versions only",
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                        "not_affected": True,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if patch_fingerprint == "post_35345_unknown":
                return {
                    "status": PocStatus.INCONCLUSIVE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35351,
                        "reason": "Patch fingerprint indicates post-PR#35345, but PR#35351 fingerprint is inconclusive on this endpoint",
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if patch_fingerprint == "post_35351":
                status = PocStatus.NOT_VULNERABLE if fp_conf_35351 == "high" else PocStatus.LIKELY_NOT_VULNERABLE
                return {
                    "status": status,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35351,
                        "reason": "Patch fingerprint indicates PR#35351 present (cycleProtection guard present)",
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35351,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            status = PocStatus.VULNERABLE if fp_conf_35351 == "high" else PocStatus.LIKELY_VULNERABLE
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": fp_conf_35351,
                    "reason": "Patch fingerprint indicates post-PR#35345 but pre-PR#35351 (incomplete DoS fix)",
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35351,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        # CVE-2025-55183 (source exposure) is configuration-dependent, but fixed by PR#35345.
        if patch_fingerprint != "pre_35345":
            status = PocStatus.NOT_VULNERABLE if fp_conf_35345 == "high" else PocStatus.LIKELY_NOT_VULNERABLE
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": fp_conf_35345,
                    "reason": "Patch fingerprint indicates post-PR#35345 (server reference source-hiding present)",
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if server_actions_enabled is False and _normalize_confidence(server_actions_confidence) == "high":
            return {
                "status": PocStatus.NOT_VULNERABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "high",
                    "reason": "No RSC Server Functions decode surface detected; CVE requires a Server Function that stringifies attacker-controlled input",
                    "patch_fingerprint": patch_fingerprint,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                    "surface_detected": False,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "server_actions_enabled": server_actions_enabled,
                    "server_actions_confidence": server_actions_confidence,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        overall_confidence: Confidence = "medium" if fp_conf_35345 == "high" else "low"
        return {
            "status": PocStatus.LIKELY_VULNERABLE,
            "details": {
                "cve_id": self.cve_id,
                "confidence": overall_confidence,
                "reason": "Patch fingerprint indicates pre-PR#35345; exploitation still depends on Server Function behavior (explicit/implicit stringify)",
                "patch_fingerprint": patch_fingerprint,
                "patch_fingerprint_confidence": fp_conf_35345,
                "server_actions_enabled": server_actions_enabled,
                "server_actions_confidence": server_actions_confidence,
                "detected_versions": detected_versions,
                "framework_detected": self.framework,
            },
            "raw_data": {"evidence": evidence, "journal": journal.to_list()},
        }


__all__ = [
    "Dec2025CveId",
    "PatchFingerprint",
    "PatchFingerprintWithUnknown",
    "RscDec2025Interpreter",
]
