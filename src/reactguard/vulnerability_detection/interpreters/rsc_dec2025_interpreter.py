# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Dec 2025 CVE mapping logic from a patch-fingerprint outcome."""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal

from ...models.poc import PocStatus
from ...utils.version import parse_semver
from ..journal import PocJournal

Dec2025CveId = Literal["CVE-2025-55184", "CVE-2025-67779", "CVE-2025-55183"]
PatchFingerprint = Literal["pre_35345", "post_35345_pre_35351", "post_35351"]
PatchFingerprintWithUnknown = PatchFingerprint | Literal["post_35345_unknown"]
Confidence = Literal["low", "medium", "high"]


def _normalize_confidence(value: str | None) -> Confidence:
    raw = str(value or "").strip().lower()
    if raw == "high":
        return "high"
    if raw in {"med", "medium"}:
        return "medium"
    return "low"


def _has_marker_evidence(evidence: dict[str, Any] | None) -> bool:
    if not isinstance(evidence, dict):
        return False
    return "marker_h_sig" in evidence and "marker_f_sig" in evidence and "conn_sig" in evidence


def _fingerprint_confidence_pr35345(patch_fingerprint: PatchFingerprintWithUnknown | None, evidence: dict[str, Any] | None) -> Confidence:
    if patch_fingerprint is None:
        return "low"

    if not isinstance(evidence, dict):
        return "medium"

    strength = str(evidence.get("pr35345_evidence_strength") or "").strip().lower()
    stable = evidence.get("pr35345_marker_stable") is True
    marker_method = str(evidence.get("pr35345_marker_method") or "").strip()

    # When we have differential marker behavior, treat it as strong evidence regardless of the
    # transport-level signature labels (some frameworks surface generic 500s/timeouts here).
    if marker_method:
        return "high"

    confidence: Confidence = "low"
    if strength == "strong":
        confidence = "high" if stable else "medium"
    elif strength == "medium":
        confidence = "medium" if stable else "low"
    elif strength == "weak":
        confidence = "low"
    elif _has_marker_evidence(evidence):
        # Legacy evidence shape without an explicit strength label.
        confidence = "medium"

    # Bundle-only hints should not exceed medium.
    if evidence.get("nextjs_server_ref_marker") in {"F", "h"} and confidence == "low":
        confidence = "medium"
    return confidence


def _min_confidence(*values: Confidence) -> Confidence:
    if any(v == "low" for v in values):
        return "low"
    if any(v == "medium" for v in values):
        return "medium"
    return "high"


def _journal_has_cycle_protection_signature(journal: PocJournal) -> bool:
    for entry in list(getattr(journal, "entries", []) or []):
        if not isinstance(entry, dict):
            continue
        summary = str(entry.get("summary") or "").lower()
        if "explicit cycleprotection" in summary or "cycleprotection signature" in summary:
            return True
    return False


def _fingerprint_confidence_pr35351(patch_fingerprint: PatchFingerprintWithUnknown | None, *, journal: PocJournal) -> Confidence:
    # The PR#35351 fingerprint is derived from bounded chain probing; when we classify to a concrete
    # bracket, treat it as strong evidence.
    if patch_fingerprint == "post_35351":
        # Prefer distinguishing explicit cycleProtection signatures when present, but still treat
        # the threshold-based fingerprint as strong enough for a definitive verdict.
        return "high" if _journal_has_cycle_protection_signature(journal) else "high"
    if patch_fingerprint == "post_35345_pre_35351":
        return "high"
    if patch_fingerprint == "post_35345_unknown":
        return "medium"
    return "low"


def _react_major_from_flight_evidence(evidence: dict[str, Any] | None) -> tuple[int | None, Confidence, bool]:
    if not isinstance(evidence, dict):
        return None, "low", False

    majors_raw = evidence.get("react_major_from_flight_majors")
    majors: set[int] = set()
    if isinstance(majors_raw, list):
        for item in majors_raw:
            try:
                majors.add(int(item))
            except (TypeError, ValueError):
                continue

    major: int | None = None
    if not majors:
        raw = evidence.get("react_major_from_flight")
        if raw is not None:
            try:
                major = int(raw)
                majors.add(major)
            except (TypeError, ValueError):
                major = None
    else:
        if len(majors) == 1:
            major = next(iter(majors))

    conflict = bool(evidence.get("react_major_from_flight_conflict")) or (len(majors) > 1)
    confidence = _normalize_confidence(str(evidence.get("react_major_from_flight_confidence") or "low"))
    if major is None and majors:
        confidence = "medium" if confidence == "high" else confidence
    return major, confidence, conflict


def _react_major_from_detected_versions(detected_versions: dict[str, Any] | None) -> int | None:
    if not isinstance(detected_versions, dict):
        return None

    raw_major = detected_versions.get("react_major")
    if raw_major is not None:
        try:
            return int(raw_major)
        except (TypeError, ValueError):
            pass

    for key in ("react_version", "rsc_runtime_version"):
        raw = detected_versions.get(key)
        if not raw:
            continue
        parsed = parse_semver(str(raw))
        if parsed:
            return parsed.major

    return None


@dataclass(frozen=True)
class RscDec2025Interpreter:
    """
    Interpreter for the Dec 2025 CVE family.

    This is intentionally CVE- and framework-aware (cve_id, framework tuple) so callers can
    keep transport/probing separate from verdict mapping.
    """

    cve_id: Dec2025CveId
    framework: str

    def to_report(
        self,
        *,
        patch_fingerprint: PatchFingerprintWithUnknown | None,
        detected_versions: dict[str, Any],
        evidence: dict[str, Any],
        journal: PocJournal,
        invocation_enabled: bool | None,
        invocation_confidence: str | None,
    ) -> dict[str, Any]:
        flight_major, flight_confidence, flight_conflict = _react_major_from_flight_evidence(evidence)
        detected_major = _react_major_from_detected_versions(detected_versions)
        if detected_major == 19 and flight_major is not None and flight_major != 19:
            flight_conflict = True

        if flight_major is not None and flight_major != 19 and not flight_conflict and detected_major != 19:
            reason = f"Flight payload indicates React {flight_major}.x; {self.cve_id} applies to React 19.x only"
            decision_rule = "flight_react_major_gate"
            journal.add_decision(
                PocStatus.NOT_APPLICABLE,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "react_major_from_flight": flight_major, "react_major_from_flight_confidence": flight_confidence},
            )
            return {
                "status": PocStatus.NOT_APPLICABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": flight_confidence,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "not_affected": True,
                    "react_major_from_flight": flight_major,
                    "react_major_from_flight_confidence": flight_confidence,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if patch_fingerprint is None:
            reason = "Could not fingerprint Dec 2025 patch level on a reachable Flight protocol payload deserialization surface"
            decision_rule = "fingerprint_missing"
            journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule=decision_rule, data={"cve_id": self.cve_id})
            return {
                "status": PocStatus.INCONCLUSIVE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "low",
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": None,
                    "patch_fingerprint_confidence": "low",
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        fp_conf_35345 = _fingerprint_confidence_pr35345(patch_fingerprint, evidence)
        fp_conf_35351 = _fingerprint_confidence_pr35351(patch_fingerprint, journal=journal)

        if self.cve_id == "CVE-2025-55184":
            if patch_fingerprint == "pre_35345":
                if fp_conf_35345 == "high":
                    status = PocStatus.VULNERABLE
                    reason = "Patch fingerprint indicates pre-PR#35345 (missing initial RSC DoS mitigation)"
                elif fp_conf_35345 == "medium":
                    status = PocStatus.LIKELY_VULNERABLE
                    reason = "Patch fingerprint suggests pre-PR#35345 (missing initial RSC DoS mitigation)"
                else:
                    status = PocStatus.INCONCLUSIVE
                    reason = "Patch fingerprint suggests pre-PR#35345, but evidence confidence is low"
                decision_rule = "cve_55184_pre_35345"
                journal.add_decision(
                    status,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                )
                return {
                    "status": status,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35345,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if fp_conf_35345 == "high":
                status = PocStatus.NOT_VULNERABLE
                reason = "Patch fingerprint indicates post-PR#35345 (initial DoS mitigation present)"
            elif fp_conf_35345 == "medium":
                status = PocStatus.LIKELY_NOT_VULNERABLE
                reason = "Patch fingerprint suggests post-PR#35345 (initial DoS mitigation present)"
            else:
                status = PocStatus.INCONCLUSIVE
                reason = "Patch fingerprint suggests post-PR#35345, but evidence confidence is low"
            decision_rule = "cve_55184_post_35345"
            journal.add_decision(
                status,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
            )
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": fp_conf_35345,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if self.cve_id == "CVE-2025-67779":
            if patch_fingerprint == "pre_35345":
                if fp_conf_35345 == "low":
                    reason = "Patch fingerprint suggests pre-PR#35345, but evidence confidence is low (cannot map CVE applicability)"
                    decision_rule = "cve_67779_pre_35345_low_confidence"
                    journal.add_decision(
                        PocStatus.INCONCLUSIVE,
                        reason,
                        rule=decision_rule,
                        data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                    )
                    return {
                        "status": PocStatus.INCONCLUSIVE,
                        "details": {
                            "cve_id": self.cve_id,
                            "confidence": fp_conf_35345,
                            "reason": reason,
                            "decision_rule": decision_rule,
                            "patch_fingerprint": patch_fingerprint,
                            "patch_fingerprint_confidence": fp_conf_35345,
                            "detected_versions": detected_versions,
                            "framework_detected": self.framework,
                        },
                        "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                    }

                reason = "Patch fingerprint indicates pre-PR#35345 (CVE-2025-55184 vulnerable); CVE-2025-67779 applies to incomplete-fix versions only"
                decision_rule = "cve_67779_pre_35345_not_affected"
                journal.add_decision(
                    PocStatus.NOT_APPLICABLE,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                )
                return {
                    "status": PocStatus.NOT_APPLICABLE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": fp_conf_35345,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                        "not_affected": True,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if patch_fingerprint == "post_35345_unknown":
                overall_confidence = _min_confidence(fp_conf_35345, fp_conf_35351)
                reason = "Patch fingerprint indicates post-PR#35345, but PR#35351 fingerprint is inconclusive on this endpoint"
                decision_rule = "cve_67779_post_35345_unknown"
                journal.add_decision(
                    PocStatus.INCONCLUSIVE,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
                )
                return {
                    "status": PocStatus.INCONCLUSIVE,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": overall_confidence,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35345,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            if patch_fingerprint == "post_35351":
                overall_confidence = _min_confidence(fp_conf_35345, fp_conf_35351)
                status = PocStatus.NOT_VULNERABLE
                reason = "Patch fingerprint indicates PR#35351 present (cycleProtection guard present)"
                decision_rule = "cve_67779_post_35351"
                journal.add_decision(
                    status,
                    reason,
                    rule=decision_rule,
                    data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35351},
                )
                return {
                    "status": status,
                    "details": {
                        "cve_id": self.cve_id,
                        "confidence": overall_confidence,
                        "reason": reason,
                        "decision_rule": decision_rule,
                        "patch_fingerprint": patch_fingerprint,
                        "patch_fingerprint_confidence": fp_conf_35351,
                        "detected_versions": detected_versions,
                        "framework_detected": self.framework,
                    },
                    "raw_data": {"evidence": evidence, "journal": journal.to_list()},
                }
            overall_confidence = _min_confidence(fp_conf_35345, fp_conf_35351)
            status = PocStatus.VULNERABLE
            reason = "Patch fingerprint indicates post-PR#35345 but pre-PR#35351 (incomplete DoS fix)"
            decision_rule = "cve_67779_post_35345_pre_35351"
            journal.add_decision(
                status,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35351},
            )
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": overall_confidence,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35351,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        # CVE-2025-55183 (source exposure) is configuration-dependent, but fixed by PR#35345.
        if patch_fingerprint != "pre_35345":
            status = PocStatus.NOT_VULNERABLE
            reason = "Patch fingerprint indicates post-PR#35345 (server reference source-hiding present)"
            decision_rule = "cve_55183_post_35345"
            journal.add_decision(
                status,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
            )
            return {
                "status": status,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": fp_conf_35345,
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        if invocation_enabled is False and _normalize_confidence(invocation_confidence) == "high":
            reason = (
                "No reachable Flight protocol payload deserialization surface detected; CVE requires a "
                "Server Action/Server Function that stringifies attacker-controlled input"
            )
            decision_rule = "cve_55183_surface_closed"
            journal.add_decision(
                PocStatus.NOT_VULNERABLE,
                reason,
                rule=decision_rule,
                data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "invocation_enabled": invocation_enabled},
            )
            return {
                "status": PocStatus.NOT_VULNERABLE,
                "details": {
                    "cve_id": self.cve_id,
                    "confidence": "high",
                    "reason": reason,
                    "decision_rule": decision_rule,
                    "patch_fingerprint": patch_fingerprint,
                    "detected_versions": detected_versions,
                    "framework_detected": self.framework,
                    "surface_detected": False,
                    "patch_fingerprint_confidence": fp_conf_35345,
                    "invocation_enabled": invocation_enabled,
                    "invocation_confidence": invocation_confidence,
                },
                "raw_data": {"evidence": evidence, "journal": journal.to_list()},
            }

        overall_confidence: Confidence = "medium" if fp_conf_35345 == "high" else "low"
        reason = "Patch fingerprint indicates pre-PR#35345; exploitation still depends on Server Action/Server Function behavior (explicit/implicit stringify)"
        decision_rule = "cve_55183_pre_35345_dependent"
        journal.add_decision(
            PocStatus.LIKELY_VULNERABLE,
            reason,
            rule=decision_rule,
            data={"cve_id": self.cve_id, "patch_fingerprint": patch_fingerprint, "patch_fingerprint_confidence": fp_conf_35345},
        )
        return {
            "status": PocStatus.LIKELY_VULNERABLE,
            "details": {
                "cve_id": self.cve_id,
                "confidence": overall_confidence,
                "reason": reason,
                "decision_rule": decision_rule,
                "patch_fingerprint": patch_fingerprint,
                "patch_fingerprint_confidence": fp_conf_35345,
                "invocation_enabled": invocation_enabled,
                "invocation_confidence": invocation_confidence,
                "detected_versions": detected_versions,
                "framework_detected": self.framework,
            },
            "raw_data": {"evidence": evidence, "journal": journal.to_list()},
        }


__all__ = [
    "Dec2025CveId",
    "PatchFingerprint",
    "PatchFingerprintWithUnknown",
    "RscDec2025Interpreter",
]
