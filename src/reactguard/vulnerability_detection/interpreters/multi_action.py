"""
ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
Copyright (C) 2025  Theori Inc.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Multi-action result interpreter for CVE-2025-55182."""

from dataclasses import dataclass
from typing import Any

from ...models.poc import PocStatus
from ..constants import ERROR_BODY_SNIPPET_LIMIT, SMALL_BODY_LENGTH
from ..journal import PocJournal
from .digest import ERROR_DIGEST_PATTERN

# CVE constants
CVE_ID = "CVE-2025-55182"

# Patched behavior signatures - action validation happens BEFORE deserialization
PATCHED_ERROR_PATTERNS = [
    "action not found",
    "invalid action",
    "unknown action",
    "action id not found",
    "no server action found",
    "server action not found",
]

# Vulnerable behavior signatures - prototype pollution occurred during deserialization
VULN_ERROR_PATTERNS = [
    "cannot read properties of null",
    "cannot read properties of undefined",
    "action error:",
    "reading 'id'",
    "reading 'workers'",
    "reading 'constructor'",
    "prototype",
]

NEXTJS_FALSE_POSITIVE_STACK_PATTERNS = [
    "action-handler.js",
]

RSC_CONTENT_TYPE = "text/x-component"
RSC_FLIGHT_PATTERN_V19 = '0:{"a":"$@1"'
RSC_FLIGHT_PATTERN_ARRAY = '0:["$@1",'

CONFIDENCE_ORDER = {"none": 0, "low": 1, "medium": 2, "high": 3}


def _confidence_score(confidence: str | None) -> int:
    return CONFIDENCE_ORDER.get(str(confidence or "").lower(), 0)


def _confidence_at_least(confidence: str | None, threshold: str) -> bool:
    return _confidence_score(confidence) >= CONFIDENCE_ORDER.get(threshold, 0)


@dataclass
class ControlMetadata:
    status: int | None
    digest: str | None
    body: str


@dataclass
class ProbeSignals:
    digests: set[str]
    error_messages: set[str]
    validation_errors: list[str]
    status_codes: list[int | None]
    prototype_error_hits: bool
    rsc_processing: bool
    false_positive_stack_detected: bool
    react_major: int | None


@dataclass
class ProbeOutcomeSummary:
    successes: int
    html_responses: int
    failures: int
    html_dev_errors: bool
    proxy_errors: list[dict[str, Any]]


def _trim_body(body: str) -> str:
    return body.strip()[:ERROR_BODY_SNIPPET_LIMIT]


def _collect_control_metadata(control_results: list[dict[str, Any]] | None, journal: PocJournal) -> ControlMetadata:
    status = None
    digest = None
    body = ""

    if control_results:
        for ctrl in control_results:
            status = ctrl.get("status_code") if ctrl.get("status_code") is not None else status
            ctrl_body = ctrl.get("body") or ctrl.get("body_snippet", "")
            ctrl_digest_match = ERROR_DIGEST_PATTERN.search(ctrl_body)
            ctrl_digest = ctrl_digest_match.group(1) if ctrl_digest_match else None
            digest = ctrl_digest or digest
            if ctrl_body and not body:
                body = ctrl_body
            journal.add_probe(
                "control",
                action_id=ctrl.get("action_id") or ctrl.get("action_name"),
                status_code=status,
                body_snippet=ctrl_body,
                headers=ctrl.get("headers", {}),
                digest=ctrl_digest,
            )

    return ControlMetadata(status=status, digest=digest, body=body)


def _collect_probe_signals(
    probe_results: list[dict[str, Any]],
    journal: PocJournal,
    react_major: int | None,
) -> ProbeSignals:
    digests: set[str] = set()
    error_messages: set[str] = set()
    validation_errors: list[str] = []
    status_codes: list[int | None] = []
    prototype_error_hits = False
    rsc_processing = False
    false_positive_stack_detected = False

    for result in probe_results:
        body = result.get("body") or result.get("body_snippet", "")
        status_code = result.get("status_code")
        status_codes.append(status_code)

        digest_match = ERROR_DIGEST_PATTERN.search(body)
        digest = digest_match.group(1) if digest_match else None
        if digest:
            digests.add(digest)
        journal.add_probe(
            "proto",
            action_id=result.get("action_id") or result.get("action_name"),
            endpoint=result.get("endpoint"),
            status_code=status_code,
            body_snippet=body,
            headers=result.get("headers", {}),
            digest=digest,
        )

        if status_code == 500 and len(body) < SMALL_BODY_LENGTH:
            if not body.startswith(("<!doctype", "<html", "0:", "1:")) and body.strip():
                error_messages.add(_trim_body(body))

        if status_code in (400, 404, 405) and len(body) < SMALL_BODY_LENGTH:
            body_lower = body.lower()
            if any(pattern in body_lower for pattern in PATCHED_ERROR_PATTERNS):
                validation_errors.append(_trim_body(body))

        body_lower = body.lower()
        is_false_positive_stack = any(pattern in body_lower for pattern in NEXTJS_FALSE_POSITIVE_STACK_PATTERNS)
        false_positive_stack_detected = false_positive_stack_detected or is_false_positive_stack
        if status_code and status_code >= 400:
            if any(pattern in body_lower for pattern in VULN_ERROR_PATTERNS) and not is_false_positive_stack:
                prototype_error_hits = True

        content_type = result.get("headers", {}).get("content-type", "")
        if RSC_CONTENT_TYPE in content_type or RSC_FLIGHT_PATTERN_V19 in body or RSC_FLIGHT_PATTERN_ARRAY in body:
            rsc_processing = True
            if react_major is None and RSC_FLIGHT_PATTERN_V19 in body:
                react_major = 19

    return ProbeSignals(
        digests=digests,
        error_messages=error_messages,
        validation_errors=validation_errors,
        status_codes=status_codes,
        prototype_error_hits=prototype_error_hits,
        rsc_processing=rsc_processing,
        false_positive_stack_detected=false_positive_stack_detected,
        react_major=react_major,
    )


def _summarize_probe_outcomes(probe_results: list[dict[str, Any]]) -> ProbeOutcomeSummary:
    successes = 0
    html_responses = 0
    failures = 0
    html_dev_errors = False
    proxy_errors = [
        result for result in probe_results if (result.get("status_code") == 502) and ("proxy error" in (result.get("body", "") + result.get("body_snippet", "")).lower())
    ]

    for result in probe_results:
        status_code = result.get("status_code")
        body = result.get("body") or result.get("body_snippet", "")
        content_type = (result.get("headers", {}) or {}).get("content-type", "")
        body_lower = body.lower()

        is_flight = body.startswith("0:") or body.startswith("1:")
        is_rsc_ct = RSC_CONTENT_TYPE in content_type
        is_json_ct = "application/json" in content_type.lower()
        is_html = "<!doctype" in body_lower or "<html" in body_lower

        if status_code == 200:
            if is_rsc_ct or is_json_ct or is_flight:
                successes += 1
            elif is_html:
                html_responses += 1
        elif status_code in (301, 302, 303, 307, 308):
            html_responses += 1
        elif status_code and status_code >= 500 and is_html and ("__next_data__" in body_lower or "__next_error__" in body_lower):
            html_dev_errors = True

        if status_code and status_code >= 500:
            failures += 1

    return ProbeOutcomeSummary(
        successes=successes,
        html_responses=html_responses,
        failures=failures,
        html_dev_errors=html_dev_errors,
        proxy_errors=proxy_errors,
    )


@dataclass
class Decision:
    status: PocStatus
    confidence: str
    reason: str
    surface_detected: bool | None = None


@dataclass
class MultiActionContext:
    probe_results: list[dict[str, Any]]
    control_results: list[dict[str, Any]] | None
    framework: str
    is_rsc_framework: bool
    error_categories: set[str] | None
    cve_id: str
    server_actions_expected: bool | None
    actions_confidence: str | None
    react_major: int | None
    react_version: str | None
    react_major_confidence: str | None
    react_major_conf_level: int
    journal: PocJournal
    control_metadata: ControlMetadata
    probe_signals: ProbeSignals
    summary: ProbeOutcomeSummary
    surface_detected: bool


def _actions_confidence(actions_confidence: str | None) -> str:
    if _confidence_at_least(actions_confidence, "high"):
        return "high"
    if _confidence_at_least(actions_confidence, "medium"):
        return "medium"
    return "low"


def _react_confidence_from_level(level: int) -> str:
    if level >= CONFIDENCE_ORDER["high"]:
        return "high"
    if level >= CONFIDENCE_ORDER["medium"]:
        return "medium"
    return "low"


def _rule_server_actions_missing(ctx: MultiActionContext) -> Decision | None:
    if ctx.server_actions_expected is not False or ctx.summary.successes != 0:
        return None

    if ctx.is_rsc_framework and ctx.probe_signals.digests:
        proto_digest = list(ctx.probe_signals.digests)[0] if len(ctx.probe_signals.digests) == 1 else None
        if ctx.control_metadata.digest and proto_digest and ctx.control_metadata.digest == proto_digest:
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "RSC probes failed identically without action signal - treating as patched/non-action",
                surface_detected=True,
            )
        if len(ctx.probe_signals.digests) > 1 or (ctx.control_metadata.digest and proto_digest and ctx.control_metadata.digest != proto_digest):
            return Decision(
                PocStatus.VULNERABLE,
                "medium",
                "Proto/control digests diverged despite no action signal - treating as vulnerable behavior",
                surface_detected=True,
            )
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "RSC probes returned error digests without action signal",
            surface_detected=True,
        )

    confidence = _actions_confidence(ctx.actions_confidence)
    status = PocStatus.NOT_VULNERABLE if confidence == "high" else PocStatus.LIKELY_NOT_VULNERABLE
    return Decision(
        status,
        confidence,
        "Server actions not enabled; probe responses came from RSC-only surface (React2Shell requires RSC / Server Actions)",
        surface_detected=ctx.surface_detected,
    )


def _rule_rsc_validation_without_success(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.failures != 0 or ctx.summary.successes != 0:
        return None
    if not (ctx.probe_signals.validation_errors and ctx.is_rsc_framework):
        return None
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Server action validation rejected synthetic IDs (4xx with action-not-found message) before RSC processing",
        surface_detected=True,
    )


def _rule_html_only_responses(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.html_responses == 0 or ctx.summary.successes != 0 or ctx.summary.failures != 0:
        return None

    if ctx.server_actions_expected is False:
        confidence = _actions_confidence(ctx.actions_confidence)
        status = PocStatus.NOT_VULNERABLE if confidence == "high" else PocStatus.LIKELY_NOT_VULNERABLE
        return Decision(
            status,
            confidence,
            "Server actions not detected; HTML responses indicate no action surface (React2Shell requires RSC / Server Actions)",
            surface_detected=ctx.surface_detected,
        )
    if ctx.is_rsc_framework:
        return Decision(
            PocStatus.NOT_VULNERABLE,
            "high",
            "RSC framework detected but probes returned HTML - patched/blocked action surface",
        )
    return Decision(
        PocStatus.NOT_APPLICABLE,
        "high",
        "All responses returned HTML, not RSC Flight protocol",
        surface_detected=False,
    )


def _rule_success_path(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.successes == 0:
        return None

    if ctx.control_metadata.status == 200 and ctx.summary.failures == 0:
        return Decision(
            PocStatus.NOT_VULNERABLE,
            "high",
            "Proto and control probes both succeeded (action processing reached)",
        )
    return Decision(
        PocStatus.NOT_VULNERABLE,
        "medium",
        "Server action processing returned 200 responses for proto probes",
    )


def _rule_nextjs_dev_overlay(ctx: MultiActionContext) -> Decision | None:
    if ctx.framework != "nextjs" or not ctx.summary.html_dev_errors or ctx.summary.successes != 0:
        return None

    all_bodies = [(res.get("body") or res.get("body_snippet", "")) for res in ctx.probe_results]
    all_bodies_same = bool(ctx.control_metadata.body) and all(body == ctx.control_metadata.body for body in all_bodies)
    dev_overlay_signatures = (
        "module not found",
        "webpack",
        "next/dist/build/webpack/plugins",
        "__next_error__",
    )
    dev_overlay_hit = ctx.control_metadata.body and any(sig in ctx.control_metadata.body.lower() for sig in dev_overlay_signatures)

    has_html_200 = any(
        res.get("status_code") == 200 and ("<html" in (res.get("body") or res.get("body_snippet", "")).lower()) for res in ctx.probe_results + (ctx.control_results or [])
    )

    dev_overlay_short_circuit = dev_overlay_hit and all_bodies_same and not ctx.probe_signals.digests and not ctx.probe_signals.rsc_processing

    if has_html_200 and dev_overlay_hit:
        return Decision(
            PocStatus.NOT_VULNERABLE,
            "high",
            "Next.js dev overlay returned 200 HTML for proto/control (patched behavior)",
        )
    if dev_overlay_short_circuit:
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Next.js dev overlay returned identical HTML for proto/control without RSC digests - treating as validation short-circuit",
        )
    if all_bodies_same or (ctx.control_metadata.body and not ctx.control_metadata.digest and ctx.summary.html_dev_errors):
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "Next.js dev overlay returned identical HTML on action probes (possible vulnerable dev path)",
        )

    if ctx.react_major is not None and ctx.react_major < 19:
        confidence = _react_confidence_from_level(ctx.react_major_conf_level)
        status = PocStatus.NOT_VULNERABLE if confidence == "high" else PocStatus.LIKELY_NOT_VULNERABLE
        return Decision(
            status,
            confidence,
            "Next.js dev overlay returned HTML without RSC; React <19 (React2Shell requires React 19.x)",
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Next.js dev error page returned HTML 5xx on action probes (dev overlay on action path)",
    )


def _rule_multiple_digests(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_signals.digests) <= 1:
        return None

    if ctx.server_actions_expected is True:
        return Decision(
            PocStatus.VULNERABLE,
            "high",
            "Proto probes returned multiple distinct error digests while actions were expected - prototype traversal altered behavior",
        )
    if ctx.server_actions_expected is False and not ctx.is_rsc_framework:
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Multiple digests on non-RSC surface without actions signal - treating as ambiguous/non-action",
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Proto probes returned multiple distinct error digests without clear action surface - treating as patched/validation differences",
    )


def _rule_single_digest_failure(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_signals.digests) != 1 or ctx.summary.failures < 2 or ctx.summary.successes != 0:
        return None

    proto_digest = list(ctx.probe_signals.digests)[0]
    react_info = f" (React {ctx.react_major})" if ctx.react_major else ""
    control_matches_proto = ctx.control_metadata.status == 500 and ctx.control_metadata.digest == proto_digest
    control_diverges = ctx.control_metadata.status == 200 or (
        ctx.control_metadata.status == 500 and ctx.control_metadata.digest is not None and ctx.control_metadata.digest != proto_digest
    )

    if control_diverges:
        if ctx.control_metadata.status == 200:
            return Decision(
                PocStatus.VULNERABLE,
                "high",
                f"Control succeeded (200) while proto probe fails with digest {proto_digest[:16]}... - prototype traversal causes crash{react_info}",
            )
        return Decision(
            PocStatus.VULNERABLE,
            "high" if ctx.server_actions_expected is True else "medium",
            f"Proto and control probes fail with different digests ({proto_digest[:12]}... vs {ctx.control_metadata.digest[:12]}...) - different error paths{react_info}",
        )

    if control_matches_proto:
        all_bodies = [(res.get("body") or "") + res.get("body_snippet", "") for res in ctx.probe_results]
        has_patched_error = any(any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS) for body in all_bodies)
        if has_patched_error:
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "Proto and control probes share the same digest but include action validation errors - patched behavior",
            )
        if ctx.react_major is not None and ctx.react_major != 19:
            confidence = _react_confidence_from_level(ctx.react_major_conf_level)
            status = PocStatus.NOT_VULNERABLE if confidence == "high" else PocStatus.LIKELY_NOT_VULNERABLE
            return Decision(
                status,
                confidence,
                f"React {ctx.react_major}.x with identical proto/control failures (React2Shell requires React 19.x)",
                surface_detected=ctx.is_rsc_framework or ctx.probe_signals.rsc_processing,
            )
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Proto and control probes fail identically - no behavioral difference attributable to prototype traversal",
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        f"All {ctx.summary.failures} probes failed with identical digest - RSC deserialization error{react_info}",
    )


def _rule_server_actions_error_path(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.server_actions_expected and ctx.is_rsc_framework and ctx.summary.failures > 0 and ctx.summary.successes == 0):
        return None

    if ctx.framework == "nextjs":
        proto_bodies = [(res.get("body") or res.get("body_snippet", "")) for res in ctx.probe_results]
        validation_on_action_path = any(
            any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS) for body in proto_bodies + ([ctx.control_metadata.body] if ctx.control_metadata.body else [])
        )
        if validation_on_action_path:
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "Server action probes hit validation messaging without RSC digests - treating as patched/blocked action surface",
            )
        if ctx.react_major is not None and ctx.react_major < 19:
            confidence = _react_confidence_from_level(ctx.react_major_conf_level)
            status = PocStatus.NOT_VULNERABLE if confidence == "high" else PocStatus.LIKELY_NOT_VULNERABLE
            return Decision(
                status,
                confidence,
                "Server actions errors without RSC processing; React <19 (React2Shell requires React 19.x)",
            )
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "Server actions expected; probes returned 5xx without RSC digests (dev/HTML error path)",
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Server actions expected; probes returned 5xx without RSC digests (dev/HTML error path)",
    )


def _rule_single_probe_guard(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_results) != 1:
        return None
    return Decision(
        PocStatus.INCONCLUSIVE,
        "low",
        "Only one probe result available; need multiple actions to compare",
    )


def _rule_prototype_errors(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.probe_signals.prototype_error_hits and not ctx.probe_signals.false_positive_stack_detected):
        return None

    if (ctx.probe_signals.rsc_processing or ctx.is_rsc_framework) and (ctx.summary.failures > 0 or ctx.server_actions_expected):
        confidence = "high" if ctx.summary.failures > 0 else "medium"
        return Decision(
            PocStatus.VULNERABLE,
            confidence,
            "Prototype-related errors observed in RSC probe responses (action path hit)",
        )
    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Prototype-related errors observed in probe responses",
    )


def _rule_validation_non_rsc(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.probe_signals.validation_errors and not ctx.is_rsc_framework):
        return None
    return Decision(
        PocStatus.NOT_APPLICABLE,
        "high",
        "Action validation errors on non-RSC surface (likely SPA)",
        surface_detected=False,
    )


def _rule_error_messages(ctx: MultiActionContext) -> Decision | None:
    if not ctx.probe_signals.error_messages:
        return None
    if len(ctx.probe_signals.error_messages) == 1:
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            "Single plain-text error response; unable to determine behavior",
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Multiple distinct error messages; suggests patched validation paths",
    )


def _rule_rsc_processing_only(ctx: MultiActionContext) -> Decision | None:
    if not ctx.probe_signals.rsc_processing:
        return None
    return Decision(
        PocStatus.INCONCLUSIVE,
        "low",
        "RSC processing detected but behavior inconclusive",
    )


def _default_rule(ctx: MultiActionContext) -> Decision:
    return Decision(
        PocStatus.NOT_APPLICABLE,
        "high",
        "No RSC processing detected",
        surface_detected=False,
    )


def _evaluate_rules(ctx: MultiActionContext) -> Decision:
    rules = [
        _rule_server_actions_missing,
        _rule_rsc_validation_without_success,
        _rule_html_only_responses,
        _rule_success_path,
        _rule_nextjs_dev_overlay,
        _rule_multiple_digests,
        _rule_single_digest_failure,
        _rule_server_actions_error_path,
        _rule_single_probe_guard,
        _rule_prototype_errors,
        _rule_validation_non_rsc,
        _rule_error_messages,
        _rule_rsc_processing_only,
        _default_rule,
    ]
    for rule in rules:
        decision = rule(ctx)
        if decision:
            return decision
    return _default_rule(ctx)


def _build_decision_result(ctx: MultiActionContext, decision: Decision, surface_detected: bool) -> dict[str, Any]:
    ctx.journal.add_decision(decision.status, decision.reason)
    return {
        "status": decision.status,
        "details": {
            "cve_id": ctx.cve_id,
            "confidence": decision.confidence,
            "reason": decision.reason,
            "framework": ctx.framework,
            "react_major": ctx.react_major,
            "surface_detected": surface_detected,
            "proto_digests": list(ctx.probe_signals.digests),
            "control_digest": ctx.control_metadata.digest,
        },
        "raw_data": {
            "probe_results": ctx.probe_results,
            "control_results": ctx.control_results,
            "journal": ctx.journal.to_list(),
        },
    }


def _build_all_failed_result(
    journal: PocJournal,
    cve_id: str,
    framework: str,
    error_categories: set[str] | None,
    probe_results: list[dict],
    _control_results: list[dict] | None,
) -> dict[str, Any]:
    reason = "Probe requests failed after retries; network state unknown"
    journal.add_decision(PocStatus.INCONCLUSIVE, reason)
    return {
        "status": PocStatus.INCONCLUSIVE,
        "details": {
            "cve_id": cve_id,
            "confidence": "none",
            "reason": reason,
            "framework": framework,
            "error_categories": list(error_categories or []),
            "probes_sent": len(probe_results),
            "surface_detected": False,
        },
        "raw_data": {"journal": journal.to_list()},
    }


def _build_proxy_error_result(ctx: MultiActionContext, decision: Decision) -> dict[str, Any]:
    ctx.journal.add_decision(decision.status, decision.reason)
    return {
        "status": decision.status,
        "details": {
            "cve_id": ctx.cve_id,
            "confidence": decision.confidence,
            "reason": decision.reason,
            "framework": ctx.framework,
            "surface_detected": decision.surface_detected,
            "error_categories": ctx.error_categories,
        },
        "raw_data": {
            "probe_results": ctx.probe_results,
            "control_results": ctx.control_results,
            "journal": ctx.journal.to_list(),
        },
    }


def analyze_multi_action_results(
    probe_results: list[dict],
    action_ids: list[str] | None = None,
    framework: str = "nextjs",
    is_rsc_framework: bool = False,
    error_categories: set[str] | None = None,
    cve_id: str = CVE_ID,
    control_results: list[dict] | None = None,
    react_major: int | None = None,
    react_version: str | None = None,
    server_actions_expected: bool | None = None,
    server_actions_confidence: str | None = None,
    react_major_confidence: str | None = None,
    journal: PocJournal | None = None,
) -> dict[str, Any]:
    journal = journal or PocJournal()
    journal.add_event(
        "analysis-start",
        "Analyzing multi-action probe responses",
        data={
            "probes": len(probe_results),
            "control_probes": len(control_results or []),
            "framework": framework,
            "is_rsc_framework": is_rsc_framework,
            "react_version": react_version,
        },
    )

    failed_results = [res for res in probe_results if res.get("ok") is False]
    if control_results:
        failed_results.extend([res for res in control_results if res.get("ok") is False])

    total_results = len(probe_results) + len(control_results or [])
    all_failed = total_results > 0 and len(failed_results) == total_results
    if all_failed:
        journal.add_event(
            "probe-error",
            "All probes failed; returning INCONCLUSIVE",
            data={
                "error_categories": list(error_categories or []),
                "failed_results": len(failed_results),
            },
        )
        return _build_all_failed_result(journal, cve_id, framework, error_categories, probe_results, control_results)

    actions_confidence = server_actions_confidence
    if actions_confidence is None and server_actions_expected is False:
        actions_confidence = "high"

    if server_actions_expected is None and not is_rsc_framework and framework != "nextjs":
        server_actions_expected = False

    control_metadata = _collect_control_metadata(control_results, journal)
    probe_signals = _collect_probe_signals(probe_results, journal, react_major)
    react_major = probe_signals.react_major
    summary = _summarize_probe_outcomes(probe_results)
    surface_detected = bool(is_rsc_framework or probe_signals.rsc_processing)
    react_major_conf_level = _confidence_score(react_major_confidence)

    ctx = MultiActionContext(
        probe_results=probe_results,
        control_results=control_results,
        framework=framework,
        is_rsc_framework=is_rsc_framework,
        error_categories=error_categories,
        cve_id=cve_id,
        server_actions_expected=server_actions_expected,
        actions_confidence=actions_confidence,
        react_major=react_major,
        react_version=react_version,
        react_major_confidence=react_major_confidence,
        react_major_conf_level=react_major_conf_level,
        journal=journal,
        control_metadata=control_metadata,
        probe_signals=probe_signals,
        summary=summary,
        surface_detected=surface_detected,
    )

    if summary.proxy_errors and summary.successes == 0 and summary.failures == len(probe_signals.status_codes):
        proxy_decision = Decision(
            PocStatus.INCONCLUSIVE,
            "none",
            "Probe requests failed with upstream proxy errors",
            surface_detected=False,
        )
        return _build_proxy_error_result(ctx, proxy_decision)

    decision = _evaluate_rules(ctx)
    applied_surface = decision.surface_detected if decision.surface_detected is not None else surface_detected

    return _build_decision_result(ctx, decision, applied_surface)
