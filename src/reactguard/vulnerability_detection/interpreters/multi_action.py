# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Multi-action result interpreter for CVE-2025-55182."""

import hashlib
import re
from collections import Counter
from dataclasses import dataclass
from typing import Any

from ...http.headers import header_value
from ...http.heuristics import looks_like_html
from ...http.models import HttpResponse
from ...models.poc import PocStatus
from ...rsc.heuristics import (
    ACTION_NOT_FOUND_PHRASES,
    extract_error_digest,
    response_looks_like_flight,
)
from ...rsc.payloads import SAFE_ARGS_STRATEGY
from ...utils.confidence import confidence_at_least, confidence_score
from ...utils.react_major import (
    apply_react_major_conflict_penalty,
    infer_react_major_from_flight_text,
    react19_possible,
)
from ...utils.version import is_react_version_vulnerable
from ..constants import ERROR_BODY_SNIPPET_LIMIT, SMALL_BODY_LENGTH
from ..journal import PocJournal, get_current_journal, journal_context
from ..surface import invocation_feature_label
from .base import BaseRuleInterpreter, Decision, Rule

# CVE constants
CVE_ID = "CVE-2025-55182"

# Patched behavior signatures - action validation happens BEFORE deserialization
PATCHED_ERROR_PATTERNS = list(ACTION_NOT_FOUND_PHRASES)

# Vulnerable behavior signatures - prototype pollution occurred during deserialization
VULN_ERROR_PATTERNS = [
    "cannot read properties of null",
    "cannot read properties of undefined",
    "action error:",
    "reading 'id'",
    "reading 'workers'",
    "reading 'constructor'",
    "prototype",
]
VULN_ERROR_REGEX_PATTERNS = [
    re.compile(r'"name"\s*:\s*"typeerror"', re.IGNORECASE),
    re.compile(r"typeerror", re.IGNORECASE),
    re.compile(r"processticksandrejections", re.IGNORECASE),
]

NEXTJS_FALSE_POSITIVE_STACK_PATTERNS = [
    "action-handler.js",
]


def _body_structure_hash(body: str) -> str | None:
    if not body:
        return None
    structure = re.sub(r'"[^"]*"', '"S"', body)
    structure = re.sub(r"'[^']*'", "'S'", structure)
    structure = re.sub(r"\b\d+\b", "N", structure)
    structure = re.sub(r"\s+", "", structure)
    if not structure:
        return None
    return hashlib.sha256(structure.encode()).hexdigest()[:16]


def _react19_possible(ctx: "MultiActionContext") -> bool:
    return react19_possible(
        react_major=ctx.react_major,
        react_major_confidence=ctx.react_major_confidence,
        react_version=ctx.react_version,
        react_major_conflict=ctx.react_major_conflict,
        react_major_conflict_majors=ctx.react_major_conflict_majors,
    )


def _apply_react_major_conflict_penalty(ctx: "MultiActionContext", confidence: str) -> str:
    return apply_react_major_conflict_penalty(
        confidence,
        react_major_conflict=ctx.react_major_conflict,
        react_major_conflict_confidence=ctx.react_major_conflict_confidence,
    )


def _header_signature(headers: dict[str, Any] | None) -> str | None:
    if not headers:
        return None
    keys = [str(k).lower() for k in headers.keys() if k is not None]
    if not keys:
        return None
    normalized = ",".join(sorted(keys))
    return hashlib.sha256(normalized.encode()).hexdigest()[:8]


def _response_body(result: HttpResponse | None) -> str:
    if not result:
        return ""
    return result.text or result.body_snippet or ""


def _response_headers(result: HttpResponse | None) -> dict[str, Any]:
    if not result:
        return {}
    return result.headers or {}


def _response_mappings(results: list[HttpResponse] | None) -> list[dict[str, Any]]:
    return [res.to_mapping() for res in results or []]


@dataclass
class ControlMetadata:
    status: int | None
    digest: str | None
    body: str
    structure_hash: str | None
    header_signature: str | None
    content_length: int | None
    rsc_processing: bool


@dataclass
class ProbeSignals:
    digests: set[str]
    error_messages: set[str]
    validation_errors: list[str]
    status_codes: list[int | None]
    prototype_error_hits: bool
    rsc_processing: bool
    false_positive_stack_detected: bool
    react_major: int | None
    structure_hashes: set[str]
    header_signatures: set[str]
    content_lengths: list[int | None]


@dataclass
class ProbeOutcomeSummary:
    successes: int
    html_responses: int
    failures: int
    html_dev_errors: bool
    proxy_errors: list[dict[str, Any]]


def _trim_body(body: str) -> str:
    return body.strip()[:ERROR_BODY_SNIPPET_LIMIT]


def _collect_control_metadata(control_results: list[HttpResponse] | None, journal: PocJournal) -> ControlMetadata:
    status = None
    digest = None
    body = ""
    structure_hash = None
    header_signature = None
    content_length = None
    rsc_processing = False

    if control_results:
        for ctrl in control_results:
            ctrl_status = ctrl.status_code
            status = ctrl_status if ctrl_status is not None else status
            ctrl_body = _response_body(ctrl)
            ctrl_digest = extract_error_digest(ctrl_body)
            digest = ctrl_digest or digest
            structure_hash = _body_structure_hash(ctrl_body) or structure_hash
            header_signature = header_signature or _header_signature(_response_headers(ctrl))
            content_length = content_length if content_length is not None else (len(ctrl_body) if ctrl_body else None)
            if ctrl_body and not body:
                body = ctrl_body

            if response_looks_like_flight(_response_headers(ctrl), ctrl_body):
                rsc_processing = True
            journal.add_probe_result("control", ctrl.to_mapping(), digest=ctrl_digest)

    return ControlMetadata(
        status=status,
        digest=digest,
        body=body,
        structure_hash=structure_hash,
        header_signature=header_signature,
        content_length=content_length,
        rsc_processing=rsc_processing,
    )


def _collect_probe_signals(
    probe_results: list[HttpResponse],
    journal: PocJournal,
    react_major: int | None,
) -> ProbeSignals:
    digests: set[str] = set()
    error_messages: set[str] = set()
    validation_errors: list[str] = []
    status_codes: list[int | None] = []
    prototype_error_hits = False
    rsc_processing = False
    false_positive_stack_detected = False
    structure_hashes: set[str] = set()
    header_signatures: set[str] = set()
    content_lengths: list[int | None] = []
    inferred_majors: set[int] = set()

    for result in probe_results:
        body = _response_body(result)
        status_code = result.status_code
        status_codes.append(status_code)

        digest = extract_error_digest(body)
        if digest:
            digests.add(digest)
        journal.add_probe_result("proto", result.to_mapping(), digest=digest)

        if status_code == 500 and len(body) < SMALL_BODY_LENGTH:
            headers = _response_headers(result)
            if not looks_like_html(headers, body) and not response_looks_like_flight(headers, body) and body.strip():
                error_messages.add(_trim_body(body))

        if status_code in (400, 404, 405) and len(body) < SMALL_BODY_LENGTH:
            body_lower = body.lower()
            if any(pattern in body_lower for pattern in PATCHED_ERROR_PATTERNS):
                validation_errors.append(_trim_body(body))

        body_lower = body.lower()
        is_false_positive_stack = any(pattern in body_lower for pattern in NEXTJS_FALSE_POSITIVE_STACK_PATTERNS)
        false_positive_stack_detected = false_positive_stack_detected or is_false_positive_stack
        if status_code and status_code >= 400:
            regex_hit = any(regex.search(body) for regex in VULN_ERROR_REGEX_PATTERNS)
            if (any(pattern in body_lower for pattern in VULN_ERROR_PATTERNS) or regex_hit) and not is_false_positive_stack:
                prototype_error_hits = True

        if response_looks_like_flight(_response_headers(result), body):
            rsc_processing = True
            inferred_major = infer_react_major_from_flight_text(body)
            if inferred_major is not None:
                inferred_majors.add(inferred_major)

        structure_hash = _body_structure_hash(body)
        header_signature = _header_signature(_response_headers(result))
        if structure_hash:
            structure_hashes.add(structure_hash)
        if header_signature:
            header_signatures.add(header_signature)
        content_lengths.append(len(body) if body else None)

    if inferred_majors:
        # Prefer React 19 when both appear to avoid false NOT_APPLICABLE gating in mixed deployments.
        react_major = 19 if 19 in inferred_majors else 18 if 18 in inferred_majors else react_major

    return ProbeSignals(
        digests=digests,
        error_messages=error_messages,
        validation_errors=validation_errors,
        status_codes=status_codes,
        prototype_error_hits=prototype_error_hits,
        rsc_processing=rsc_processing,
        false_positive_stack_detected=false_positive_stack_detected,
        react_major=react_major,
        structure_hashes=structure_hashes,
        header_signatures=header_signatures,
        content_lengths=content_lengths,
    )


def _summarize_probe_outcomes(probe_results: list[HttpResponse]) -> ProbeOutcomeSummary:
    successes = 0
    html_responses = 0
    failures = 0
    html_dev_errors = False
    proxy_errors = [
        result.to_mapping()
        for result in probe_results
        if (result.status_code == 502) and ("proxy error" in (_response_body(result).lower()))
    ]

    for result in probe_results:
        status_code = result.status_code
        body = _response_body(result)
        headers = _response_headers(result)
        content_type = header_value(headers or {}, "content-type").lower()
        body_lower = body.lower()

        is_html = looks_like_html(headers, body)
        is_flight = response_looks_like_flight(headers, body)
        is_rsc_ct = bool(headers) and response_looks_like_flight(headers, None)
        is_json_ct = "application/json" in content_type

        if status_code == 200:
            if is_rsc_ct or is_json_ct or is_flight:
                successes += 1
            elif is_html:
                html_responses += 1
        elif status_code in (301, 302, 303, 307, 308):
            html_responses += 1
        elif status_code and status_code >= 500 and is_html and ("__next_data__" in body_lower or "__next_error__" in body_lower):
            html_dev_errors = True

        if status_code and status_code >= 500:
            failures += 1

    return ProbeOutcomeSummary(
        successes=successes,
        html_responses=html_responses,
        failures=failures,
        html_dev_errors=html_dev_errors,
        proxy_errors=proxy_errors,
    )


@dataclass
class MultiActionContext:
    probe_results: list[HttpResponse]
    control_results: list[HttpResponse] | None
    framework: str
    is_rsc_framework: bool
    cve_id: str
    invocation_expected: bool | None
    actions_confidence: str | None
    react_major: int | None
    react_version: str | None
    react_major_confidence: str | None
    react_major_conf_level: int
    react_major_conflict: bool | None
    react_major_conflict_confidence: str | None
    react_major_conflict_majors: list[int] | None
    journal: PocJournal
    control_metadata: ControlMetadata
    probe_signals: ProbeSignals
    summary: ProbeOutcomeSummary
    surface_detected: bool
    decode_surface_reached: bool | None


@dataclass
class MultiActionAnalyzer(BaseRuleInterpreter[MultiActionContext]):
    """Stateful analyzer for multi-action probe result sets."""

    framework: str = "nextjs"
    is_rsc_framework: bool = False
    cve_id: str = CVE_ID
    react_major: int | None = None
    react_version: str | None = None
    invocation_expected: bool | None = None
    invocation_confidence: str | None = None
    react_major_confidence: str | None = None
    react_major_conflict: bool | None = None
    react_major_conflict_confidence: str | None = None
    react_major_conflict_majors: list[int] | None = None
    journal: PocJournal | None = None

    def rules(self) -> list[Rule[MultiActionContext]]:
        rules = default_multi_action_rules()
        if str(self.framework or "").strip().lower() == "nextjs":
            return insert_rule(rules, _rule_nextjs_dev_overlay, after=_rule_success_path)
        return rules

    def default_decision(self, ctx: MultiActionContext) -> Decision:
        return _default_rule(ctx)

    def analyze(
        self,
        probe_results: list[HttpResponse],
        *,
        action_ids: list[str] | None = None,
        control_results: list[HttpResponse] | None = None,
    ) -> dict[str, Any]:
        journal = self.journal or get_current_journal() or PocJournal()

        def _analyze_inner() -> dict[str, Any]:
            journal.add_event(
                "analysis-start",
                "Analyzing multi-action probe responses",
                data={
                    "probes": len(probe_results),
                    "control_probes": len(control_results or []),
                    "framework": self.framework,
                    "is_rsc_framework": self.is_rsc_framework,
                    "react_version": self.react_version,
                },
            )

            failed_results = [res for res in probe_results if res.ok is False]
            if control_results:
                failed_results.extend([res for res in control_results if res.ok is False])

            total_results = len(probe_results) + len(control_results or [])
            all_failed = total_results > 0 and len(failed_results) == total_results
            if all_failed:
                # The all-failed branch returns before normal signal collection, so explicitly
                # record probe/control outcomes for visibility.
                for result in probe_results:
                    body = _response_body(result)
                    digest = extract_error_digest(str(body or ""))
                    journal.add_probe_result("proto", result.to_mapping(), digest=digest)
                for result in control_results or []:
                    body = _response_body(result)
                    digest = extract_error_digest(str(body or ""))
                    journal.add_probe_result("control", result.to_mapping(), digest=digest)
                journal.add_event(
                    "probe-error",
                    "All probes failed; returning INCONCLUSIVE",
                    data={
                        "failed_results": len(failed_results),
                    },
                )
                return _build_all_failed_result(
                    journal,
                    self.cve_id,
                    self.framework,
                    probe_results,
                    control_results,
                )

            actions_confidence = self.invocation_confidence

            invocation_expected = self.invocation_expected

            control_metadata = _collect_control_metadata(control_results, journal)
            probe_signals = _collect_probe_signals(probe_results, journal, self.react_major)
            react_major = probe_signals.react_major
            if react_major is None and control_metadata.body:
                inferred = infer_react_major_from_flight_text(control_metadata.body)
                if inferred is not None:
                    react_major = inferred
            summary = _summarize_probe_outcomes(probe_results)
            if not confidence_at_least(actions_confidence, "medium"):
                # If we have multiple comparable probes plus a control baseline with no transport noise,
                # treat the "no actions" inference as medium confidence rather than low.
                if (
                    len(probe_results) >= 2
                    and control_results
                    and summary.failures == 0
                    and summary.html_responses == 0
                    and not summary.proxy_errors
                ):
                    actions_confidence = "medium"
            surface_detected = bool(self.is_rsc_framework or probe_signals.rsc_processing or control_metadata.rsc_processing)
            react_major_confidence = self.react_major_confidence
            if react_major is not None and confidence_score(react_major_confidence) < confidence_score("medium"):
                # Flight-root inference is weaker than explicit version strings, but stronger than "unknown".
                react_major_confidence = "medium"
            react_major_conf_level = confidence_score(react_major_confidence)
            react_major_conflict = self.react_major_conflict
            react_major_conflict_confidence = self.react_major_conflict_confidence
            react_major_conflict_majors = self.react_major_conflict_majors
            decode_surface_reached: bool | None = None
            if (
                summary.successes > 0
                or probe_signals.digests
                or control_metadata.digest
                or probe_signals.rsc_processing
                or control_metadata.rsc_processing
                or probe_signals.prototype_error_hits
            ):
                decode_surface_reached = True
            elif probe_signals.validation_errors and summary.successes == 0 and summary.failures == 0:
                decode_surface_reached = False
            elif summary.html_responses > 0 and summary.successes == 0 and summary.failures == 0 and invocation_expected is True:
                decode_surface_reached = False

            ctx = MultiActionContext(
                probe_results=probe_results,
                control_results=control_results,
                framework=self.framework,
                is_rsc_framework=self.is_rsc_framework,
                cve_id=self.cve_id,
                invocation_expected=invocation_expected,
                actions_confidence=actions_confidence,
                react_major=react_major,
                react_version=self.react_version,
                react_major_confidence=react_major_confidence,
                react_major_conf_level=react_major_conf_level,
                react_major_conflict=react_major_conflict,
                react_major_conflict_confidence=react_major_conflict_confidence,
                react_major_conflict_majors=react_major_conflict_majors,
                journal=journal,
                control_metadata=control_metadata,
                probe_signals=probe_signals,
                summary=summary,
                surface_detected=surface_detected,
                decode_surface_reached=decode_surface_reached,
            )

            journal.add_event(
                "analysis-context",
                "Derived probe signals for rule evaluation",
                data={
                    "framework": ctx.framework,
                    "invocation_expected": ctx.invocation_expected,
                    "actions_confidence": ctx.actions_confidence,
                    "surface_detected": ctx.surface_detected,
                    "decode_surface_reached": ctx.decode_surface_reached,
                    "react_major": ctx.react_major,
                    "react_major_confidence": ctx.react_major_confidence,
                    "summary": {
                        "successes": ctx.summary.successes,
                        "failures": ctx.summary.failures,
                        "html_responses": ctx.summary.html_responses,
                        "html_dev_errors": ctx.summary.html_dev_errors,
                        "proxy_error_count": len(ctx.summary.proxy_errors),
                    },
                    "signals": {
                        "digests_count": len(ctx.probe_signals.digests),
                        "validation_errors_count": len(ctx.probe_signals.validation_errors),
                        "prototype_error_hits": ctx.probe_signals.prototype_error_hits,
                        "false_positive_stack_detected": ctx.probe_signals.false_positive_stack_detected,
                        "rsc_processing": ctx.probe_signals.rsc_processing,
                    },
                    "control": {
                        "status_code": ctx.control_metadata.status,
                        "digest": ctx.control_metadata.digest,
                        "rsc_processing": ctx.control_metadata.rsc_processing,
                    },
                },
            )

            if summary.proxy_errors and summary.successes == 0 and summary.failures == len(probe_signals.status_codes):
                proxy_decision = Decision(
                    PocStatus.INCONCLUSIVE,
                    "low",
                    "Probe requests failed with upstream proxy errors",
                    surface_detected=False,
                )
                return _build_proxy_error_result(ctx, proxy_decision)

            decision = self.evaluate_rules(ctx)
            applied_surface = decision.surface_detected if decision.surface_detected is not None else surface_detected

            journal.add_event(
                "rule-trace",
                "Evaluated decision rules",
                data={
                    "rules": [getattr(rule, "__name__", None) or "<unknown>" for rule in self.rules()],
                    "selected": decision.rule,
                },
            )

            return _build_decision_result(ctx, decision, applied_surface)

        with journal_context(journal):
            return _analyze_inner()


def _actions_confidence(actions_confidence: str | None) -> str:
    if confidence_at_least(actions_confidence, "high"):
        return "high"
    if confidence_at_least(actions_confidence, "medium"):
        return "medium"
    return "low"


def _react_confidence_from_level(level: int) -> str:
    if level >= confidence_score("high"):
        return "high"
    if level >= confidence_score("medium"):
        return "medium"
    return "low"


def _negative_status_from_confidence(confidence: str) -> PocStatus:
    if confidence_at_least(confidence, "high"):
        return PocStatus.NOT_VULNERABLE
    if confidence_at_least(confidence, "medium"):
        return PocStatus.LIKELY_NOT_VULNERABLE
    return PocStatus.INCONCLUSIVE


def _align_status_with_confidence(status: PocStatus, confidence: str) -> PocStatus:
    if confidence == "low":
        return PocStatus.INCONCLUSIVE
    if confidence == "medium":
        if status == PocStatus.VULNERABLE:
            return PocStatus.LIKELY_VULNERABLE
        if status == PocStatus.NOT_VULNERABLE:
            return PocStatus.LIKELY_NOT_VULNERABLE
        if status == PocStatus.NOT_APPLICABLE:
            return PocStatus.INCONCLUSIVE
    return status


def _not_applicable_or_inconclusive(confidence: str, reason: str, *, surface_detected: bool | None = None) -> Decision:
    if confidence_at_least(confidence, "high"):
        return Decision(PocStatus.NOT_APPLICABLE, "high", reason, surface_detected=surface_detected)
    return Decision(
        PocStatus.INCONCLUSIVE,
        "low",
        reason,
        surface_detected=surface_detected,
    )


def _rule_server_actions_missing(ctx: MultiActionContext) -> Decision | None:
    if ctx.invocation_expected is not False or ctx.summary.successes != 0:
        return None

    feature = invocation_feature_label(ctx.framework)
    if ctx.is_rsc_framework and ctx.probe_signals.digests:
        # Conflicting signals: we expected "no actions", but we still observed RSC digests.
        # This can happen with wrong endpoints, intermediate error pages, or framework heuristics.
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            f"RSC error digests observed despite missing {feature} signal; unable to reconcile Flight protocol payload deserialization reachability",
            surface_detected=True,
        )

    confidence = _actions_confidence(ctx.actions_confidence)
    if confidence == "low" and ctx.is_rsc_framework:
        confidence = "medium"
    status = _negative_status_from_confidence(confidence)
    return Decision(
        status,
        confidence,
        f"{feature} not detected; Flight protocol payload deserialization not reachable on tested endpoints",
        surface_detected=ctx.surface_detected,
    )


def _rule_rsc_validation_without_success(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.failures != 0 or ctx.summary.successes != 0:
        return None
    if not (ctx.probe_signals.validation_errors and ctx.is_rsc_framework):
        return None

    feature = invocation_feature_label(ctx.framework)
    if ctx.invocation_expected is True and ctx.framework != "nextjs":
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            f"{feature} validation rejected synthetic IDs (4xx action-not-found) before Flight protocol payload deserialization",
            surface_detected=True,
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        f"{feature} validation rejected synthetic IDs (4xx action-not-found) before Flight protocol payload deserialization",
        surface_detected=True,
    )


def _rule_html_only_responses(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.html_responses == 0 or ctx.summary.successes != 0 or ctx.summary.failures != 0:
        return None

    feature = invocation_feature_label(ctx.framework)
    if ctx.invocation_expected is False:
        confidence = _actions_confidence(ctx.actions_confidence)
        status = _negative_status_from_confidence(confidence)
        return Decision(
            status,
            confidence,
            f"{feature} not detected; HTML-only responses suggest Flight protocol payload deserialization is not reachable on tested endpoints",
            surface_detected=ctx.surface_detected,
        )

    # HTML-only responses while a Flight protocol payload deserializing endpoint is expected
    # (often exposed via Server Actions/Server Functions) are FN-prone
    # (wrong route/auth/dev overlay).
    if ctx.invocation_expected is True or ctx.is_rsc_framework:
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            f"Expected Flight protocol payload deserialization (based on RSC and {feature} hints), but probes returned only HTML; endpoint may be blocked or incorrect",
            surface_detected=ctx.surface_detected,
        )
    return Decision(
        _negative_status_from_confidence(_actions_confidence(ctx.actions_confidence)),
        _actions_confidence(ctx.actions_confidence),
        "All responses returned HTML (no RSC Flight); no Flight protocol payload deserialization observed on tested endpoints",
        surface_detected=False,
    )


def _rule_success_path(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.successes == 0:
        return None

    if ctx.control_metadata.status == 200 and ctx.summary.failures == 0:
        return Decision(
            PocStatus.NOT_VULNERABLE,
            "high",
            "Proto and control probes both succeeded (action processing reached)",
        )

    feature = invocation_feature_label(ctx.framework)
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        f"{feature} processing returned 200 responses for proto probes",
    )


def _rule_safe_args_no_invoke(ctx: MultiActionContext) -> Decision | None:
    """
    Safe-probing mode: requests use a "no-invoke args" container (BigInt length) to prevent
    server function execution even when action IDs are valid.

    Interpretation is inverted vs normal probes:
    - proto matches control baseline => traversal likely reachable => (likely) vulnerable
    - proto diverges from control baseline => traversal likely blocked before invocation => (likely) not vulnerable
    """

    def _uses_safe_args_strategy(results: list[HttpResponse] | None) -> bool:
        for res in results or []:
            meta = getattr(res, "payload_meta", None) or {}
            if isinstance(meta, dict) and meta.get("probe_strategy") == SAFE_ARGS_STRATEGY:
                return True
        return False

    if not (_uses_safe_args_strategy(ctx.control_results) or _uses_safe_args_strategy(ctx.probe_results)):
        return None

    if not (ctx.control_results and ctx.probe_results):
        return None

    # If any probe succeeded (Flight/JSON 200), the "no-invoke" assumption did not hold.
    # Defer to the standard success-path / error-path rules instead of inferring vulnerability.
    if ctx.summary.successes > 0:
        return None

    if ctx.react_major is not None and ctx.react_major != 19 and not _react19_possible(ctx):
        confidence = _react_confidence_from_level(ctx.react_major_conf_level)
        return _not_applicable_or_inconclusive(
            confidence,
            f"No-invoke args probes observed but React {ctx.react_major}.x (React2Shell requires React 19.x)",
            surface_detected=ctx.surface_detected,
        )

    def _fingerprint(res: HttpResponse) -> tuple[str, str] | None:
        body = _response_body(res)
        digest = extract_error_digest(body)
        if digest:
            return ("digest", digest)
        struct = _body_structure_hash(body)
        if struct:
            return ("struct", struct)
        header = _header_signature(_response_headers(res))
        if header:
            return ("header", header)
        return None

    ctrl_fp = _fingerprint(ctx.control_results[0]) if ctx.control_results else None
    if ctrl_fp is None:
        return None

    proto_fps = [_fingerprint(res) for res in ctx.probe_results]
    proto_fps_present = [fp for fp in proto_fps if fp is not None]
    if not proto_fps_present:
        return None

    required = max(1, len(proto_fps_present) // 2 + 1)
    matches = sum(fp == ctrl_fp for fp in proto_fps_present)

    if matches >= required:
        ctrl_body = _response_body(ctx.control_results[0]) if ctx.control_results else ""
        ctrl_body_norm = str(ctrl_body or "").strip().lower()
        generic_error_bodies = {"internal server error", "internal error", "server error"}
        if ctrl_fp[0] != "digest":
            if "invalid reference" in ctrl_body_norm or "invalid server reference" in ctrl_body_norm:
                return Decision(
                    PocStatus.LIKELY_NOT_VULNERABLE,
                    "medium",
                    "No-invoke args probes matched on an explicit reference-validation error; traversal likely blocked before deserialization",
                    surface_detected=ctx.surface_detected,
                )
            decode_evidence = bool(
                ctx.decode_surface_reached is True
                and (
                    ctx.control_metadata.rsc_processing
                    or ctx.probe_signals.rsc_processing
                    or ctx.control_metadata.digest
                    or ctx.probe_signals.digests
                )
            )
            version_hint = is_react_version_vulnerable(ctx.react_version)
            low_signal_match = ctrl_body_norm in generic_error_bodies
            if not decode_evidence or low_signal_match:
                if version_hint is False:
                    return Decision(
                        PocStatus.LIKELY_NOT_VULNERABLE,
                        "medium",
                        "No-invoke args probes matched without digest-level evidence; detected React runtime version appears patched",
                        surface_detected=ctx.surface_detected,
                    )
                if version_hint is True and ctx.invocation_expected is True:
                    return Decision(
                        PocStatus.LIKELY_VULNERABLE,
                        "medium",
                        "No-invoke args probes matched without digest-level evidence; React runtime version appears vulnerable",
                        surface_detected=ctx.surface_detected,
                    )
                return Decision(
                    PocStatus.INCONCLUSIVE,
                    "low",
                    "No-invoke args probes matched without digest-level evidence; Flight decode reachability is unclear",
                    surface_detected=ctx.surface_detected,
                )
            return Decision(
                PocStatus.LIKELY_VULNERABLE if ctx.invocation_expected is True else PocStatus.INCONCLUSIVE,
                "medium" if ctx.invocation_expected is True else "low",
                "No-invoke args probes matched without digests but decode evidence is present; reachability remains uncertain",
                surface_detected=ctx.surface_detected,
            )

        status = PocStatus.VULNERABLE if ctx.invocation_expected is True else PocStatus.LIKELY_VULNERABLE
        confidence = "high" if ctrl_fp[0] == "digest" and ctx.invocation_expected is True else "medium"
        return Decision(
            status,
            confidence,
            "No-invoke args baseline matched between proto and control (decode reached invocation boundary; traversal may be reachable)",
            surface_detected=ctx.surface_detected,
        )

    if ctrl_fp[0] != "digest":
        decode_evidence = bool(
            ctx.decode_surface_reached is True
            and (
                ctx.control_metadata.rsc_processing
                or ctx.probe_signals.rsc_processing
                or ctx.control_metadata.digest
                or ctx.probe_signals.digests
            )
        )
        if not decode_evidence:
            return Decision(
                PocStatus.INCONCLUSIVE,
                "low",
                "No-invoke args baseline diverged without digest-level evidence; Flight decode reachability is unclear",
                surface_detected=ctx.surface_detected,
            )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "No-invoke args baseline diverged between proto and control (decode failed before invocation; traversal likely blocked)",
        surface_detected=ctx.surface_detected,
    )


def _rule_nextjs_dev_overlay(ctx: MultiActionContext) -> Decision | None:
    if ctx.framework != "nextjs" or not ctx.summary.html_dev_errors or ctx.summary.successes != 0:
        return None

    all_bodies = [_response_body(res) for res in ctx.probe_results]
    all_bodies_same = bool(ctx.control_metadata.body) and all(body == ctx.control_metadata.body for body in all_bodies)
    dev_overlay_signatures = (
        "module not found",
        "webpack",
        "next/dist/build/webpack/plugins",
        "__next_error__",
    )
    dev_overlay_hit = ctx.control_metadata.body and any(sig in ctx.control_metadata.body.lower() for sig in dev_overlay_signatures)

    has_html_200 = any(
        (res.status_code == 200) and ("<html" in _response_body(res).lower()) for res in ctx.probe_results + (ctx.control_results or [])
    )

    dev_overlay_short_circuit = dev_overlay_hit and all_bodies_same and not ctx.probe_signals.digests and not ctx.probe_signals.rsc_processing

    if has_html_200 and dev_overlay_hit:
        return Decision(
            PocStatus.NOT_VULNERABLE,
            "high",
            "Next.js dev overlay returned 200 HTML for proto/control; no RSC Flight response observed",
        )
    if dev_overlay_short_circuit:
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Next.js dev overlay returned identical HTML for proto/control without RSC digests - treating as validation short-circuit",
        )

    if all_bodies_same or (ctx.control_metadata.body and not ctx.control_metadata.digest and ctx.summary.html_dev_errors):
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "Next.js dev overlay returned identical HTML on action probes (possible vulnerable dev path)",
        )

    if ctx.react_major is not None and ctx.react_major < 19 and not _react19_possible(ctx):
        confidence = _react_confidence_from_level(ctx.react_major_conf_level)
        return _not_applicable_or_inconclusive(
            confidence,
            "Next.js dev overlay returned HTML without RSC; React <19 (React2Shell requires React 19.x)",
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Next.js dev error page returned HTML 5xx on action probes (dev overlay on action path)",
    )


def _rule_multiple_digests(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_signals.digests) <= 1:
        return None

    if ctx.react_major is not None and ctx.react_major != 19 and not _react19_possible(ctx):
        confidence = _react_confidence_from_level(ctx.react_major_conf_level)
        return _not_applicable_or_inconclusive(
            confidence,
            f"Multiple error digests observed but React {ctx.react_major}.x (React2Shell requires React 19.x)",
            surface_detected=ctx.surface_detected,
        )

    if ctx.invocation_expected is True:
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "Proto probes returned multiple distinct error digests while actions were expected; divergent error paths possible",
        )
    if ctx.invocation_expected is False and not ctx.is_rsc_framework:
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Multiple digests on non-RSC surface without actions signal - treating as ambiguous/non-action",
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Proto probes returned multiple distinct error digests without clear Flight protocol payload deserialization evidence; likely validation or non-action differences",
    )


def _rule_single_digest_failure(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_signals.digests) != 1 or ctx.summary.failures < 2 or ctx.summary.successes != 0:
        return None

    proto_digest = list(ctx.probe_signals.digests)[0]
    if not proto_digest:
        return None
    react_info = f" (React {ctx.react_major})" if ctx.react_major else ""
    control_matches_proto = ctx.control_metadata.status == 500 and ctx.control_metadata.digest == proto_digest
    control_diverges = ctx.control_metadata.status == 200 or (
        ctx.control_metadata.status == 500 and ctx.control_metadata.digest is not None and ctx.control_metadata.digest != proto_digest
    )

    if control_diverges:
        if ctx.control_metadata.status == 200:
            return Decision(
                PocStatus.VULNERABLE,
                "high",
                f"Control succeeded (200) while proto probe fails with digest {proto_digest[:16]}... - prototype traversal triggered an error{react_info}",
            )
        control_digest = ctx.control_metadata.digest
        if not control_digest:
            return None
        return Decision(
            PocStatus.VULNERABLE,
            "high" if ctx.invocation_expected is True else "medium",
            f"Proto and control probes fail with different digests ({proto_digest[:12]}... vs {control_digest[:12]}...) - different error paths{react_info}",
        )

    if control_matches_proto:
        all_bodies = [_response_body(res) for res in ctx.probe_results]
        has_patched_error = any(any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS) for body in all_bodies)
        if has_patched_error:
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "Proto and control probes share the same digest and include action validation errors; likely validation short-circuit",
            )
        if ctx.react_major is not None and ctx.react_major != 19 and not _react19_possible(ctx):
            confidence = _react_confidence_from_level(ctx.react_major_conf_level)
            return _not_applicable_or_inconclusive(
                confidence,
                f"React {ctx.react_major}.x with identical proto/control failures (React2Shell requires React 19.x)",
                surface_detected=ctx.is_rsc_framework or ctx.probe_signals.rsc_processing,
            )
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Proto and control probes fail identically - no behavioral difference attributable to prototype traversal",
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        f"All {ctx.summary.failures} probes failed with identical digest - RSC deserialization error{react_info}",
    )


def _rule_structural_divergence(ctx: MultiActionContext) -> Decision | None:
    if ctx.probe_signals.digests or ctx.control_metadata.digest:
        return None
    if ctx.decode_surface_reached is not True:
        return None
    if not ctx.control_metadata.rsc_processing:
        return None

    total_probes = len(ctx.probe_results)
    if total_probes < 2:
        return None

    ctrl_structure = ctx.control_metadata.structure_hash
    ctrl_header = ctx.control_metadata.header_signature
    ctrl_len = ctx.control_metadata.content_length
    if not ctrl_structure and not ctrl_header:
        return None

    errorish = any((code or 0) >= 400 for code in ctx.probe_signals.status_codes)
    if not errorish and ctx.summary.failures == 0:
        return None

    required = max(2, total_probes // 2 + 1)
    struct_diff_count = 0
    header_diff_count = 0
    length_diff_count = 0
    probe_struct_hashes: list[str | None] = []

    for result in ctx.probe_results:
        body = _response_body(result)
        struct_hash = _body_structure_hash(body)
        header_sig = _header_signature(_response_headers(result))
        probe_struct_hashes.append(struct_hash)

        if ctrl_structure and struct_hash and struct_hash != ctrl_structure:
            struct_diff_count += 1
        if ctrl_header and header_sig and header_sig != ctrl_header:
            header_diff_count += 1
        if ctrl_len is not None and body:
            if abs(len(body) - ctrl_len) > max(64, int(ctrl_len * 0.3)):
                length_diff_count += 1

    if ctrl_structure:
        if struct_diff_count < required:
            return None
        # Require a stable non-control fingerprint across proto probes to avoid noise-driven divergence.
        non_control_hashes = [h for h in probe_struct_hashes if h and h != ctrl_structure]
        if len(non_control_hashes) < required:
            return None
        most_common = max(Counter(non_control_hashes).values(), default=0)
        if most_common < required:
            return None
    else:
        # Without a control structure fingerprint, require corroboration from both headers and body length.
        if ctrl_len is None or header_diff_count < required or length_diff_count < required:
            return None

    confidence = "high" if ctx.invocation_expected else "medium"
    status = PocStatus.VULNERABLE if ctx.invocation_expected else PocStatus.LIKELY_VULNERABLE
    reason = "Proto responses structurally diverged from control (locale-agnostic fingerprint)"
    return Decision(status, confidence, reason, surface_detected=ctx.surface_detected)


def _rule_server_actions_error_path(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.invocation_expected and ctx.is_rsc_framework and ctx.summary.failures > 0 and ctx.summary.successes == 0):
        return None

    feature = invocation_feature_label(ctx.framework)
    # Let prototype-error rules speak first when we have explicit TypeError/prototype indicators.
    if ctx.probe_signals.prototype_error_hits and not ctx.probe_signals.false_positive_stack_detected:
        return None

    def _control_matches_proto_failures() -> bool:
        if not (ctx.control_metadata.status and ctx.control_metadata.status >= 500):
            return False

        ctrl_struct = ctx.control_metadata.structure_hash
        ctrl_header = ctx.control_metadata.header_signature
        if not ctrl_struct and not ctrl_header:
            return False

        matches = 0
        comparable = 0
        for result in ctx.probe_results:
            status_code = result.status_code
            if not (status_code and status_code >= 500):
                continue
            body = _response_body(result)
            struct_hash = _body_structure_hash(body) if body else None
            header_sig = _header_signature(_response_headers(result))

            # Prefer structure-hash matches when available; fall back to header-signature matches.
            if ctrl_struct and struct_hash:
                comparable += 1
                if struct_hash == ctrl_struct:
                    matches += 1
                continue
            if ctrl_header and header_sig:
                comparable += 1
                if header_sig == ctrl_header:
                    matches += 1
                continue

        if comparable == 0:
            return False
        return matches >= comparable

    if ctx.framework == "nextjs":
        proto_bodies = [_response_body(res) for res in ctx.probe_results]
        validation_on_action_path = any(
            any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS) for body in proto_bodies + ([ctx.control_metadata.body] if ctx.control_metadata.body else [])
        )
        if validation_on_action_path:
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                f"{feature} probes hit validation messaging without RSC digests; likely validated before Flight protocol payload deserialization",
            )
        if _control_matches_proto_failures():
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "Proto/control probes both produced similar 5xx responses without RSC digests - likely app error path (no proto-specific behavior)",
                surface_detected=ctx.surface_detected,
            )
        if ctx.react_major is not None and ctx.react_major < 19 and not _react19_possible(ctx):
            confidence = _react_confidence_from_level(ctx.react_major_conf_level)
            return _not_applicable_or_inconclusive(
                confidence,
                f"{feature} errors without RSC Flight/digests; React <19 (React2Shell requires React 19.x)",
            )
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            f"{feature} expected; 5xx responses without RSC digests (possible dev/HTML wrapper; Flight protocol payload deserialization reachability unclear)",
        )

    if ctx.framework in {"expo", "react-router"} and ctx.probe_signals.error_messages:
        error_messages_lower = {msg.lower() for msg in ctx.probe_signals.error_messages if msg}
        if any("invalid reference" in msg for msg in error_messages_lower):
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                f"{feature} probes returned 'Invalid reference' without RSC digests; likely validation before Flight protocol payload deserialization",
                surface_detected=ctx.surface_detected,
            )

    if _control_matches_proto_failures():
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Proto/control probes both produced similar 5xx responses without RSC digests - likely app error path (no proto-specific behavior)",
            surface_detected=ctx.surface_detected,
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        f"{feature} expected; 5xx responses without RSC digests (possible dev/HTML wrapper; Flight protocol payload deserialization reachability unclear)",
    )


def _rule_single_probe_guard(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_results) != 1:
        return None

    # Validation errors on a non-RSC surface are meaningful even with a single probe.
    if ctx.probe_signals.validation_errors and not ctx.is_rsc_framework:
        return None

    return Decision(
        PocStatus.INCONCLUSIVE,
        "low",
        "Only one probe result available; need multiple actions to compare",
    )


def _rule_prototype_errors(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.probe_signals.prototype_error_hits and not ctx.probe_signals.false_positive_stack_detected):
        return None

    if (ctx.probe_signals.rsc_processing or ctx.is_rsc_framework) and (ctx.summary.failures > 0 or ctx.invocation_expected):
        confidence = "high" if ctx.summary.failures > 0 else "medium"
        return Decision(
            PocStatus.VULNERABLE,
            confidence,
            "Prototype-related errors observed in RSC probe responses (Flight protocol payload deserialization hit)",
        )
    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Prototype-related errors observed in probe responses",
    )


def _rule_validation_non_rsc(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.probe_signals.validation_errors and not ctx.is_rsc_framework):
        return None
    return Decision(
        PocStatus.NOT_VULNERABLE,
        "high",
        "Action validation errors on non-RSC surface (likely SPA)",
        surface_detected=False,
    )


def _rule_error_messages(ctx: MultiActionContext) -> Decision | None:
    if not ctx.probe_signals.error_messages:
        return None
    if len(ctx.probe_signals.error_messages) == 1:
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            "Single plain-text error response; unable to determine behavior",
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Multiple distinct plain-text error responses; no stable digest/Flight signal - treating as likely not vulnerable",
    )


def _rule_rsc_processing_only(ctx: MultiActionContext) -> Decision | None:
    if not ctx.probe_signals.rsc_processing:
        return None
    return Decision(
        PocStatus.INCONCLUSIVE,
        "low",
        "RSC Flight processing detected but behavior inconclusive",
    )


def _default_rule(ctx: MultiActionContext) -> Decision:
    feature = invocation_feature_label(ctx.framework)

    # If we expected a reachable Flight protocol payload deserializing endpoint (often branded as
    # "Server Actions" or "Server Functions") but observed no RSC Flight/deserialization signals at all,
    # treat this as inconclusive (FN-prone: wrong route, auth, WAF, etc.).
    if ctx.invocation_expected is True or ctx.is_rsc_framework:
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            f"No RSC Flight or Flight protocol payload deserialization observed on tested endpoints despite expected {feature} hints",
            surface_detected=ctx.surface_detected,
        )

    # Otherwise this is a missing-surface conclusion.
    confidence = _actions_confidence(ctx.actions_confidence)
    return Decision(
        PocStatus.NOT_VULNERABLE,
        confidence,
        "No RSC Flight or Flight protocol payload deserialization observed on tested endpoints",
        surface_detected=False,
    )


_DEFAULT_MULTI_ACTION_RULES: tuple[Rule[MultiActionContext], ...] = (
    _rule_server_actions_missing,
    _rule_rsc_validation_without_success,
    _rule_html_only_responses,
    _rule_safe_args_no_invoke,
    _rule_success_path,
    _rule_multiple_digests,
    _rule_single_digest_failure,
    _rule_structural_divergence,
    _rule_server_actions_error_path,
    _rule_single_probe_guard,
    _rule_prototype_errors,
    _rule_validation_non_rsc,
    _rule_error_messages,
    _rule_rsc_processing_only,
    _default_rule,
)


def default_multi_action_rules() -> list[Rule[MultiActionContext]]:
    """Return the default rule chain for multi-action interpreters."""
    return list(_DEFAULT_MULTI_ACTION_RULES)


def insert_rule(
    rules: list[Rule[MultiActionContext]],
    rule: Rule[MultiActionContext],
    *,
    after: Rule[MultiActionContext] | None = None,
    before: Rule[MultiActionContext] | None = None,
) -> list[Rule[MultiActionContext]]:
    """Insert a rule relative to another rule without mutating the input list."""
    out = list(rules)
    if rule in out:
        return out
    if after and after in out:
        out.insert(out.index(after) + 1, rule)
        return out
    if before and before in out:
        out.insert(out.index(before), rule)
        return out
    out.append(rule)
    return out


def _build_decision_result(ctx: MultiActionContext, decision: Decision, surface_detected: bool) -> dict[str, Any]:
    confidence = _apply_react_major_conflict_penalty(ctx, decision.confidence)
    status = _align_status_with_confidence(decision.status, confidence)
    ctx.journal.add_decision(status, decision.reason, rule=decision.rule)
    return {
        "status": status,
        "details": {
            "cve_id": ctx.cve_id,
            "confidence": confidence,
            "reason": decision.reason,
            "decision_rule": decision.rule,
            "framework": ctx.framework,
            "is_rsc_framework": ctx.is_rsc_framework,
            "invocation_expected": ctx.invocation_expected,
            "actions_confidence": ctx.actions_confidence,
            "react_major": ctx.react_major,
            "react_major_confidence": ctx.react_major_confidence,
            "react_major_conflict": ctx.react_major_conflict,
            "react_major_conflict_confidence": ctx.react_major_conflict_confidence,
            "react_major_conflict_majors": ctx.react_major_conflict_majors,
            "surface_detected": surface_detected,
            "decode_surface_reached": ctx.decode_surface_reached,
            "proto_digests": sorted(ctx.probe_signals.digests),
            "control_digest": ctx.control_metadata.digest,
            "evidence": {
                "probe_count": len(ctx.probe_results),
                "control_count": len(ctx.control_results or []),
                "summary": {
                    "successes": ctx.summary.successes,
                    "failures": ctx.summary.failures,
                    "html_responses": ctx.summary.html_responses,
                    "html_dev_errors": ctx.summary.html_dev_errors,
                    "proxy_error_count": len(ctx.summary.proxy_errors),
                },
                "signals": {
                    "digests_count": len(ctx.probe_signals.digests),
                    "validation_errors_count": len(ctx.probe_signals.validation_errors),
                    "prototype_error_hits": ctx.probe_signals.prototype_error_hits,
                    "false_positive_stack_detected": ctx.probe_signals.false_positive_stack_detected,
                    "rsc_processing": ctx.probe_signals.rsc_processing,
                },
                "control": {
                    "status_code": ctx.control_metadata.status,
                    "digest": ctx.control_metadata.digest,
                    "rsc_processing": ctx.control_metadata.rsc_processing,
                },
            },
        },
        "raw_data": {
            "probe_results": _response_mappings(ctx.probe_results),
            "control_results": _response_mappings(ctx.control_results),
            "journal": ctx.journal.to_list(),
        },
    }


def _build_all_failed_result(
    journal: PocJournal,
    cve_id: str,
    framework: str,
    probe_results: list[HttpResponse],
    control_results: list[HttpResponse] | None,
) -> dict[str, Any]:
    reason = "Probe requests failed after retries; network state unknown"
    journal.add_decision(PocStatus.INCONCLUSIVE, reason, rule="all_probes_failed")
    return {
        "status": PocStatus.INCONCLUSIVE,
        "details": {
            "cve_id": cve_id,
            "confidence": "low",
            "reason": reason,
            "decision_rule": "all_probes_failed",
            "framework": framework,
            "probes_sent": len(probe_results),
            "control_sent": len(control_results or []),
            "surface_detected": False,
            "decode_surface_reached": None,
        },
        "raw_data": {
            "probe_results": _response_mappings(probe_results),
            "control_results": _response_mappings(control_results),
            "journal": journal.to_list(),
        },
    }


def _build_proxy_error_result(ctx: MultiActionContext, decision: Decision) -> dict[str, Any]:
    ctx.journal.add_decision(decision.status, decision.reason, rule=decision.rule or "proxy_error")
    return {
        "status": decision.status,
        "details": {
            "cve_id": ctx.cve_id,
            "confidence": decision.confidence,
            "reason": decision.reason,
            "decision_rule": decision.rule or "proxy_error",
            "framework": ctx.framework,
            "surface_detected": decision.surface_detected,
            "decode_surface_reached": ctx.decode_surface_reached,
        },
        "raw_data": {
            "probe_results": _response_mappings(ctx.probe_results),
            "control_results": _response_mappings(ctx.control_results),
            "journal": ctx.journal.to_list(),
        },
    }


def analyze_multi_action_results(
    probe_results: list[HttpResponse],
    action_ids: list[str] | None = None,
    framework: str = "nextjs",
    is_rsc_framework: bool = False,
    cve_id: str = CVE_ID,
    control_results: list[HttpResponse] | None = None,
    react_major: int | None = None,
    react_version: str | None = None,
    invocation_expected: bool | None = None,
    invocation_confidence: str | None = None,
    react_major_confidence: str | None = None,
    react_major_conflict: bool | None = None,
    react_major_conflict_confidence: str | None = None,
    react_major_conflict_majors: list[int] | None = None,
    journal: PocJournal | None = None,
) -> dict[str, Any]:
    analyzer_cls: type[MultiActionAnalyzer] = MultiActionAnalyzer
    normalized_framework = str(framework or "").strip().lower()
    if normalized_framework == "nextjs":
        from .nextjs_interpreter import NextjsInterpreter

        analyzer_cls = NextjsInterpreter
    elif normalized_framework == "expo":
        from .expo_interpreter import ExpoInterpreter

        analyzer_cls = ExpoInterpreter
    elif normalized_framework in {"react-router", "react_router"}:
        from .react_router_interpreter import ReactRouterInterpreter

        analyzer_cls = ReactRouterInterpreter
    elif normalized_framework in {"rsc", "generic-rsc", "generic_rsc"}:
        from .generic_rsc_interpreter import GenericRscInterpreter

        analyzer_cls = GenericRscInterpreter

    analyzer = analyzer_cls(
        framework=framework,
        is_rsc_framework=is_rsc_framework,
        cve_id=cve_id,
        react_major=react_major,
        react_version=react_version,
        invocation_expected=invocation_expected,
        invocation_confidence=invocation_confidence,
        react_major_confidence=react_major_confidence,
        react_major_conflict=react_major_conflict,
        react_major_conflict_confidence=react_major_conflict_confidence,
        react_major_conflict_majors=react_major_conflict_majors,
        journal=journal,
    )
    return analyzer.analyze(
        probe_results,
        action_ids=action_ids,
        control_results=control_results,
    )
