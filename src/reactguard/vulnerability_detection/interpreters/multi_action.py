# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Multi-action result interpreter for CVE-2025-55182."""

import hashlib
import re
from collections import Counter
from dataclasses import dataclass
from typing import Any

from ...framework_detection.constants import SERVER_ACTIONS_RSC_CONTENT_TYPE
from ...http.headers import header_value
from ...models.poc import PocStatus
from ...rsc.payloads import SAFE_ARGS_STRATEGY
from ...utils.confidence import confidence_at_least, confidence_score
from ...utils.react_major import (
    apply_react_major_conflict_penalty,
    infer_react_major_from_flight_text,
    react19_possible,
)
from ...utils.version import is_react_version_vulnerable
from ..constants import ERROR_BODY_SNIPPET_LIMIT, SMALL_BODY_LENGTH
from ..journal import PocJournal, get_current_journal, journal_context
from .base import BaseRuleInterpreter, Decision, Rule
from .digest import ERROR_DIGEST_PATTERN

# CVE constants
CVE_ID = "CVE-2025-55182"

# Patched behavior signatures - action validation happens BEFORE deserialization
PATCHED_ERROR_PATTERNS = [
    "action not found",
    "invalid action",
    "unknown action",
    "action id not found",
    "no server action found",
    "server action not found",
]

# Vulnerable behavior signatures - prototype pollution occurred during deserialization
VULN_ERROR_PATTERNS = [
    "cannot read properties of null",
    "cannot read properties of undefined",
    "action error:",
    "reading 'id'",
    "reading 'workers'",
    "reading 'constructor'",
    "prototype",
]
VULN_ERROR_REGEX_PATTERNS = [
    re.compile(r'"name"\s*:\s*"typeerror"', re.IGNORECASE),
    re.compile(r"typeerror", re.IGNORECASE),
    re.compile(r"processticksandrejections", re.IGNORECASE),
]

NEXTJS_FALSE_POSITIVE_STACK_PATTERNS = [
    "action-handler.js",
]

RSC_FLIGHT_PATTERN_V19 = '0:{"a":"$@1"'
RSC_FLIGHT_PATTERN_ARRAY = '0:["$@1",'
RSC_GENERIC_FLIGHT_LINE_RE = re.compile(r"^\d+:(?:I\[|\[|\{)", re.MULTILINE)

def _body_structure_hash(body: str) -> str | None:
    if not body:
        return None
    structure = re.sub(r'"[^"]*"', '"S"', body)
    structure = re.sub(r"'[^']*'", "'S'", structure)
    structure = re.sub(r"\b\d+\b", "N", structure)
    structure = re.sub(r"\s+", "", structure)
    if not structure:
        return None
    return hashlib.sha256(structure.encode()).hexdigest()[:16]


def _react19_possible(ctx: "MultiActionContext") -> bool:
    return react19_possible(
        react_major=ctx.react_major,
        react_major_confidence=ctx.react_major_confidence,
        react_version=ctx.react_version,
        react_major_conflict=ctx.react_major_conflict,
        react_major_conflict_majors=ctx.react_major_conflict_majors,
    )


def _apply_react_major_conflict_penalty(ctx: "MultiActionContext", confidence: str) -> str:
    return apply_react_major_conflict_penalty(
        confidence,
        react_major_conflict=ctx.react_major_conflict,
        react_major_conflict_confidence=ctx.react_major_conflict_confidence,
    )


def _header_signature(headers: dict[str, Any] | None) -> str | None:
    if not headers:
        return None
    keys = [str(k).lower() for k in headers.keys() if k is not None]
    if not keys:
        return None
    normalized = ",".join(sorted(keys))
    return hashlib.sha256(normalized.encode()).hexdigest()[:8]


@dataclass
class ControlMetadata:
    status: int | None
    digest: str | None
    body: str
    structure_hash: str | None
    header_signature: str | None
    content_length: int | None
    rsc_processing: bool


@dataclass
class ProbeSignals:
    digests: set[str]
    error_messages: set[str]
    validation_errors: list[str]
    status_codes: list[int | None]
    prototype_error_hits: bool
    rsc_processing: bool
    false_positive_stack_detected: bool
    react_major: int | None
    structure_hashes: set[str]
    header_signatures: set[str]
    content_lengths: list[int | None]


@dataclass
class ProbeOutcomeSummary:
    successes: int
    html_responses: int
    failures: int
    html_dev_errors: bool
    proxy_errors: list[dict[str, Any]]


def _trim_body(body: str) -> str:
    return body.strip()[:ERROR_BODY_SNIPPET_LIMIT]


def _collect_control_metadata(control_results: list[dict[str, Any]] | None, journal: PocJournal) -> ControlMetadata:
    status = None
    digest = None
    body = ""
    structure_hash = None
    header_signature = None
    content_length = None
    rsc_processing = False

    if control_results:
        for ctrl in control_results:
            status = ctrl.get("status_code") if ctrl.get("status_code") is not None else status
            ctrl_body = ctrl.get("body") or ctrl.get("body_snippet", "")
            ctrl_digest_match = ERROR_DIGEST_PATTERN.search(ctrl_body)
            ctrl_digest = ctrl_digest_match.group(1) if ctrl_digest_match else None
            digest = ctrl_digest or digest
            structure_hash = _body_structure_hash(ctrl_body) or structure_hash
            header_signature = header_signature or _header_signature(ctrl.get("headers"))
            content_length = content_length if content_length is not None else (len(ctrl_body) if ctrl_body else None)
            if ctrl_body and not body:
                body = ctrl_body

            content_type = header_value(ctrl.get("headers") or {}, "content-type").lower()
            if (
                SERVER_ACTIONS_RSC_CONTENT_TYPE in content_type
                or RSC_FLIGHT_PATTERN_V19 in ctrl_body
                or RSC_FLIGHT_PATTERN_ARRAY in ctrl_body
                or RSC_GENERIC_FLIGHT_LINE_RE.search(ctrl_body)
            ):
                rsc_processing = True
            journal.add_probe(
                "control",
                action_id=ctrl.get("action_id") or ctrl.get("action_name"),
                status_code=status,
                body_snippet=ctrl_body,
                headers=ctrl.get("headers", {}),
                digest=ctrl_digest,
            )

    return ControlMetadata(
        status=status,
        digest=digest,
        body=body,
        structure_hash=structure_hash,
        header_signature=header_signature,
        content_length=content_length,
        rsc_processing=rsc_processing,
    )


def _collect_probe_signals(
    probe_results: list[dict[str, Any]],
    journal: PocJournal,
    react_major: int | None,
) -> ProbeSignals:
    digests: set[str] = set()
    error_messages: set[str] = set()
    validation_errors: list[str] = []
    status_codes: list[int | None] = []
    prototype_error_hits = False
    rsc_processing = False
    false_positive_stack_detected = False
    structure_hashes: set[str] = set()
    header_signatures: set[str] = set()
    content_lengths: list[int | None] = []
    inferred_majors: set[int] = set()

    for result in probe_results:
        body = result.get("body") or result.get("body_snippet", "")
        status_code = result.get("status_code")
        status_codes.append(status_code)

        digest_match = ERROR_DIGEST_PATTERN.search(body)
        digest = digest_match.group(1) if digest_match else None
        if digest:
            digests.add(digest)
        journal.add_probe(
            "proto",
            action_id=result.get("action_id") or result.get("action_name"),
            endpoint=result.get("endpoint"),
            status_code=status_code,
            body_snippet=body,
            headers=result.get("headers", {}),
            digest=digest,
        )

        if status_code == 500 and len(body) < SMALL_BODY_LENGTH:
            if not body.startswith(("<!doctype", "<html", "0:", "1:")) and body.strip():
                error_messages.add(_trim_body(body))

        if status_code in (400, 404, 405) and len(body) < SMALL_BODY_LENGTH:
            body_lower = body.lower()
            if any(pattern in body_lower for pattern in PATCHED_ERROR_PATTERNS):
                validation_errors.append(_trim_body(body))

        body_lower = body.lower()
        is_false_positive_stack = any(pattern in body_lower for pattern in NEXTJS_FALSE_POSITIVE_STACK_PATTERNS)
        false_positive_stack_detected = false_positive_stack_detected or is_false_positive_stack
        if status_code and status_code >= 400:
            regex_hit = any(regex.search(body) for regex in VULN_ERROR_REGEX_PATTERNS)
            if (any(pattern in body_lower for pattern in VULN_ERROR_PATTERNS) or regex_hit) and not is_false_positive_stack:
                prototype_error_hits = True

        content_type = header_value(result.get("headers") or {}, "content-type").lower()
        has_flight_line = bool(RSC_GENERIC_FLIGHT_LINE_RE.search(body))
        if SERVER_ACTIONS_RSC_CONTENT_TYPE in content_type or RSC_FLIGHT_PATTERN_V19 in body or RSC_FLIGHT_PATTERN_ARRAY in body or has_flight_line:
            rsc_processing = True
            inferred_major = infer_react_major_from_flight_text(body)
            if inferred_major is not None:
                inferred_majors.add(inferred_major)

        structure_hash = _body_structure_hash(body)
        header_signature = _header_signature(result.get("headers"))
        if structure_hash:
            structure_hashes.add(structure_hash)
        if header_signature:
            header_signatures.add(header_signature)
        content_lengths.append(len(body) if body else None)

    if inferred_majors:
        # Prefer React 19 when both appear to avoid false NOT_APPLICABLE gating in mixed deployments.
        react_major = 19 if 19 in inferred_majors else 18 if 18 in inferred_majors else react_major

    return ProbeSignals(
        digests=digests,
        error_messages=error_messages,
        validation_errors=validation_errors,
        status_codes=status_codes,
        prototype_error_hits=prototype_error_hits,
        rsc_processing=rsc_processing,
        false_positive_stack_detected=false_positive_stack_detected,
        react_major=react_major,
        structure_hashes=structure_hashes,
        header_signatures=header_signatures,
        content_lengths=content_lengths,
    )


def _summarize_probe_outcomes(probe_results: list[dict[str, Any]]) -> ProbeOutcomeSummary:
    successes = 0
    html_responses = 0
    failures = 0
    html_dev_errors = False
    proxy_errors = [
        result for result in probe_results if (result.get("status_code") == 502) and ("proxy error" in (result.get("body", "") + result.get("body_snippet", "")).lower())
    ]

    for result in probe_results:
        status_code = result.get("status_code")
        body = result.get("body") or result.get("body_snippet", "")
        content_type = header_value(result.get("headers") or {}, "content-type").lower()
        body_lower = body.lower()

        is_flight = bool(RSC_GENERIC_FLIGHT_LINE_RE.search(body))
        is_rsc_ct = SERVER_ACTIONS_RSC_CONTENT_TYPE in content_type
        is_json_ct = "application/json" in content_type
        is_html = "<!doctype" in body_lower or "<html" in body_lower

        if status_code == 200:
            if is_rsc_ct or is_json_ct or is_flight:
                successes += 1
            elif is_html:
                html_responses += 1
        elif status_code in (301, 302, 303, 307, 308):
            html_responses += 1
        elif status_code and status_code >= 500 and is_html and ("__next_data__" in body_lower or "__next_error__" in body_lower):
            html_dev_errors = True

        if status_code and status_code >= 500:
            failures += 1

    return ProbeOutcomeSummary(
        successes=successes,
        html_responses=html_responses,
        failures=failures,
        html_dev_errors=html_dev_errors,
        proxy_errors=proxy_errors,
    )


@dataclass
class MultiActionContext:
    probe_results: list[dict[str, Any]]
    control_results: list[dict[str, Any]] | None
    framework: str
    is_rsc_framework: bool
    cve_id: str
    server_actions_expected: bool | None
    actions_confidence: str | None
    react_major: int | None
    react_version: str | None
    react_major_confidence: str | None
    react_major_conf_level: int
    react_major_conflict: bool | None
    react_major_conflict_confidence: str | None
    react_major_conflict_majors: list[int] | None
    journal: PocJournal
    control_metadata: ControlMetadata
    probe_signals: ProbeSignals
    summary: ProbeOutcomeSummary
    surface_detected: bool
    decode_surface_reached: bool | None


@dataclass
class MultiActionAnalyzer(BaseRuleInterpreter[MultiActionContext]):
    """Stateful analyzer for multi-action probe result sets."""

    framework: str = "nextjs"
    is_rsc_framework: bool = False
    cve_id: str = CVE_ID
    react_major: int | None = None
    react_version: str | None = None
    server_actions_expected: bool | None = None
    server_actions_confidence: str | None = None
    react_major_confidence: str | None = None
    react_major_conflict: bool | None = None
    react_major_conflict_confidence: str | None = None
    react_major_conflict_majors: list[int] | None = None
    journal: PocJournal | None = None

    def rules(self) -> list[Rule[MultiActionContext]]:
        return [
            _rule_server_actions_missing,
            _rule_rsc_validation_without_success,
            _rule_html_only_responses,
            _rule_safe_args_no_invoke,
            _rule_success_path,
            _rule_nextjs_dev_overlay,
            _rule_multiple_digests,
            _rule_single_digest_failure,
            _rule_structural_divergence,
            _rule_server_actions_error_path,
            _rule_single_probe_guard,
            _rule_prototype_errors,
            _rule_validation_non_rsc,
            _rule_error_messages,
            _rule_rsc_processing_only,
            _default_rule,
        ]

    def default_decision(self, ctx: MultiActionContext) -> Decision:
        return _default_rule(ctx)

    def analyze(
        self,
        probe_results: list[dict],
        *,
        action_ids: list[str] | None = None,
        control_results: list[dict] | None = None,
    ) -> dict[str, Any]:
        journal = self.journal or get_current_journal() or PocJournal()

        def _analyze_inner() -> dict[str, Any]:
            journal.add_event(
                "analysis-start",
                "Analyzing multi-action probe responses",
                data={
                    "probes": len(probe_results),
                    "control_probes": len(control_results or []),
                    "framework": self.framework,
                    "is_rsc_framework": self.is_rsc_framework,
                    "react_version": self.react_version,
                },
            )

            failed_results = [res for res in probe_results if res.get("ok") is False]
            if control_results:
                failed_results.extend([res for res in control_results if res.get("ok") is False])

            total_results = len(probe_results) + len(control_results or [])
            all_failed = total_results > 0 and len(failed_results) == total_results
            if all_failed:
                journal.add_event(
                    "probe-error",
                    "All probes failed; returning INCONCLUSIVE",
                    data={
                        "failed_results": len(failed_results),
                    },
                )
                return _build_all_failed_result(journal, self.cve_id, self.framework, probe_results, control_results)

            actions_confidence = self.server_actions_confidence

            server_actions_expected = self.server_actions_expected

            control_metadata = _collect_control_metadata(control_results, journal)
            probe_signals = _collect_probe_signals(probe_results, journal, self.react_major)
            react_major = probe_signals.react_major
            if react_major is None and control_metadata.body:
                inferred = infer_react_major_from_flight_text(control_metadata.body)
                if inferred is not None:
                    react_major = inferred
            summary = _summarize_probe_outcomes(probe_results)
            surface_detected = bool(self.is_rsc_framework or probe_signals.rsc_processing or control_metadata.rsc_processing)
            react_major_confidence = self.react_major_confidence
            if react_major is not None and confidence_score(react_major_confidence) < confidence_score("medium"):
                # Flight-root inference is weaker than explicit version strings, but stronger than "unknown".
                react_major_confidence = "medium"
            react_major_conf_level = confidence_score(react_major_confidence)
            react_major_conflict = self.react_major_conflict
            react_major_conflict_confidence = self.react_major_conflict_confidence
            react_major_conflict_majors = self.react_major_conflict_majors
            decode_surface_reached: bool | None = None
            if (
                summary.successes > 0
                or probe_signals.digests
                or control_metadata.digest
                or probe_signals.rsc_processing
                or control_metadata.rsc_processing
                or probe_signals.prototype_error_hits
            ):
                decode_surface_reached = True
            elif probe_signals.validation_errors and summary.successes == 0 and summary.failures == 0:
                decode_surface_reached = False
            elif summary.html_responses > 0 and summary.successes == 0 and summary.failures == 0 and server_actions_expected is True:
                decode_surface_reached = False

            ctx = MultiActionContext(
                probe_results=probe_results,
                control_results=control_results,
                framework=self.framework,
                is_rsc_framework=self.is_rsc_framework,
                cve_id=self.cve_id,
                server_actions_expected=server_actions_expected,
                actions_confidence=actions_confidence,
                react_major=react_major,
                react_version=self.react_version,
                react_major_confidence=react_major_confidence,
                react_major_conf_level=react_major_conf_level,
                react_major_conflict=react_major_conflict,
                react_major_conflict_confidence=react_major_conflict_confidence,
                react_major_conflict_majors=react_major_conflict_majors,
                journal=journal,
                control_metadata=control_metadata,
                probe_signals=probe_signals,
                summary=summary,
                surface_detected=surface_detected,
                decode_surface_reached=decode_surface_reached,
            )

            if summary.proxy_errors and summary.successes == 0 and summary.failures == len(probe_signals.status_codes):
                proxy_decision = Decision(
                    PocStatus.INCONCLUSIVE,
                    "low",
                    "Probe requests failed with upstream proxy errors",
                    surface_detected=False,
                )
                return _build_proxy_error_result(ctx, proxy_decision)

            decision = self.evaluate_rules(ctx)
            applied_surface = decision.surface_detected if decision.surface_detected is not None else surface_detected

            return _build_decision_result(ctx, decision, applied_surface)

        with journal_context(journal):
            return _analyze_inner()


def _actions_confidence(actions_confidence: str | None) -> str:
    if confidence_at_least(actions_confidence, "high"):
        return "high"
    if confidence_at_least(actions_confidence, "medium"):
        return "medium"
    return "low"


def _react_confidence_from_level(level: int) -> str:
    if level >= confidence_score("high"):
        return "high"
    if level >= confidence_score("medium"):
        return "medium"
    return "low"


def _rule_server_actions_missing(ctx: MultiActionContext) -> Decision | None:
    if ctx.server_actions_expected is not False or ctx.summary.successes != 0:
        return None

    if ctx.is_rsc_framework and ctx.probe_signals.digests:
        # Conflicting signals: we expected "no actions", but we still observed RSC digests.
        # This can happen with wrong endpoints, intermediate error pages, or framework heuristics.
        return Decision(
            PocStatus.INCONCLUSIVE,
            "medium",
            "RSC error digests observed despite missing Server Actions signal; unable to reconcile surface reachability",
            surface_detected=True,
        )

    confidence = _actions_confidence(ctx.actions_confidence)
    return Decision(
        PocStatus.NOT_VULNERABLE,
        confidence,
        "Server Actions not detected; probes did not observe RSC Server Functions decoding (React2Shell requires Server Actions)",
        surface_detected=ctx.surface_detected,
    )


def _rule_rsc_validation_without_success(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.failures != 0 or ctx.summary.successes != 0:
        return None
    if not (ctx.probe_signals.validation_errors and ctx.is_rsc_framework):
        return None
    if ctx.server_actions_expected is True and ctx.framework != "nextjs":
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            "Server Actions validation rejected synthetic IDs (4xx action-not-found) before RSC processing",
            surface_detected=True,
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Server Actions validation rejected synthetic IDs (4xx action-not-found) before RSC processing",
        surface_detected=True,
    )


def _rule_html_only_responses(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.html_responses == 0 or ctx.summary.successes != 0 or ctx.summary.failures != 0:
        return None

    if ctx.server_actions_expected is False:
        confidence = _actions_confidence(ctx.actions_confidence)
        return Decision(
            PocStatus.NOT_VULNERABLE,
            confidence,
            "Server Actions not detected; HTML responses indicate no reachable Server Actions surface (React2Shell requires Server Actions)",
            surface_detected=ctx.surface_detected,
        )

    # HTML-only responses while Server Actions are expected are FN-prone (wrong route/auth/dev overlay).
    if ctx.server_actions_expected is True or ctx.is_rsc_framework:
        return Decision(
            PocStatus.INCONCLUSIVE,
            "medium",
            "Expected RSC / Server Actions decoding, but probes returned only HTML; decode surface may be blocked or endpoints may be incorrect",
            surface_detected=ctx.surface_detected,
        )
    return Decision(
        PocStatus.NOT_VULNERABLE,
        _actions_confidence(ctx.actions_confidence),
        "All responses returned HTML, not RSC Flight protocol; no Server Functions decode surface observed on tested endpoints",
        surface_detected=False,
    )


def _rule_success_path(ctx: MultiActionContext) -> Decision | None:
    if ctx.summary.successes == 0:
        return None

    if ctx.control_metadata.status == 200 and ctx.summary.failures == 0:
        return Decision(
            PocStatus.NOT_VULNERABLE,
            "high",
            "Proto and control probes both succeeded (action processing reached)",
        )
    return Decision(
        PocStatus.NOT_VULNERABLE,
        "medium",
        "Server Actions processing returned 200 responses for proto probes",
    )


def _rule_safe_args_no_invoke(ctx: MultiActionContext) -> Decision | None:
    """
    Safe-probing mode: requests use a "no-invoke args" container (BigInt length) to prevent
    server function execution even when action IDs are valid.

    Interpretation is inverted vs normal probes:
    - proto matches control baseline => traversal likely reachable => (likely) vulnerable
    - proto diverges from control baseline => traversal likely blocked before invocation => (likely) not vulnerable
    """

    def _uses_safe_args_strategy(results: list[dict[str, Any]] | None) -> bool:
        for res in results or []:
            meta = res.get("payload_meta") or {}
            if isinstance(meta, dict) and meta.get("probe_strategy") == SAFE_ARGS_STRATEGY:
                return True
        return False

    if not (_uses_safe_args_strategy(ctx.control_results) or _uses_safe_args_strategy(ctx.probe_results)):
        return None

    if not (ctx.control_results and ctx.probe_results):
        return None

    # If any probe succeeded (Flight/JSON 200), the "no-invoke" assumption did not hold.
    # Defer to the standard success-path / error-path rules instead of inferring vulnerability.
    if ctx.summary.successes > 0:
        return None

    if ctx.react_major is not None and ctx.react_major != 19 and not _react19_possible(ctx):
        confidence = _react_confidence_from_level(ctx.react_major_conf_level)
        return Decision(
            PocStatus.NOT_APPLICABLE,
            confidence,
            f"No-invoke args probes observed but React {ctx.react_major}.x (React2Shell requires React 19.x)",
            surface_detected=ctx.surface_detected,
        )

    def _fingerprint(res: dict[str, Any]) -> tuple[str, str] | None:
        body = (res.get("body") or res.get("body_snippet", "")) or ""
        m = ERROR_DIGEST_PATTERN.search(body)
        if m:
            return ("digest", m.group(1))
        struct = _body_structure_hash(body)
        if struct:
            return ("struct", struct)
        header = _header_signature(res.get("headers"))
        if header:
            return ("header", header)
        return None

    ctrl_fp = _fingerprint(ctx.control_results[0] or {})
    if ctrl_fp is None:
        return None

    proto_fps = [_fingerprint(res) for res in ctx.probe_results]
    proto_fps_present = [fp for fp in proto_fps if fp is not None]
    if not proto_fps_present:
        return None

    required = max(1, len(proto_fps_present) // 2 + 1)
    matches = sum(fp == ctrl_fp for fp in proto_fps_present)

    if matches >= required:
        ctrl_body = (ctx.control_results[0].get("body") or ctx.control_results[0].get("body_snippet") or "") if ctx.control_results else ""
        ctrl_body_norm = str(ctrl_body or "").strip().lower()
        generic_error_bodies = {"internal server error", "internal error", "server error"}
        low_signal_match = ctrl_fp[0] != "digest" and ctrl_body_norm in generic_error_bodies

        if low_signal_match:
            version_hint = is_react_version_vulnerable(ctx.react_version)
            if version_hint is False:
                return Decision(
                    PocStatus.LIKELY_NOT_VULNERABLE,
                    "low",
                    "No-invoke args probes matched on a generic error baseline; runtime version hint suggests traversal is patched",
                    surface_detected=ctx.surface_detected,
                )
            if version_hint is True:
                return Decision(
                    PocStatus.LIKELY_VULNERABLE,
                    "low",
                    "No-invoke args probes matched on a generic error baseline; runtime version hint suggests traversal may be reachable",
                    surface_detected=ctx.surface_detected,
                )

        # Some patched runtimes reject malformed server references early with stable validation strings.
        if ctrl_fp[0] != "digest" and ("invalid reference" in ctrl_body_norm or "invalid server reference" in ctrl_body_norm):
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "No-invoke args probes matched on an explicit reference-validation error; traversal likely blocked before deserialization",
                surface_detected=ctx.surface_detected,
            )

        # When we don't have an error digest, treat baseline matches as low-signal and defer to version hints.
        if ctrl_fp[0] != "digest":
            version_hint = is_react_version_vulnerable(ctx.react_version)
            if version_hint is False:
                return Decision(
                    PocStatus.LIKELY_NOT_VULNERABLE,
                    "low",
                    "No-invoke args probes matched without digests; runtime version hint suggests traversal is patched",
                    surface_detected=ctx.surface_detected,
                )
            if version_hint is True:
                return Decision(
                    PocStatus.LIKELY_VULNERABLE,
                    "low",
                    "No-invoke args probes matched without digests; runtime version hint suggests traversal may be reachable",
                    surface_detected=ctx.surface_detected,
                )
            return Decision(
                PocStatus.LIKELY_VULNERABLE if ctx.server_actions_expected is True else PocStatus.INCONCLUSIVE,
                "low",
                "No-invoke args probes matched without digests; reachability remains uncertain without version grounding",
                surface_detected=ctx.surface_detected,
            )

        status = PocStatus.VULNERABLE if ctx.server_actions_expected is True else PocStatus.LIKELY_VULNERABLE
        confidence = "high" if ctrl_fp[0] == "digest" and ctx.server_actions_expected is True else "medium"
        return Decision(
            status,
            confidence,
            "No-invoke args baseline matched between proto and control (decode reached invocation boundary; traversal may be reachable)",
            surface_detected=ctx.surface_detected,
        )

    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "No-invoke args baseline diverged between proto and control (decode failed before invocation; traversal likely blocked)",
        surface_detected=ctx.surface_detected,
    )


def _rule_nextjs_dev_overlay(ctx: MultiActionContext) -> Decision | None:
    if ctx.framework != "nextjs" or not ctx.summary.html_dev_errors or ctx.summary.successes != 0:
        return None

    all_bodies = [(res.get("body") or res.get("body_snippet", "")) for res in ctx.probe_results]
    all_bodies_same = bool(ctx.control_metadata.body) and all(body == ctx.control_metadata.body for body in all_bodies)
    dev_overlay_signatures = (
        "module not found",
        "webpack",
        "next/dist/build/webpack/plugins",
        "__next_error__",
    )
    dev_overlay_hit = ctx.control_metadata.body and any(sig in ctx.control_metadata.body.lower() for sig in dev_overlay_signatures)

    has_html_200 = any(
        res.get("status_code") == 200 and ("<html" in (res.get("body") or res.get("body_snippet", "")).lower()) for res in ctx.probe_results + (ctx.control_results or [])
    )

    dev_overlay_short_circuit = dev_overlay_hit and all_bodies_same and not ctx.probe_signals.digests and not ctx.probe_signals.rsc_processing

    if has_html_200 and dev_overlay_hit:
        return Decision(
            PocStatus.NOT_VULNERABLE,
            "high",
            "Next.js dev overlay returned 200 HTML for proto/control; no RSC Flight response observed",
        )
    if dev_overlay_short_circuit:
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Next.js dev overlay returned identical HTML for proto/control without RSC digests - treating as validation short-circuit",
        )

    if all_bodies_same or (ctx.control_metadata.body and not ctx.control_metadata.digest and ctx.summary.html_dev_errors):
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "Next.js dev overlay returned identical HTML on action probes (possible vulnerable dev path)",
        )

    if ctx.react_major is not None and ctx.react_major < 19 and not _react19_possible(ctx):
        confidence = _react_confidence_from_level(ctx.react_major_conf_level)
        return Decision(
            PocStatus.NOT_APPLICABLE,
            confidence,
            "Next.js dev overlay returned HTML without RSC; React <19 (React2Shell requires React 19.x)",
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Next.js dev error page returned HTML 5xx on action probes (dev overlay on action path)",
    )


def _rule_multiple_digests(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_signals.digests) <= 1:
        return None

    if ctx.react_major is not None and ctx.react_major != 19 and not _react19_possible(ctx):
        confidence = _react_confidence_from_level(ctx.react_major_conf_level)
        return Decision(
            PocStatus.NOT_APPLICABLE,
            confidence,
            f"Multiple error digests observed but React {ctx.react_major}.x (React2Shell requires React 19.x)",
            surface_detected=ctx.surface_detected,
        )

    if ctx.server_actions_expected is True:
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "Proto probes returned multiple distinct error digests while actions were expected; divergent error paths possible",
        )
    if ctx.server_actions_expected is False and not ctx.is_rsc_framework:
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Multiple digests on non-RSC surface without actions signal - treating as ambiguous/non-action",
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Proto probes returned multiple distinct error digests without a clear Server Actions surface; likely validation or non-action differences",
    )


def _rule_single_digest_failure(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_signals.digests) != 1 or ctx.summary.failures < 2 or ctx.summary.successes != 0:
        return None

    proto_digest = list(ctx.probe_signals.digests)[0]
    if not proto_digest:
        return None
    react_info = f" (React {ctx.react_major})" if ctx.react_major else ""
    control_matches_proto = ctx.control_metadata.status == 500 and ctx.control_metadata.digest == proto_digest
    control_diverges = ctx.control_metadata.status == 200 or (
        ctx.control_metadata.status == 500 and ctx.control_metadata.digest is not None and ctx.control_metadata.digest != proto_digest
    )

    if control_diverges:
        if ctx.control_metadata.status == 200:
            return Decision(
                PocStatus.VULNERABLE,
                "high",
                f"Control succeeded (200) while proto probe fails with digest {proto_digest[:16]}... - prototype traversal triggered an error{react_info}",
            )
        control_digest = ctx.control_metadata.digest
        if not control_digest:
            return None
        return Decision(
            PocStatus.VULNERABLE,
            "high" if ctx.server_actions_expected is True else "medium",
            f"Proto and control probes fail with different digests ({proto_digest[:12]}... vs {control_digest[:12]}...) - different error paths{react_info}",
        )

    if control_matches_proto:
        all_bodies = [(res.get("body") or "") + res.get("body_snippet", "") for res in ctx.probe_results]
        has_patched_error = any(any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS) for body in all_bodies)
        if has_patched_error:
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "Proto and control probes share the same digest and include action validation errors; likely validation short-circuit",
            )
        if ctx.react_major is not None and ctx.react_major != 19 and not _react19_possible(ctx):
            confidence = _react_confidence_from_level(ctx.react_major_conf_level)
            return Decision(
                PocStatus.NOT_APPLICABLE,
                confidence,
                f"React {ctx.react_major}.x with identical proto/control failures (React2Shell requires React 19.x)",
                surface_detected=ctx.is_rsc_framework or ctx.probe_signals.rsc_processing,
            )
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Proto and control probes fail identically - no behavioral difference attributable to prototype traversal",
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        f"All {ctx.summary.failures} probes failed with identical digest - RSC deserialization error{react_info}",
    )


def _rule_structural_divergence(ctx: MultiActionContext) -> Decision | None:
    if ctx.probe_signals.digests or ctx.control_metadata.digest:
        return None
    if ctx.decode_surface_reached is not True:
        return None
    if not ctx.control_metadata.rsc_processing:
        return None

    total_probes = len(ctx.probe_results)
    if total_probes < 2:
        return None

    ctrl_structure = ctx.control_metadata.structure_hash
    ctrl_header = ctx.control_metadata.header_signature
    ctrl_len = ctx.control_metadata.content_length
    if not ctrl_structure and not ctrl_header:
        return None

    errorish = any((code or 0) >= 400 for code in ctx.probe_signals.status_codes)
    if not errorish and ctx.summary.failures == 0:
        return None

    required = max(2, total_probes // 2 + 1)
    struct_diff_count = 0
    header_diff_count = 0
    length_diff_count = 0
    probe_struct_hashes: list[str | None] = []

    for result in ctx.probe_results:
        body = result.get("body") or result.get("body_snippet", "")
        struct_hash = _body_structure_hash(body)
        header_sig = _header_signature(result.get("headers"))
        probe_struct_hashes.append(struct_hash)

        if ctrl_structure and struct_hash and struct_hash != ctrl_structure:
            struct_diff_count += 1
        if ctrl_header and header_sig and header_sig != ctrl_header:
            header_diff_count += 1
        if ctrl_len is not None and body:
            if abs(len(body) - ctrl_len) > max(64, int(ctrl_len * 0.3)):
                length_diff_count += 1

    if ctrl_structure:
        if struct_diff_count < required:
            return None
        # Require a stable non-control fingerprint across proto probes to avoid noise-driven divergence.
        non_control_hashes = [h for h in probe_struct_hashes if h and h != ctrl_structure]
        if len(non_control_hashes) < required:
            return None
        most_common = max(Counter(non_control_hashes).values(), default=0)
        if most_common < required:
            return None
    else:
        # Without a control structure fingerprint, require corroboration from both headers and body length.
        if ctrl_len is None or header_diff_count < required or length_diff_count < required:
            return None

    confidence = "high" if ctx.server_actions_expected else "medium"
    status = PocStatus.VULNERABLE if ctx.server_actions_expected else PocStatus.LIKELY_VULNERABLE
    reason = "Proto responses structurally diverged from control (locale-agnostic fingerprint)"
    return Decision(status, confidence, reason, surface_detected=ctx.surface_detected)


def _rule_server_actions_error_path(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.server_actions_expected and ctx.is_rsc_framework and ctx.summary.failures > 0 and ctx.summary.successes == 0):
        return None

    # Let prototype-error rules speak first when we have explicit TypeError/prototype indicators.
    if ctx.probe_signals.prototype_error_hits and not ctx.probe_signals.false_positive_stack_detected:
        return None

    def _control_matches_proto_failures() -> bool:
        if not (ctx.control_metadata.status and ctx.control_metadata.status >= 500):
            return False

        ctrl_struct = ctx.control_metadata.structure_hash
        ctrl_header = ctx.control_metadata.header_signature
        if not ctrl_struct and not ctrl_header:
            return False

        total = len(ctx.probe_results)
        if total == 0:
            return False

        struct_matches = 0
        header_matches = 0
        for result in ctx.probe_results:
            body = result.get("body") or result.get("body_snippet", "")
            if ctrl_struct and _body_structure_hash(body) == ctrl_struct:
                struct_matches += 1
            if ctrl_header and _header_signature(result.get("headers")) == ctrl_header:
                header_matches += 1

        # Prefer body-structure matches; fall back to header-signature when structure hashes are unavailable.
        required = total
        if ctrl_struct:
            return struct_matches >= required
        return header_matches >= required

    if ctx.framework == "nextjs":
        proto_bodies = [(res.get("body") or res.get("body_snippet", "")) for res in ctx.probe_results]
        validation_on_action_path = any(
            any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS) for body in proto_bodies + ([ctx.control_metadata.body] if ctx.control_metadata.body else [])
        )
        if validation_on_action_path:
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "Server Actions probes hit validation messaging without RSC digests; likely blocked/validated action surface",
            )
        if _control_matches_proto_failures():
            return Decision(
                PocStatus.LIKELY_NOT_VULNERABLE,
                "medium",
                "Proto/control probes both produced similar 5xx responses without RSC digests - likely app error path (no proto-specific behavior)",
                surface_detected=ctx.surface_detected,
            )
        if ctx.react_major is not None and ctx.react_major < 19 and not _react19_possible(ctx):
            confidence = _react_confidence_from_level(ctx.react_major_conf_level)
            return Decision(
                PocStatus.NOT_APPLICABLE,
                confidence,
                "Server Actions errors without RSC processing; React <19 (React2Shell requires React 19.x)",
            )
        return Decision(
            PocStatus.LIKELY_VULNERABLE,
            "medium",
            "Server Actions expected; probes returned 5xx without RSC digests (dev/HTML error path)",
        )

    if _control_matches_proto_failures():
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            "Proto/control probes both produced similar 5xx responses without RSC digests - likely app error path (no proto-specific behavior)",
            surface_detected=ctx.surface_detected,
        )

    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Server Actions expected; probes returned 5xx without RSC digests (dev/HTML error path)",
    )


def _rule_single_probe_guard(ctx: MultiActionContext) -> Decision | None:
    if len(ctx.probe_results) != 1:
        return None

    # Validation errors on a non-RSC surface are meaningful even with a single probe.
    if ctx.probe_signals.validation_errors and not ctx.is_rsc_framework:
        return None

    return Decision(
        PocStatus.INCONCLUSIVE,
        "low",
        "Only one probe result available; need multiple actions to compare",
    )


def _rule_prototype_errors(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.probe_signals.prototype_error_hits and not ctx.probe_signals.false_positive_stack_detected):
        return None

    if (ctx.probe_signals.rsc_processing or ctx.is_rsc_framework) and (ctx.summary.failures > 0 or ctx.server_actions_expected):
        confidence = "high" if ctx.summary.failures > 0 else "medium"
        return Decision(
            PocStatus.VULNERABLE,
            confidence,
            "Prototype-related errors observed in RSC probe responses (action path hit)",
        )
    return Decision(
        PocStatus.LIKELY_VULNERABLE,
        "medium",
        "Prototype-related errors observed in probe responses",
    )


def _rule_validation_non_rsc(ctx: MultiActionContext) -> Decision | None:
    if not (ctx.probe_signals.validation_errors and not ctx.is_rsc_framework):
        return None
    return Decision(
        PocStatus.NOT_VULNERABLE,
        "high",
        "Action validation errors on non-RSC surface (likely SPA)",
        surface_detected=False,
    )


def _rule_error_messages(ctx: MultiActionContext) -> Decision | None:
    if not ctx.probe_signals.error_messages:
        return None
    if len(ctx.probe_signals.error_messages) == 1:
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            "Single plain-text error response; unable to determine behavior",
        )
    return Decision(
        PocStatus.LIKELY_NOT_VULNERABLE,
        "medium",
        "Multiple distinct plain-text error responses; no stable digest/Flight signal - treating as likely not vulnerable",
    )


def _rule_rsc_processing_only(ctx: MultiActionContext) -> Decision | None:
    if not ctx.probe_signals.rsc_processing:
        return None
    return Decision(
        PocStatus.INCONCLUSIVE,
        "low",
        "RSC processing detected but behavior inconclusive",
    )


def _default_rule(ctx: MultiActionContext) -> Decision:
    # If we expected an action/decode surface but observed no RSC processing at all, treat this as
    # inconclusive (FN-prone: wrong route, auth, WAF, etc.).
    if ctx.server_actions_expected is True or ctx.is_rsc_framework:
        return Decision(
            PocStatus.INCONCLUSIVE,
            "low",
            "No RSC processing detected on tested endpoints despite expected Server Actions surface",
            surface_detected=ctx.surface_detected,
        )

    # Otherwise this is a missing-surface conclusion.
    confidence = _actions_confidence(ctx.actions_confidence)
    return Decision(
        PocStatus.NOT_VULNERABLE,
        confidence,
        "No RSC processing detected on tested endpoints",
        surface_detected=False,
    )


def _build_decision_result(ctx: MultiActionContext, decision: Decision, surface_detected: bool) -> dict[str, Any]:
    ctx.journal.add_decision(decision.status, decision.reason)
    confidence = _apply_react_major_conflict_penalty(ctx, decision.confidence)
    return {
        "status": decision.status,
        "details": {
            "cve_id": ctx.cve_id,
            "confidence": confidence,
            "reason": decision.reason,
            "decision_rule": decision.rule,
            "framework": ctx.framework,
            "is_rsc_framework": ctx.is_rsc_framework,
            "server_actions_expected": ctx.server_actions_expected,
            "actions_confidence": ctx.actions_confidence,
            "react_major": ctx.react_major,
            "react_major_confidence": ctx.react_major_confidence,
            "react_major_conflict": ctx.react_major_conflict,
            "react_major_conflict_confidence": ctx.react_major_conflict_confidence,
            "react_major_conflict_majors": ctx.react_major_conflict_majors,
            "surface_detected": surface_detected,
            "decode_surface_reached": ctx.decode_surface_reached,
            "proto_digests": sorted(ctx.probe_signals.digests),
            "control_digest": ctx.control_metadata.digest,
            "evidence": {
                "probe_count": len(ctx.probe_results),
                "control_count": len(ctx.control_results or []),
                "summary": {
                    "successes": ctx.summary.successes,
                    "failures": ctx.summary.failures,
                    "html_responses": ctx.summary.html_responses,
                    "html_dev_errors": ctx.summary.html_dev_errors,
                    "proxy_error_count": len(ctx.summary.proxy_errors),
                },
                "signals": {
                    "digests_count": len(ctx.probe_signals.digests),
                    "validation_errors_count": len(ctx.probe_signals.validation_errors),
                    "prototype_error_hits": ctx.probe_signals.prototype_error_hits,
                    "false_positive_stack_detected": ctx.probe_signals.false_positive_stack_detected,
                    "rsc_processing": ctx.probe_signals.rsc_processing,
                },
                "control": {
                    "status_code": ctx.control_metadata.status,
                    "digest": ctx.control_metadata.digest,
                    "rsc_processing": ctx.control_metadata.rsc_processing,
                },
            },
        },
        "raw_data": {
            "probe_results": ctx.probe_results,
            "control_results": ctx.control_results,
            "journal": ctx.journal.to_list(),
        },
    }


def _build_all_failed_result(
    journal: PocJournal,
    cve_id: str,
    framework: str,
    probe_results: list[dict],
    _control_results: list[dict] | None,
) -> dict[str, Any]:
    reason = "Probe requests failed after retries; network state unknown"
    journal.add_decision(PocStatus.INCONCLUSIVE, reason)
    return {
        "status": PocStatus.INCONCLUSIVE,
        "details": {
            "cve_id": cve_id,
            "confidence": "low",
            "reason": reason,
            "framework": framework,
            "probes_sent": len(probe_results),
            "surface_detected": False,
            "decode_surface_reached": None,
        },
        "raw_data": {"journal": journal.to_list()},
    }


def _build_proxy_error_result(ctx: MultiActionContext, decision: Decision) -> dict[str, Any]:
    ctx.journal.add_decision(decision.status, decision.reason)
    return {
        "status": decision.status,
        "details": {
            "cve_id": ctx.cve_id,
            "confidence": decision.confidence,
            "reason": decision.reason,
            "framework": ctx.framework,
            "surface_detected": decision.surface_detected,
            "decode_surface_reached": ctx.decode_surface_reached,
        },
        "raw_data": {
            "probe_results": ctx.probe_results,
            "control_results": ctx.control_results,
            "journal": ctx.journal.to_list(),
        },
    }


def analyze_multi_action_results(
    probe_results: list[dict],
    action_ids: list[str] | None = None,
    framework: str = "nextjs",
    is_rsc_framework: bool = False,
    cve_id: str = CVE_ID,
    control_results: list[dict] | None = None,
    react_major: int | None = None,
    react_version: str | None = None,
    server_actions_expected: bool | None = None,
    server_actions_confidence: str | None = None,
    react_major_confidence: str | None = None,
    react_major_conflict: bool | None = None,
    react_major_conflict_confidence: str | None = None,
    react_major_conflict_majors: list[int] | None = None,
    journal: PocJournal | None = None,
) -> dict[str, Any]:
    analyzer_cls: type[MultiActionAnalyzer] = MultiActionAnalyzer
    normalized_framework = str(framework or "").strip().lower()
    if normalized_framework == "nextjs":
        from .nextjs_interpreter import NextjsInterpreter

        analyzer_cls = NextjsInterpreter
    elif normalized_framework == "expo":
        from .expo_interpreter import ExpoInterpreter

        analyzer_cls = ExpoInterpreter
    elif normalized_framework in {"react-router", "react_router"}:
        from .react_router_interpreter import ReactRouterInterpreter

        analyzer_cls = ReactRouterInterpreter
    elif normalized_framework in {"rsc", "generic-rsc", "generic_rsc"}:
        from .generic_rsc_interpreter import GenericRscInterpreter

        analyzer_cls = GenericRscInterpreter

    analyzer = analyzer_cls(
        framework=framework,
        is_rsc_framework=is_rsc_framework,
        cve_id=cve_id,
        react_major=react_major,
        react_version=react_version,
        server_actions_expected=server_actions_expected,
        server_actions_confidence=server_actions_confidence,
        react_major_confidence=react_major_confidence,
        react_major_conflict=react_major_conflict,
        react_major_conflict_confidence=react_major_conflict_confidence,
        react_major_conflict_majors=react_major_conflict_majors,
        journal=journal,
    )
    return analyzer.analyze(
        probe_results,
        action_ids=action_ids,
        control_results=control_results,
    )
