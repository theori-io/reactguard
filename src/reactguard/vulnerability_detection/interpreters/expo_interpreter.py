# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

"""Expo-specific multi-action interpreter for CVE-2025-55182."""

from __future__ import annotations

from dataclasses import dataclass

from ...models.poc import PocStatus
from .base import Decision, Rule
from .multi_action import (
    MultiActionAnalyzer,
    MultiActionContext,
    _default_rule,
    _rule_error_messages,
    _rule_html_only_responses,
    _rule_multiple_digests,
    _rule_prototype_errors,
    _rule_rsc_processing_only,
    _rule_rsc_validation_without_success,
    _rule_safe_args_no_invoke,
    _rule_server_actions_error_path,
    _rule_server_actions_missing,
    _rule_single_digest_failure,
    _rule_single_probe_guard,
    _rule_structural_divergence,
    _rule_success_path,
    _rule_validation_non_rsc,
)


def _rule_expo_connection_closed(ctx: MultiActionContext) -> Decision | None:
    """
    Expo (Metro) Server Functions can return a small `text/plain` 5xx like "Connection closed."
    for proto-pollution probes when decodeReply() cannot resolve chunk 0.

    When probing with a randomized ACTION_ URL (to avoid invoking unknown app code), the benign
    baseline is often a module-resolution error ("Unable to resolve module ...reactguard_probe...").
    Treat "control=module resolution" + "proto=connection closed" as likely-not-vulnerable unless
    we also see explicit prototype/TypeError markers.
    """

    if ctx.framework != "expo" or ctx.invocation_expected is not True:
        return None

    if ctx.summary.successes != 0 or ctx.summary.failures != len(ctx.probe_results):
        return None

    if ctx.probe_signals.digests or ctx.control_metadata.digest:
        return None

    if ctx.probe_signals.prototype_error_hits:
        return None

    ctrl_status = ctx.control_metadata.status or 0
    ctrl_body = (ctx.control_metadata.body or "").strip()
    ctrl_lower = ctrl_body.lower()
    if not ctrl_body:
        return None

    flight_baseline_hit = bool(ctrl_status == 200 and ctx.control_metadata.rsc_processing)

    # Randomized ACTION_ URLs should not map to real app modules; module-resolution failures are expected.
    module_resolution_hit = bool(ctrl_status >= 500 and ("unable to resolve module" in ctrl_lower or "cannot find module" in ctrl_lower) and ("reactguard_probe" in ctrl_lower))

    if not (flight_baseline_hit or module_resolution_hit):
        return None

    bodies = [(res.get("body") or res.get("body_snippet") or "").strip() for res in ctx.probe_results]
    if not bodies:
        return None

    if not all(body and len(body) <= 64 for body in bodies):
        return None

    if all("connection closed" in body.lower() for body in bodies):
        baseline = "Flight baseline" if flight_baseline_hit else "module-resolution baseline"
        return Decision(
            PocStatus.LIKELY_NOT_VULNERABLE,
            "medium",
            f"Expo Server Functions returned 'Connection closed' on proto probes with {baseline}; likely validation/baseline behavior",
            surface_detected=ctx.surface_detected,
        )

    return None


@dataclass
class ExpoInterpreter(MultiActionAnalyzer):
    framework: str = "expo"

    def rules(self) -> list[Rule[MultiActionContext]]:
        return [
            _rule_server_actions_missing,
            _rule_rsc_validation_without_success,
            _rule_html_only_responses,
            _rule_safe_args_no_invoke,
            _rule_success_path,
            _rule_prototype_errors,
            _rule_expo_connection_closed,
            _rule_multiple_digests,
            _rule_single_digest_failure,
            _rule_structural_divergence,
            _rule_server_actions_error_path,
            _rule_single_probe_guard,
            _rule_validation_non_rsc,
            _rule_error_messages,
            _rule_rsc_processing_only,
            _default_rule,
        ]
