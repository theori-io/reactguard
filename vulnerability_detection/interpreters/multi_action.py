"""
    ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
    Copyright (C) 2025  Theori Inc.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Multi-action result interpreter for CVE-2025-55182."""

from typing import Any, Dict, List, Optional, Set

from ...models.poc import PocStatus
from ..journal import PocJournal
from .digest import ERROR_DIGEST_PATTERN

# CVE constants
CVE_ID = "CVE-2025-55182"

# Patched behavior signatures - action validation happens BEFORE deserialization
PATCHED_ERROR_PATTERNS = [
    "action not found",
    "invalid action",
    "unknown action",
    "action id not found",
    "no server action found",
    "server action not found",
]

# Vulnerable behavior signatures - prototype pollution occurred during deserialization
VULN_ERROR_PATTERNS = [
    "cannot read properties of null",
    "cannot read properties of undefined",
    "action error:",
    "reading 'id'",
    "reading 'workers'",
    "reading 'constructor'",
    "prototype",
]

NEXTJS_FALSE_POSITIVE_STACK_PATTERNS = [
    "action-handler.js",
]

RSC_CONTENT_TYPE = "text/x-component"
RSC_FLIGHT_PATTERN_V19 = '0:{"a":"$@1"'
RSC_FLIGHT_PATTERN_ARRAY = '0:["$@1",'

CONFIDENCE_ORDER = {"none": 0, "low": 1, "medium": 2, "high": 3}


def _confidence_score(confidence: Optional[str]) -> int:
    return CONFIDENCE_ORDER.get(str(confidence or "").lower(), 0)


def _confidence_at_least(confidence: Optional[str], threshold: str) -> bool:
    return _confidence_score(confidence) >= CONFIDENCE_ORDER.get(threshold, 0)


def analyze_multi_action_results(
    probe_results: List[Dict],
    action_ids: Optional[List[str]] = None,
    framework: str = "nextjs",
    is_rsc_framework: bool = False,
    error_categories: Optional[Set[str]] = None,
    cve_id: str = CVE_ID,
    control_results: Optional[List[Dict]] = None,
    react_major: Optional[int] = None,
    react_version: Optional[str] = None,
    server_actions_expected: Optional[bool] = None,
    server_actions_confidence: Optional[str] = None,
    react_major_confidence: Optional[str] = None,
    journal: Optional[PocJournal] = None,
) -> Dict[str, Any]:
    journal = journal or PocJournal()
    journal.add_event(
        "analysis-start",
        "Analyzing multi-action probe responses",
        data={
            "probes": len(probe_results),
            "control_probes": len(control_results or []),
            "framework": framework,
            "is_rsc_framework": is_rsc_framework,
            "react_version": react_version,
        },
    )

    def _early_error_from_categories() -> Optional[Dict[str, Any]]:
        failed_results = [res for res in probe_results if res.get("ok") is False]
        if control_results:
            failed_results.extend([res for res in control_results if res.get("ok") is False])

        total_results = len(probe_results) + len(control_results or [])
        all_failed = total_results > 0 and len(failed_results) == total_results

        if not all_failed:
            return None

        reason = "Probe requests failed after retries; network state unknown"
        journal.add_event(
            "probe-error",
            "All probes failed; returning INCONCLUSIVE",
            data={
                "error_categories": list(error_categories or []),
                "failed_results": len(failed_results),
            },
        )
        journal.add_decision(PocStatus.INCONCLUSIVE, reason)
        return {
            "status": PocStatus.INCONCLUSIVE,
            "details": {
                "cve_id": cve_id,
                "confidence": "none",
                "reason": reason,
                "framework": framework,
                "error_categories": list(error_categories or []),
                "probes_sent": len(probe_results),
                "surface_detected": False,
            },
            "raw_data": {"journal": journal.to_list()},
        }

    early = _early_error_from_categories()
    if early:
        return early

    actions_confidence = server_actions_confidence
    if actions_confidence is None and server_actions_expected is False:
        actions_confidence = "high"

    if server_actions_expected is None and not is_rsc_framework and framework != "nextjs":
        server_actions_expected = False

    control_status = None
    control_digest = None
    control_body = None
    if control_results:
        for ctrl in control_results:
            control_status = ctrl.get("status_code")
            ctrl_body = ctrl.get("body") or ctrl.get("body_snippet", "")
            ctrl_digest_match = ERROR_DIGEST_PATTERN.search(ctrl_body)
            ctrl_digest = ctrl_digest_match.group(1) if ctrl_digest_match else None
            if ctrl_digest:
                control_digest = ctrl_digest
            if ctrl_body and control_body is None:
                control_body = ctrl_body
            journal.add_probe(
                "control",
                action_id=ctrl.get("action_id") or ctrl.get("action_name"),
                status_code=control_status,
                body_snippet=ctrl_body,
                headers=ctrl.get("headers", {}),
                digest=ctrl_digest,
            )

    digests: Set[str] = set()
    error_messages: Set[str] = set()
    validation_errors: List[str] = []
    status_codes: List[int] = []
    prototype_error_hits = False
    rsc_processing = False
    false_positive_stack_detected = False

    for result in probe_results:
        body = result.get("body") or result.get("body_snippet", "")
        status_code = result.get("status_code")
        status_codes.append(status_code)

        digest_match = ERROR_DIGEST_PATTERN.search(body)
        digest = digest_match.group(1) if digest_match else None
        if digest:
            digests.add(digest)
        journal.add_probe(
            "proto",
            action_id=result.get("action_id") or result.get("action_name"),
            endpoint=result.get("endpoint"),
            status_code=status_code,
            body_snippet=body,
            headers=result.get("headers", {}),
            digest=digest,
        )

        if status_code == 500 and len(body) < 500:
            if not body.startswith(("<!doctype", "<html", "0:", "1:")) and body.strip():
                error_messages.add(body.strip()[:4096])

        if status_code in (400, 404, 405) and len(body) < 500:
            body_lower = body.lower()
            if any(pattern in body_lower for pattern in PATCHED_ERROR_PATTERNS):
                validation_errors.append(body.strip()[:4096])

        body_lower = body.lower()
        is_false_positive_stack = any(
            pattern in body_lower for pattern in NEXTJS_FALSE_POSITIVE_STACK_PATTERNS
        )
        false_positive_stack_detected = false_positive_stack_detected or is_false_positive_stack
        if status_code and status_code >= 400:
            if (
                any(pattern in body_lower for pattern in VULN_ERROR_PATTERNS)
                and not is_false_positive_stack
            ):
                prototype_error_hits = True

        content_type = result.get("headers", {}).get("content-type", "")
        if (
            RSC_CONTENT_TYPE in content_type
            or RSC_FLIGHT_PATTERN_V19 in body
            or RSC_FLIGHT_PATTERN_ARRAY in body
        ):
            rsc_processing = True
            if react_major is None and RSC_FLIGHT_PATTERN_V19 in body:
                react_major = 19

    successes = 0
    html_responses = 0
    failures = sum(1 for sc in status_codes if sc and sc >= 500)
    html_dev_errors = False
    proxy_errors = [
        result
        for result in probe_results
        if (result.get("status_code") == 502)
        and ("proxy error" in (result.get("body", "") + result.get("body_snippet", "")).lower())
    ]

    for result in probe_results:
        status_code = result.get("status_code")
        body = result.get("body") or result.get("body_snippet", "")
        content_type = (result.get("headers", {}) or {}).get("content-type", "")
        body_lower = body.lower()

        is_flight = body.startswith("0:") or body.startswith("1:")
        is_rsc_ct = RSC_CONTENT_TYPE in content_type
        is_json_ct = "application/json" in content_type.lower()
        is_html = "<!doctype" in body_lower or "<html" in body_lower

        if status_code == 200:
            if is_rsc_ct or is_json_ct or is_flight:
                successes += 1
            elif is_html:
                html_responses += 1
        elif status_code in (301, 302, 303, 307, 308):
            html_responses += 1
        elif (
            status_code
            and status_code >= 500
            and is_html
            and ("__next_data__" in body_lower or "__next_error__" in body_lower)
        ):
            html_dev_errors = True

    if proxy_errors and successes == 0 and failures == len(status_codes):
        status = PocStatus.INCONCLUSIVE
        confidence = "none"
        reason = "Probe requests failed with upstream proxy errors"
        journal.add_decision(status, reason)
        return {
            "status": status,
            "details": {
                "cve_id": cve_id,
                "confidence": confidence,
                "reason": reason,
                "framework": framework,
                "surface_detected": False,
                "error_categories": error_categories,
            },
            "raw_data": {
                "probe_results": probe_results,
                "control_results": control_results,
                "journal": journal.to_list(),
            },
        }

    surface_detected = bool(is_rsc_framework or rsc_processing)
    react_major_conf_level = _confidence_score(react_major_confidence)

    # Decision tree based on probe/control responses and digests.

    if server_actions_expected is False and successes == 0:
        # Some Next.js variants expose action-like behavior even when signals say no actions.
        if is_rsc_framework and digests:
            proto_digest = list(digests)[0] if len(digests) == 1 else None
            if control_digest and proto_digest and control_digest == proto_digest:
                status = PocStatus.LIKELY_NOT_VULNERABLE
                confidence = "medium"
                reason = "RSC probes failed identically without action signal - treating as patched/non-action"
                surface_detected = True
            elif len(digests) > 1 or (
                control_digest and proto_digest and control_digest != proto_digest
            ):
                status = PocStatus.VULNERABLE
                confidence = "medium"
                reason = "Proto/control digests diverged despite no action signal - treating as vulnerable behavior"
                surface_detected = True
            else:
                status = PocStatus.LIKELY_VULNERABLE
                confidence = "medium"
                reason = "RSC probes returned error digests without action signal"
                surface_detected = True
        else:
            confidence = (
                "high"
                if _confidence_at_least(actions_confidence, "high")
                else "medium" if _confidence_at_least(actions_confidence, "medium") else "low"
            )
            status = (
                PocStatus.NOT_VULNERABLE
                if confidence == "high"
                else PocStatus.LIKELY_NOT_VULNERABLE
            )
            reason = (
                "Server actions not enabled; probe responses came from RSC-only surface "
                "(React2Shell requires RSC / Server Actions)"
            )
            surface_detected = bool(is_rsc_framework or rsc_processing)
    elif failures == 0 and successes == 0 and validation_errors and is_rsc_framework:
        status = PocStatus.LIKELY_NOT_VULNERABLE
        confidence = "medium"
        reason = (
            "Server action validation rejected synthetic IDs (4xx with action-not-found message) "
            "before RSC processing"
        )
        surface_detected = True
    elif html_responses > 0 and successes == 0 and failures == 0:
        if server_actions_expected is False:
            confidence = (
                "high"
                if _confidence_at_least(actions_confidence, "high")
                else "medium" if _confidence_at_least(actions_confidence, "medium") else "low"
            )
            status = (
                PocStatus.NOT_VULNERABLE
                if confidence == "high"
                else PocStatus.LIKELY_NOT_VULNERABLE
            )
            reason = (
                "Server actions not detected; HTML responses indicate no action surface "
                "(React2Shell requires RSC / Server Actions)"
            )
            surface_detected = bool(is_rsc_framework or rsc_processing)
        elif is_rsc_framework:
            status = PocStatus.NOT_VULNERABLE
            confidence = "high"
            reason = (
                "RSC framework detected but probes returned HTML - patched/blocked action surface"
            )
        else:
            status = PocStatus.NOT_APPLICABLE
            confidence = "high"
            reason = "All responses returned HTML, not RSC Flight protocol"
            surface_detected = False
    elif successes > 0:
        if control_status == 200 and failures == 0:
            status = PocStatus.NOT_VULNERABLE
            confidence = "high"
            reason = "Proto and control probes both succeeded (action processing reached)"
        else:
            status = PocStatus.NOT_VULNERABLE
            confidence = "medium"
            reason = "Server action processing returned 200 responses for proto probes"
    elif framework == "nextjs" and html_dev_errors and successes == 0:
        all_bodies = [(res.get("body") or res.get("body_snippet", "")) for res in probe_results]
        all_bodies_same = control_body is not None and all(
            body == control_body for body in all_bodies
        )
        dev_overlay_signatures = (
            "module not found",
            "webpack",
            "next/dist/build/webpack/plugins",
            "__next_error__",
        )
        dev_overlay_hit = control_body and any(
            sig in control_body.lower() for sig in dev_overlay_signatures
        )

        # If dev overlay returns a 200 HTML page for proto/control, treat as patched.
        has_html_200 = any(
            res.get("status_code") == 200
            and ("<html" in (res.get("body") or res.get("body_snippet", "")).lower())
            for res in probe_results + (control_results or [])
        )

        dev_overlay_short_circuit = (
            dev_overlay_hit and all_bodies_same and not digests and not rsc_processing
        )

        if has_html_200 and dev_overlay_hit:
            status = PocStatus.NOT_VULNERABLE
            confidence = "high"
            reason = "Next.js dev overlay returned 200 HTML for proto/control (patched behavior)"
        elif dev_overlay_short_circuit:
            status = PocStatus.LIKELY_NOT_VULNERABLE
            confidence = "medium"
            reason = (
                "Next.js dev overlay returned identical HTML for proto/control without RSC digests "
                "- treating as validation short-circuit"
            )
        elif all_bodies_same or (control_body and not control_digest and html_dev_errors):
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Next.js dev overlay returned identical HTML on action probes (possible vulnerable dev path)"
        else:
            if react_major is not None and react_major < 19:
                confidence = (
                    "high"
                    if react_major_conf_level >= CONFIDENCE_ORDER["high"]
                    else "medium" if react_major_conf_level >= CONFIDENCE_ORDER["medium"] else "low"
                )
                status = (
                    PocStatus.NOT_VULNERABLE
                    if confidence == "high"
                    else PocStatus.LIKELY_NOT_VULNERABLE
                )
                reason = (
                    "Next.js dev overlay returned HTML without RSC; React <19 "
                    "(React2Shell requires React 19.x)"
                )
            else:
                status = PocStatus.LIKELY_VULNERABLE
                confidence = "medium"
                reason = "Next.js dev error page returned HTML 5xx on action probes (dev overlay on action path)"
    elif len(digests) > 1:
        if server_actions_expected is True:
            status = PocStatus.VULNERABLE
            confidence = "high"
            reason = (
                "Proto probes returned multiple distinct error digests while actions were expected "
                "- prototype traversal altered behavior"
            )
        elif server_actions_expected is False and not is_rsc_framework:
            status = PocStatus.LIKELY_NOT_VULNERABLE
            confidence = "medium"
            reason = "Multiple digests on non-RSC surface without actions signal - treating as ambiguous/non-action"
        else:
            status = PocStatus.LIKELY_NOT_VULNERABLE
            confidence = "medium"
            reason = (
                "Proto probes returned multiple distinct error digests without clear action surface "
                "- treating as patched/validation differences"
            )
    elif len(digests) == 1 and failures >= 2 and successes == 0:
        proto_digest = list(digests)[0]
        react_info = f" (React {react_major})" if react_major else ""
        control_matches_proto = control_status == 500 and control_digest == proto_digest
        control_diverges = control_status == 200 or (
            control_status == 500 and control_digest is not None and control_digest != proto_digest
        )

        if control_diverges:
            if control_status == 200:
                status = PocStatus.VULNERABLE
                confidence = "high"
                reason = (
                    f"Control succeeded (200) while proto probe fails with digest "
                    f"{proto_digest[:16]}... - prototype traversal causes crash{react_info}"
                )
            else:
                status = PocStatus.VULNERABLE
                confidence = "high" if server_actions_expected is True else "medium"
                reason = (
                    "Proto and control probes fail with different digests "
                    f"({proto_digest[:12]}... vs {control_digest[:12]}...) - different error paths{react_info}"
                )
        elif control_matches_proto:
            all_bodies = [
                (res.get("body") or "") + res.get("body_snippet", "") for res in probe_results
            ]
            has_patched_error = any(
                any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS)
                for body in all_bodies
            )
            if has_patched_error:
                status = PocStatus.LIKELY_NOT_VULNERABLE
                confidence = "medium"
                reason = (
                    "Proto and control probes share the same digest but include action validation errors "
                    "- patched behavior"
                )
            elif react_major is not None and react_major != 19:
                confidence = (
                    "high"
                    if react_major_conf_level >= CONFIDENCE_ORDER["high"]
                    else "medium" if react_major_conf_level >= CONFIDENCE_ORDER["medium"] else "low"
                )
                status = (
                    PocStatus.NOT_VULNERABLE
                    if confidence == "high"
                    else PocStatus.LIKELY_NOT_VULNERABLE
                )
                reason = (
                    f"React {react_major}.x with identical proto/control failures "
                    "(React2Shell requires React 19.x)"
                )
                surface_detected = is_rsc_framework or rsc_processing
            else:
                status = PocStatus.LIKELY_NOT_VULNERABLE
                confidence = "medium"
                reason = (
                    "Proto and control probes fail identically - no behavioral difference attributable "
                    "to prototype traversal"
                )
        else:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = f"All {failures} probes failed with identical digest - RSC deserialization error{react_info}"
    elif server_actions_expected and is_rsc_framework and failures > 0 and successes == 0:
        if framework == "nextjs":
            proto_bodies = [
                (res.get("body") or res.get("body_snippet", "")) for res in probe_results
            ]
            validation_on_action_path = any(
                any(pattern in body.lower() for pattern in PATCHED_ERROR_PATTERNS)
                for body in proto_bodies + ([control_body] if control_body else [])
            )
            if validation_on_action_path:
                status = PocStatus.LIKELY_NOT_VULNERABLE
                confidence = "medium"
                reason = (
                    "Server action probes hit validation messaging without RSC digests "
                    "- treating as patched/blocked action surface"
                )
            elif react_major is not None and react_major < 19:
                confidence = (
                    "high"
                    if react_major_conf_level >= CONFIDENCE_ORDER["high"]
                    else "medium" if react_major_conf_level >= CONFIDENCE_ORDER["medium"] else "low"
                )
                status = (
                    PocStatus.NOT_VULNERABLE
                    if confidence == "high"
                    else PocStatus.LIKELY_NOT_VULNERABLE
                )
                reason = (
                    "Server actions errors without RSC processing; React <19 "
                    "(React2Shell requires React 19.x)"
                )
            else:
                status = PocStatus.LIKELY_VULNERABLE
                confidence = "medium"
                reason = "Server actions expected; probes returned 5xx without RSC digests (dev/HTML error path)"
        else:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Server actions expected; probes returned 5xx without RSC digests (dev/HTML error path)"
    elif len(probe_results) == 1:
        status = PocStatus.INCONCLUSIVE
        confidence = "low"
        reason = "Only one probe result available; need multiple actions to compare"
    elif prototype_error_hits and not false_positive_stack_detected:
        if (rsc_processing or is_rsc_framework) and (failures > 0 or server_actions_expected):
            status = PocStatus.VULNERABLE
            confidence = "high" if failures > 0 else "medium"
            reason = "Prototype-related errors observed in RSC probe responses (action path hit)"
        else:
            status = PocStatus.LIKELY_VULNERABLE
            confidence = "medium"
            reason = "Prototype-related errors observed in probe responses"
    elif validation_errors and not is_rsc_framework:
        status = PocStatus.NOT_APPLICABLE
        confidence = "high"
        reason = "Action validation errors on non-RSC surface (likely SPA)"
        surface_detected = False
    elif error_messages:
        if len(error_messages) == 1:
            status = PocStatus.INCONCLUSIVE
            confidence = "low"
            reason = "Single plain-text error response; unable to determine behavior"
        else:
            status = PocStatus.LIKELY_NOT_VULNERABLE
            confidence = "medium"
            reason = "Multiple distinct error messages; suggests patched validation paths"
    elif rsc_processing:
        status = PocStatus.INCONCLUSIVE
        confidence = "low"
        reason = "RSC processing detected but behavior inconclusive"
    else:
        status = PocStatus.NOT_APPLICABLE
        confidence = "high"
        reason = "No RSC processing detected"
        surface_detected = False

    journal.add_decision(status, reason)

    return {
        "status": status,
        "details": {
            "cve_id": cve_id,
            "confidence": confidence,
            "reason": reason,
            "framework": framework,
            "react_major": react_major,
            "surface_detected": surface_detected,
            "proto_digests": list(digests),
            "control_digest": control_digest,
        },
        "raw_data": {
            "probe_results": probe_results,
            "control_results": control_results,
            "journal": journal.to_list(),
        },
    }
