"""
    ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
    Copyright (C) 2025  Theori Inc.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Base assessor with shared helpers."""

from abc import ABC, abstractmethod
from typing import Any, Dict, Optional, Tuple

from ...errors import error_category_to_reason
from ...models.poc import PocStatus
from ...utils.version import compare_semver as _compare_semver
from ...utils.version import parse_semver as _parse_semver
from ..journal import PocJournal

CVE_ID = "CVE-2025-55182"


class BaseAssessor(ABC):
    framework_name: str = "base"
    cve_id: str = CVE_ID
    _CONFIDENCE_ORDER = {"none": 0, "low": 1, "medium": 2, "high": 3}

    @staticmethod
    def parse_semver(version: Optional[str]) -> Optional[Tuple[int, int, int, str]]:
        parsed = _parse_semver(version)
        return parsed.to_tuple() if parsed else None

    @staticmethod
    def compare_semver(a: Optional[str], b: Optional[str]) -> Optional[int]:
        return _compare_semver(a, b)

    def get_react_major(
        self, detected_versions: Dict[str, Any], detect_context: Optional[Dict] = None
    ) -> Optional[int]:
        react_major = None
        if detect_context and detect_context.get("react_major") is not None:
            react_major = detect_context.get("react_major")
        elif detected_versions.get("react_major") is not None:
            react_major = detected_versions.get("react_major")
        elif detected_versions.get("react_version"):
            parsed = self.parse_semver(detected_versions.get("react_version"))
            if parsed:
                react_major = parsed[0]
        return react_major

    def get_version_confidence(
        self,
        version_key: str,
        detected_versions: Dict[str, Any],
        detect_context: Optional[Dict] = None,
    ) -> Optional[str]:
        """
        Resolve the best confidence label for a given version key (e.g., ``react_version``).
        """
        signals = (detect_context or {}).get("signals", {}) or {}
        if detect_context and detect_context.get(f"{version_key}_confidence"):
            return detect_context.get(f"{version_key}_confidence")
        if signals.get(f"detected_{version_key}_confidence"):
            return signals.get(f"detected_{version_key}_confidence")
        if detected_versions.get(f"{version_key}_confidence"):
            return detected_versions.get(f"{version_key}_confidence")
        return None

    def confidence_at_least(self, confidence: Optional[str], threshold: str) -> bool:
        """Helper to compare confidence labels."""
        return self._CONFIDENCE_ORDER.get(
            str(confidence or "").lower(), 0
        ) >= self._CONFIDENCE_ORDER.get(threshold, 0)

    def build_not_applicable_result(
        self,
        reason: str,
        detected_versions: Dict[str, Any],
        surface_detected: bool = False,
        not_affected: bool = False,
        journal: Optional[PocJournal] = None,
        confidence: str = "high",
        **extra_details,
    ) -> Dict[str, Any]:
        status = PocStatus.NOT_VULNERABLE if not_affected else PocStatus.NOT_APPLICABLE
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "surface_detected": surface_detected,
            "not_affected": not_affected,
            "detected_versions": detected_versions,
        }
        details.update(extra_details)
        return {
            "status": status,
            "details": details,
            "raw_data": {"journal": (journal or PocJournal()).to_list()},
        }

    def build_inconclusive_result(
        self,
        reason: str,
        detected_versions: Dict[str, Any],
        error_category: Optional[str] = None,
        journal: Optional[PocJournal] = None,
        confidence: str = "low",
        **extra_details,
    ) -> Dict[str, Any]:
        details = {
            "cve_id": self.cve_id,
            "confidence": confidence,
            "reason": reason,
            "error_category": error_category,
            "detected_versions": detected_versions,
        }
        details.update(extra_details)
        return {
            "status": PocStatus.INCONCLUSIVE,
            "details": details,
            "raw_data": {"journal": (journal or PocJournal()).to_list()},
        }

    def error_reason(self, category: Optional[str]) -> str:
        return error_category_to_reason(category)

    @abstractmethod
    def evaluate(
        self,
        base_url: str,
        detected_versions: Dict[str, Any],
        detect_context: Optional[Dict] = None,
        proxy_profile: Optional[str] = None,
        correlation_id: Optional[str] = None,
    ) -> Dict[str, Any]: ...
