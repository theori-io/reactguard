"""
    ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
    Copyright (C) 2025  Theori Inc.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Lightweight journal helper for PoC evaluations."""

import json
from typing import Any, Dict, List, Optional


class PocJournal:
    """Structured journal for PoC runs with size-aware serialization."""

    def __init__(self, entry_limit_bytes: int = 8192, max_entries: int = 128):
        self.entry_limit_bytes = entry_limit_bytes
        self.max_entries = max_entries
        self.entries: List[Dict[str, Any]] = []

    def add_event(
        self,
        step: str,
        summary: str,
        *,
        outcome: Optional[str] = None,
        data: Optional[Any] = None,
        status_code: Optional[int] = None,
    ) -> None:
        entry: Dict[str, Any] = {"step": step, "summary": summary}
        if outcome is not None:
            entry["outcome"] = outcome
        if status_code is not None:
            entry["status_code"] = status_code
        if data is not None:
            entry["data"] = self._normalize_data(data)
        self.entries.append(entry)

    def add_probe(
        self,
        label: str,
        *,
        action_id: Optional[str] = None,
        endpoint: Optional[str] = None,
        status_code: Optional[int] = None,
        body_snippet: str = "",
        headers: Optional[Dict[str, Any]] = None,
        digest: Optional[str] = None,
    ) -> None:
        target = action_id or endpoint or "unknown"
        summary = f"{label} probe for {target} returned {status_code}"
        probe_data: Dict[str, Any] = {
            "body_snippet": (body_snippet or "")[:4096],
        }
        if action_id:
            probe_data["action_id"] = action_id
        if endpoint:
            probe_data["endpoint"] = endpoint
        if headers and headers.get("content-type"):
            probe_data["content_type"] = headers.get("content-type")
        if digest:
            probe_data["digest"] = digest

        self.add_event(
            "probe",
            summary,
            status_code=status_code,
            data=probe_data,
        )

    def add_decision(self, outcome: str, reason: str) -> None:
        self.add_event("decision", reason, outcome=outcome)

    def to_list(self) -> List[Dict[str, Any]]:
        serialized: List[Dict[str, Any]] = []
        for entry in self.entries[: self.max_entries]:
            trimmed = self._trim_entry(entry)
            trimmed = self._enforce_entry_limit(trimmed)
            serialized.append(trimmed)

        if len(self.entries) > self.max_entries:
            serialized.append(
                {
                    "step": "journal-truncated",
                    "summary": f"Journal truncated at {self.max_entries} entries",
                    "dropped_entries": len(self.entries) - self.max_entries,
                }
            )

        return serialized

    def _normalize_data(self, data: Any) -> Any:
        if isinstance(data, str):
            return data[: self.entry_limit_bytes]
        if isinstance(data, dict):
            return {key: self._normalize_data(value) for key, value in data.items()}
        if isinstance(data, list):
            return [self._normalize_data(item) for item in data][: self.max_entries]
        try:
            serialized = json.dumps(data, ensure_ascii=True)
            return serialized[: self.entry_limit_bytes]
        except Exception:
            return str(data)[: self.entry_limit_bytes]

    def _trim_entry(self, entry: Dict[str, Any]) -> Dict[str, Any]:
        trimmed: Dict[str, Any] = {}
        for key, value in entry.items():
            if key == "data" and isinstance(value, str):
                trimmed[key] = value[: self.entry_limit_bytes]
            else:
                trimmed[key] = value
        return trimmed

    def _enforce_entry_limit(self, entry: Dict[str, Any]) -> Dict[str, Any]:
        serialized = json.dumps(entry, ensure_ascii=True)
        if len(serialized) <= self.entry_limit_bytes:
            return entry

        trimmed = dict(entry)
        data = trimmed.get("data")

        if isinstance(data, str):
            base = dict(trimmed)
            base.pop("data", None)
            base_size = len(json.dumps(base, ensure_ascii=True))
            allowance = max(0, self.entry_limit_bytes - base_size - 10)
            trimmed["data"] = data[:allowance]
        else:
            trimmed.pop("data", None)

        if len(json.dumps(trimmed, ensure_ascii=True)) > self.entry_limit_bytes:
            return {"step": "journal-entry-truncated", "summary": "Entry exceeded size limit"}

        return trimmed
