"""
    ReactGuard, framework- and vulnerability-detection tooling for CVE-2025-55182 (React2Shell).
    Copyright (C) 2025  Theori Inc.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published
    by the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""

"""Vulnerability detection runner and CVE-2025-55182 detector."""

from typing import Any, Dict, Optional

from ..errors import error_category_to_reason
from ..framework_detection.engine import FrameworkDetectionEngine
from ..models import FrameworkDetectionResult, ScanRequest
from ..models.poc import PocStatus
from .assessors import (
    ExpoAssessor,
    GenericRSCAssessor,
    NextJSAssessor,
    ReactRouterAssessor,
    WakuAssessor,
)
from .plugin import PocPlugin
from .snapshots import DetectionSnapshot


class CVE202555182VulnerabilityDetector(PocPlugin):
    name = "cve-2025-55182"
    applicable_tags = [
        "nextjs",
        "nextjs-app-router",
        "waku",
        "expo",
        "react-router-v7",
        "react-router-v6",
        "rsc",
    ]

    def __init__(self, detection_engine: Optional[FrameworkDetectionEngine] = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.assessors = {
            "nextjs": NextJSAssessor(),
            "waku": WakuAssessor(),
            "expo": ExpoAssessor(),
            "react-router": ReactRouterAssessor(),
            "rsc": GenericRSCAssessor(),
        }

    def evaluate(
        self,
        url: str,
        *,
        proxy_profile: Optional[str] = None,
        correlation_id: Optional[str] = None,
        detection_result: Optional[FrameworkDetectionResult] = None,
    ) -> Dict[str, Any]:
        detection = detection_result or self.detection_engine.detect(
            ScanRequest(url=url, proxy_profile=proxy_profile, correlation_id=correlation_id)
        )
        snapshot = DetectionSnapshot.from_detection(detection)

        if self._has_fatal_fetch_error(snapshot):
            category = detection.signals.get("fetch_error_category")
            return {
                "status": PocStatus.INCONCLUSIVE,
                "details": {
                    "cve_id": "CVE-2025-55182",
                    "confidence": "none",
                    "reason": error_category_to_reason(category),
                    "framework": None,
                    "error_category": category,
                    "detection_confidence": detection.signals.get("detection_confidence"),
                    "detection_confidence_level": detection.signals.get(
                        "detection_confidence_level"
                    ),
                },
                "raw_data": {"detection": detection.signals},
            }

        framework = self._framework_from_tags(snapshot.tags)
        assessor = self._assessor_for_framework(framework)

        if not assessor:
            return {
                "status": PocStatus.NOT_APPLICABLE,
                "details": {
                    "cve_id": "CVE-2025-55182",
                    "confidence": "none",
                    "reason": "Framework not in scope for PoC",
                    "framework_detected": None,
                    "detection_confidence": detection.signals.get("detection_confidence"),
                    "detection_confidence_level": detection.signals.get(
                        "detection_confidence_level"
                    ),
                },
                "raw_data": {"detection": detection.signals},
            }

        detect_context = snapshot.to_detect_context(self.detection_engine.http_client)
        result = assessor.evaluate(
            url,
            snapshot.detected_versions,
            detect_context,
            proxy_profile=proxy_profile,
            correlation_id=correlation_id,
        )

        result["details"]["framework_detected"] = framework
        result["details"]["detection_confidence"] = snapshot.signals.get("detection_confidence")
        result["details"]["detection_confidence_level"] = snapshot.signals.get(
            "detection_confidence_level"
        )
        result["details"]["detection_tags"] = snapshot.tags
        return result

    def _framework_from_tags(self, tags) -> Optional[str]:
        tag_set = set(tags or [])
        if "waku" in tag_set:
            return "waku"
        if "nextjs" in tag_set or "nextjs-app-router" in tag_set:
            return "nextjs"
        if "expo" in tag_set:
            return "expo"
        if "react-router-v7" in tag_set or "react-router-v6" in tag_set:
            return "react-router"
        if "rsc" in tag_set:
            return "rsc"
        return None

    @staticmethod
    def _has_fatal_fetch_error(snapshot: DetectionSnapshot) -> bool:
        return bool(snapshot.signals.get("fetch_error_category"))

    def _assessor_for_framework(self, framework: Optional[str]):
        if framework is None:
            return None
        return self.assessors.get(framework)


class VulnerabilityDetectionRunner:
    """Utility to run framework detection + vulnerability detection in one step."""

    def __init__(self, detection_engine: Optional[FrameworkDetectionEngine] = None):
        self.detection_engine = detection_engine or FrameworkDetectionEngine()
        self.detector = CVE202555182VulnerabilityDetector(self.detection_engine)

    def run(
        self,
        url: str,
        *,
        proxy_profile: Optional[str] = None,
        correlation_id: Optional[str] = None,
        detection_result=None,
        scan_request: Optional[ScanRequest] = None,
    ) -> Dict[str, Any]:
        detection = detection_result or self._detect(
            url, proxy_profile, correlation_id, scan_request
        )

        result = self.detector.evaluate(
            url,
            proxy_profile=proxy_profile,
            correlation_id=correlation_id,
            detection_result=detection,
        )
        return result

    def _detect(
        self,
        url: str,
        proxy_profile: Optional[str],
        correlation_id: Optional[str],
        scan_request: Optional[ScanRequest],
    ) -> FrameworkDetectionResult:
        effective_request = scan_request or ScanRequest(
            url=url, proxy_profile=proxy_profile, correlation_id=correlation_id
        )
        if not effective_request.url:
            effective_request.url = url
        return self.detection_engine.detect(effective_request)
