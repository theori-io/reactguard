from reactguard.rsc.payloads import (
    NO_INVOKE_TEMP_REF_STRATEGY,
    NO_INVOKE_TEMP_REF_TOKEN,
    SAFE_ARGS_LENGTH_TOKEN,
    SAFE_ARGS_STRATEGY,
    RscReference,
    build_multipart_decode_payload,
)
from reactguard.rsc.runner import run_rsc_action_probes
from reactguard.rsc.send import send_rsc_request
from reactguard.rsc.types import RscRequestConfig
from reactguard.utils.context import get_scan_context, scan_context
from reactguard.vulnerability_detection.probes.rsc_dec2025_probe import (
    send_dec2025_missing_chunk_probe,
    send_dec2025_nextjs_promise_chain_root_probe,
    send_dec2025_promise_chain_probe,
    send_dec2025_safe_control_probe,
    send_dec2025_server_reference_marker_root_probe,
)
from reactguard.vulnerability_detection.probes.waku_probe import send_waku_probe


def test_run_rsc_action_probes_injects_ids_and_uses_context_http_client(monkeypatch):
    calls: list[tuple[str, str | None, object | None, object | None]] = []

    def fake_send(url, config, payload, *, action_id=None, http_client=None):  # noqa: ARG001
        calls.append((url, action_id, http_client, get_scan_context().http_client))
        return {"ok": False, "error_message": "TIMEOUT", "error_type": "Timeout"}

    monkeypatch.setattr("reactguard.rsc.runner.send_rsc_request", fake_send)

    cfg = RscRequestConfig(base_headers={"Accept": "text/x-component"}, action_id_header="Next-Action")
    payload = build_multipart_decode_payload(RscReference(slot=1, root="x", prop="__proto__", marker="F"), boundary="----FormBoundaryfixed")

    with scan_context(http_client="client"):
        results, control = run_rsc_action_probes(
            "http://example",
            ["a1", "a2"],
            request_config=cfg,
            proto_payload=lambda _action_id: payload,
            control_payload=lambda _action_id: payload,
        )

    assert [r["action_id"] for r in results] == ["a1", "a2"]
    assert control["action_id"] == "control_probe"
    assert results[0]["error_message"] == "TIMEOUT"
    assert calls[0][2] is None
    assert calls[0][3] == "client"


def test_send_rsc_request_injects_action_header(monkeypatch):
    captured = {}

    def fake_request(url, *, method, headers, body, **kwargs):  # noqa: ARG001
        captured["headers"] = headers
        captured["body"] = body
        return {"ok": True, "status_code": 200, "headers": {}, "body": "", "body_snippet": "", "url": url}

    monkeypatch.setattr("reactguard.rsc.send.request_with_retries", fake_request)

    cfg = RscRequestConfig(base_headers={"Accept": "text/x-component"}, action_id_header="Next-Action")
    payload = build_multipart_decode_payload(RscReference(slot=1, root="x", prop="__proto__", marker="F"), boundary="----FormBoundaryfixed")
    res = send_rsc_request("http://example", cfg, payload, action_id="x")

    assert res["ok"] is True
    assert captured["headers"]["Next-Action"] == "x"
    assert captured["headers"]["Accept"] == "text/x-component"
    assert "__proto__" in str(captured["body"])


def test_waku_probe_error_path(monkeypatch):
    monkeypatch.setattr(
        "reactguard.rsc.send.request_with_retries",
        lambda *_, **__: {"ok": False, "error_message": "boom", "error_type": "SSLError"},
    )
    res = send_waku_probe("http://example/RSC/F/abc/action.txt")
    assert res["error_message"] == "boom"


def test_dec2025_safe_control_probe_uses_no_invoke_temp_reference_token(monkeypatch):
    monkeypatch.setattr("reactguard.rsc.payloads.secrets.token_hex", lambda *_args, **_kwargs: "feedface")
    captured: dict[str, object] = {}

    def fake_request(url, *, method, headers, body, **kwargs):  # noqa: ARG001
        captured["headers"] = headers
        captured["body"] = body
        return {"ok": True, "status_code": 500, "headers": {}, "body": "", "body_snippet": "", "url": url}

    monkeypatch.setattr("reactguard.rsc.send.request_with_retries", fake_request)

    cfg = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header=None)
    result = send_dec2025_safe_control_probe("http://example", request_config=cfg, action_id=None)

    assert f'"{NO_INVOKE_TEMP_REF_TOKEN}"' in str(captured.get("body"))
    assert result["payload_meta"]["probe_kind"] == "dec2025_control_safe"
    assert result["payload_meta"]["probe_strategy"] == NO_INVOKE_TEMP_REF_STRATEGY


def test_dec2025_marker_root_probe_keeps_metadata_id_non_string(monkeypatch):
    monkeypatch.setattr("reactguard.rsc.payloads.secrets.token_hex", lambda *_args, **_kwargs: "feedface")
    captured: dict[str, object] = {}

    def fake_request(url, *, method, headers, body, **kwargs):  # noqa: ARG001
        captured["headers"] = headers
        captured["body"] = body
        return {"ok": True, "status_code": 500, "headers": {}, "body": "", "body_snippet": "", "url": url}

    monkeypatch.setattr("reactguard.rsc.send.request_with_retries", fake_request)

    cfg = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header=None)
    result = send_dec2025_server_reference_marker_root_probe(
        "http://example",
        request_config=cfg,
        action_id=None,
        server_ref_marker="F",
    )

    body = str(captured.get("body"))
    assert '"id":null' in body
    assert '"x":"$F1"' in body
    assert result["payload_meta"]["probe_kind"] == "dec2025_marker_root"
    assert result["payload_meta"]["probe_strategy"] == "marker_root_decode_error"


def test_dec2025_missing_chunk_probe_uses_root_thenable_token(monkeypatch):
    monkeypatch.setattr("reactguard.rsc.payloads.secrets.token_hex", lambda *_args, **_kwargs: "feedface")
    captured: dict[str, object] = {}

    def fake_request(url, *, method, headers, body, **kwargs):  # noqa: ARG001
        captured["headers"] = headers
        captured["body"] = body
        return {"ok": True, "status_code": 500, "headers": {}, "body": "", "body_snippet": "", "url": url}

    monkeypatch.setattr("reactguard.rsc.send.request_with_retries", fake_request)

    cfg = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header=None)
    result = send_dec2025_missing_chunk_probe(
        "http://example",
        request_config=cfg,
        action_id=None,
        missing_chunk_id_hex="ffff",
    )

    body = str(captured.get("body"))
    assert '"$@ffff"' in body
    assert result["payload_meta"]["probe_kind"] == "dec2025_missing_chunk"
    assert result["payload_meta"]["probe_strategy"] == "missing_chunk_root_thenable"


def test_dec2025_chain_probe_terminates_in_no_invoke_args_container(monkeypatch):
    monkeypatch.setattr("reactguard.rsc.payloads.secrets.token_hex", lambda *_args, **_kwargs: "feedface")
    captured: dict[str, object] = {}

    def fake_request(url, *, method, headers, body, **kwargs):  # noqa: ARG001
        captured["headers"] = headers
        captured["body"] = body
        return {"ok": True, "status_code": 500, "headers": {}, "body": "", "body_snippet": "", "url": url}

    monkeypatch.setattr("reactguard.rsc.send.request_with_retries", fake_request)

    cfg = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header=None)
    result = send_dec2025_promise_chain_probe("http://example", request_config=cfg, action_id=None, chain_depth=5)

    assert f'"length":"{SAFE_ARGS_LENGTH_TOKEN}"' in str(captured.get("body"))
    assert result["payload_meta"]["probe_kind"] == "dec2025_chain"
    assert result["payload_meta"]["probe_strategy"] == SAFE_ARGS_STRATEGY


def test_dec2025_nextjs_chain_root_probe_terminates_in_missing_chunk_thenable(monkeypatch):
    monkeypatch.setattr("reactguard.rsc.payloads.secrets.token_hex", lambda *_args, **_kwargs: "feedface")
    captured: dict[str, object] = {}

    def fake_request(url, *, method, headers, body, **kwargs):  # noqa: ARG001
        captured["headers"] = headers
        captured["body"] = body
        return {"ok": True, "status_code": 500, "headers": {}, "body": "", "body_snippet": "", "url": url}

    monkeypatch.setattr("reactguard.rsc.send.request_with_retries", fake_request)

    cfg = RscRequestConfig(method="POST", base_headers={"Accept": "text/x-component"}, action_id_header="Next-Action")
    result = send_dec2025_nextjs_promise_chain_root_probe(
        "http://example",
        request_config=cfg,
        action_id="deadbeef",
        chain_depth=2,
    )

    assert '"$@ffff"' in str(captured.get("body"))
    assert result["payload_meta"]["probe_kind"] == "dec2025_chain_root"
    assert result["payload_meta"]["probe_strategy"] == "missing_chunk_chain_terminal"
