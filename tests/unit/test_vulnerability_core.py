# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

from reactguard.models import FrameworkDetectionResult, ScanRequest
from reactguard.models.poc import PocStatus
from reactguard.vulnerability_detection.engine import VulnerabilityDetectionEngine
from reactguard.vulnerability_detection.registry import CVE202555182VulnerabilityDetector, detector_registry, get_applicable_detectors
from reactguard.utils.context import get_scan_context, scan_context


class StubAssessor:
    def __init__(self, status):
        self.status = status
        self.calls = 0

    def evaluate(self, *_, **__):
        self.calls += 1
        return {"status": self.status, "details": {"cve_id": "CVE-2025-55182", "reason": "stub"}, "raw_data": {}}


def test_registry_filters_by_tags():
    registry = detector_registry()
    assert any(detector.name == "cve-2025-55182" for detector in registry)
    applicable = get_applicable_detectors(["nextjs", "unknown"])
    names = {detector.name for detector in applicable}
    assert "cve-2025-55182" in names
    assert "cve-2025-55183" in names
    assert "cve-2025-55184" in names
    assert "cve-2025-67779" in names


def test_detector_handles_fetch_error_and_non_applicable():
    detection_error = FrameworkDetectionResult(tags=[], signals={"fetch_error_message": "timeout"})
    detector = CVE202555182VulnerabilityDetector()
    inconclusive = detector.evaluate("http://example", detection_result=detection_error)
    assert inconclusive.status == PocStatus.INCONCLUSIVE

    detection_none = FrameworkDetectionResult(tags=[], signals={"detection_confidence": 10})
    not_applicable = detector.evaluate("http://example", detection_result=detection_none)
    assert not_applicable.status == PocStatus.INCONCLUSIVE


def test_detector_delegates_to_assessor(monkeypatch):
    detection = FrameworkDetectionResult(tags=["waku"], signals={"detection_confidence": 70})
    detector = CVE202555182VulnerabilityDetector()
    stub = StubAssessor(PocStatus.VULNERABLE)
    detector.assessors["waku"] = stub
    result = detector.evaluate("http://example", detection_result=detection)
    assert result.status == PocStatus.VULNERABLE
    assert stub.calls == 1


def test_vulnerability_engine_detects_when_missing_detection(monkeypatch):
    detection_called = {"count": 0}

    class FakeEngine:
        def detect(self, request: ScanRequest):
            detection_called["count"] += 1
            return FrameworkDetectionResult(tags=["nextjs"], signals={})

    engine = VulnerabilityDetectionEngine(detection_engine=FakeEngine())

    class StubPlugin:
        name = "stub"
        applicable_tags = ["nextjs"]

        def evaluate(self, *args, **kwargs):
            return {"status": PocStatus.LIKELY_NOT_VULNERABLE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}}

    monkeypatch.setattr("reactguard.vulnerability_detection.engine.get_applicable_detectors", lambda *_args, **_kwargs: [StubPlugin()])

    result = engine.run("http://example")
    assert detection_called["count"] == 1
    assert isinstance(result, list)
    assert result[0].status == PocStatus.LIKELY_NOT_VULNERABLE


def test_vulnerability_engine_prefers_context_http_client(monkeypatch):
    client_a = object()
    client_b = object()

    class FakeEngine:
        http_client = client_b

        def detect(self, request: ScanRequest):  # noqa: ARG002
            return FrameworkDetectionResult(tags=["nextjs"], signals={})

    engine = VulnerabilityDetectionEngine(detection_engine=FakeEngine())
    captured = []

    class StubPlugin:
        name = "stub"
        applicable_tags = ["nextjs"]

        def evaluate(self, *args, **kwargs):  # noqa: ARG002
            captured.append(get_scan_context().http_client)
            return {"status": PocStatus.INCONCLUSIVE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}}

    monkeypatch.setattr("reactguard.vulnerability_detection.engine.get_applicable_detectors", lambda *_args, **_kwargs: [StubPlugin()])

    with scan_context(http_client=client_a):
        engine.run("http://example", detection_result=FrameworkDetectionResult(tags=["nextjs"], signals={}))

    assert captured == [client_a]


def test_vulnerability_engine_handles_empty_detector_result(monkeypatch):
    class FakeEngine:
        def detect(self, request: ScanRequest):  # noqa: ARG002
            return FrameworkDetectionResult(tags=["nextjs"], signals={})

    engine = VulnerabilityDetectionEngine(detection_engine=FakeEngine())

    class StubPlugin:
        name = "cve-2025-55182"
        applicable_tags = ["nextjs"]

        def evaluate(self, *args, **kwargs):  # noqa: ARG002
            return {}

    monkeypatch.setattr("reactguard.vulnerability_detection.engine.get_applicable_detectors", lambda *_args, **_kwargs: [StubPlugin()])

    result = engine.run("http://example", detection_result=FrameworkDetectionResult(tags=["nextjs"], signals={}))
    assert result[0].status == PocStatus.INCONCLUSIVE
    assert "reason" in result[0].details
