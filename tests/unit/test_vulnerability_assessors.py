# SPDX-FileCopyrightText: 2025 Theori Inc.
# SPDX-License-Identifier: AGPL-3.0-or-later

from reactguard.models.poc import PocStatus
from reactguard.utils import DetectedVersion
from reactguard.rsc.types import RscResponse
from reactguard.vulnerability_detection.assessors import (
    ExpoAssessor,
    GenericRSCAssessor,
    NextJSAssessor,
    ReactRouterAssessor,
    ReactServerComponentsDec2025Assessor,
    RscDec2025Spec,
    WakuAssessor,
)
from reactguard.vulnerability_detection.resolvers.types import ActionEndpoint, ActionResolution
from reactguard.vulnerability_detection.snapshots import DetectContext


def make_detect_context(
    *,
    react_major=None,
    react_major_confidence=None,
    react_major_conflict=None,
    react_major_conflict_confidence=None,
    react_major_conflict_majors=None,
    invocation_enabled=None,
    invocation_confidence=None,
    signals=None,
    tags=None,
    invocation_endpoints=None,
    detected_versions=None,
    extra=None,
):
    return DetectContext(
        react_major=react_major,
        react_major_confidence=react_major_confidence,
        react_major_conflict=react_major_conflict,
        react_major_conflict_confidence=react_major_conflict_confidence,
        react_major_conflict_majors=react_major_conflict_majors,
        invocation_enabled=invocation_enabled,
        invocation_confidence=invocation_confidence,
        signals=signals or {},
        tags=tags or [],
        invocation_endpoints=invocation_endpoints or [],
        detected_versions=detected_versions or {},
        extra=extra or {},
    )


def rsc_response(*, status_code=200, body="", headers=None, ok=True, error_message=None, error_type=None):
    text = str(body or "")
    return RscResponse(
        ok=ok,
        status_code=status_code,
        headers=headers or {},
        text=text,
        content=text.encode(),
        url=None,
        error_message=error_message,
        error_type=error_type,
    )


def test_nextjs_assessor_out_of_scope_version():
    assessor = NextJSAssessor()
    detected_versions = {"next_version": DetectedVersion("13.3.0", confidence="high")}
    result = assessor.evaluate("http://example", detected_versions, detect_context=make_detect_context(signals={}, tags=[]))
    assert result["status"] == PocStatus.NOT_APPLICABLE
    assert result["details"]["not_affected"] is True


def test_nextjs_assessor_react18_not_vulnerable(monkeypatch):
    assessor = NextJSAssessor()
    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.nextjs.discover_nextjs_action_entrypoint_cached", lambda *_args, **_kwargs: None)
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.run_rsc_action_probes",
        lambda *_args, **__: (
            [rsc_response(status_code=500, body="err")] * 3,
            rsc_response(status_code=200, body="ok"),
        ),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.NextjsInterpreter.analyze",
        lambda *_args, **__: {"status": PocStatus.LIKELY_NOT_VULNERABLE, "details": {"confidence": "medium"}, "raw_data": {}},
    )
    detected_versions = {"react_version": DetectedVersion("18.2.0", confidence="high")}
    result = assessor.evaluate("http://example", detected_versions, detect_context=make_detect_context(signals={}, tags=[]))
    assert result["status"] in {PocStatus.LIKELY_NOT_VULNERABLE, PocStatus.NOT_VULNERABLE}


def test_nextjs_assessor_uses_analysis(monkeypatch):
    assessor = NextJSAssessor()
    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.nextjs.discover_nextjs_action_entrypoint_cached", lambda *_args, **_kwargs: None)
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.run_rsc_action_probes",
        lambda *_args, **__: (
            [rsc_response(status_code=200, body="0:[", headers={"content-type": "text/x-component"})] * 3,
            rsc_response(status_code=200, body="ok"),
        ),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.NextjsInterpreter.analyze",
        lambda *_args, **__: {"status": PocStatus.VULNERABLE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detected_versions = {"next_version": DetectedVersion("16.0.5")}
    result = assessor.evaluate(
        "http://example",
        detected_versions,
        detect_context=make_detect_context(
            signals={"rsc_endpoint_found": True, "invocation_enabled": True},
            tags=["nextjs-app-router"],
        ),
    )
    assert result["status"] == PocStatus.VULNERABLE
    assert result["details"]["detected_versions"] == {"next_version": "16.0.5"}


def test_react_router_assessor_not_applicable_without_actions():
    assessor = ReactRouterAssessor()
    detected_versions = {}
    detect_context = make_detect_context(signals={"invocation_enabled": False, "rsc_endpoint_found": False}, tags=[])
    result = assessor.evaluate("http://example", detected_versions, detect_context=detect_context)
    assert result["status"] == PocStatus.LIKELY_NOT_VULNERABLE
    assert result["details"].get("not_affected") is None


def test_expo_assessor_short_circuits_without_actions():
    assessor = ExpoAssessor()
    detected_versions = {}
    detect_context = make_detect_context(signals={"rsc_endpoint_found": False, "invocation_enabled": False}, tags=[])
    result = assessor.evaluate("http://example", detected_versions, detect_context=detect_context)
    assert result["status"] == PocStatus.LIKELY_NOT_VULNERABLE
    assert result["details"].get("not_affected") is None


def test_generic_rsc_assessor_delegates_to_multi_action(monkeypatch):
    assessor = GenericRSCAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.generic_rsc.run_rsc_action_probes",
        lambda *_args, **__: (
            [rsc_response(status_code=500, body="err")] * 3,
            rsc_response(status_code=200, body="ok"),
        ),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.generic_rsc.GenericRscInterpreter.analyze",
        lambda *_args, **__: {"status": PocStatus.INCONCLUSIVE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detected_versions = {"react_version": DetectedVersion("19.1.0")}
    result = assessor.evaluate(
        "http://example",
        detected_versions,
        detect_context=make_detect_context(signals={"invocation_enabled": True}),
    )
    assert result["status"] == PocStatus.INCONCLUSIVE
    assert result["details"]["detected_versions"] == {"react_version": "19.1.0"}


def test_waku_assessor_requires_actions(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.resolve_waku_action_endpoints",
        lambda *_args, **_kwargs: ActionResolution(endpoints=[], has_actions=False, discovery_method="none"),
    )
    result = assessor.evaluate("http://example", {}, detect_context=make_detect_context(signals={}))
    assert result["status"] == PocStatus.LIKELY_NOT_VULNERABLE
    assert result["details"]["surface_detected"] is False


def test_waku_assessor_reports_probe_error(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.resolve_waku_action_endpoints",
        lambda *_args, **_kwargs: ActionResolution(
            endpoints=[],
            has_actions=False,
            discovery_method="probe_error",
            error_info={"error_message": "boom", "error_type": "Timeout"},
        ),
    )
    result = assessor.evaluate("http://example", {}, detect_context=make_detect_context(signals={}))
    assert result["status"] == PocStatus.INCONCLUSIVE
    assert result["details"]["error_message"] == "boom"
    assert "boom" in result["details"]["reason"].lower()


def test_waku_assessor_delegates_to_analysis(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.resolve_waku_action_endpoints",
        lambda *_args, **_kwargs: ActionResolution(
            endpoints=[ActionEndpoint(url="http://example/RSC/F/abc/action.txt", action_name="doThing")],
            has_actions=True,
            discovery_method="probe",
            entrypoint_url="http://example",
        ),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.send_waku_probe",
        lambda *_, **__: rsc_response(status_code=200, body="0:[", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.analyze_waku_results",
        lambda *_, **__: {"status": PocStatus.VULNERABLE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detected_versions = {"react_version": DetectedVersion("19.1.0")}
    result = assessor.evaluate("http://example", detected_versions, detect_context=make_detect_context(signals={}))
    assert result["status"] == PocStatus.VULNERABLE
    assert result["details"]["detected_versions"] == {"react_version": "19.1.0"}


def test_waku_assessor_uses_detected_action_endpoints(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.resolvers.waku.probe_waku_server_actions_result",
        lambda *_, **__: (_ for _ in ()).throw(AssertionError("probe_waku_server_actions should not run when endpoints are provided")),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.resolvers.waku.crawl_same_origin_html",
        lambda *_, **__: (_ for _ in ()).throw(AssertionError("crawl should not run when endpoints are provided")),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.send_waku_probe",
        lambda *_, **__: rsc_response(status_code=200, body="0:[", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.analyze_waku_results",
        lambda *_, **__: {"status": PocStatus.VULNERABLE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detect_context = make_detect_context(signals={}, invocation_endpoints=["http://example/RSC/F/abcdef1234567890/doThing.txt"])
    result = assessor.evaluate("http://example", {}, detect_context=detect_context)
    assert result["status"] == PocStatus.VULNERABLE


def test_rsc_dec2025_assessor_pre_35345_mapping(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=200, body="ok", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed."),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # pre-PR#35345: $h unsupported, $F supported
        if server_ref_marker == "h":
            return rsc_response(status_code=400, body="Connection closed.")
        return rsc_response(status_code=500, body="Args shape error")

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    def _unexpected_chain(*_args, **_kwargs):
        raise AssertionError("promise chain probe should not run for pre_35345 targets")

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_promise_chain_probe", _unexpected_chain)

    base_url = "http://example"
    detect_context = make_detect_context(
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    r_55184 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "pre_35345"

    r_67779 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-67779", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.NOT_APPLICABLE
    assert r_67779["details"]["patch_fingerprint"] == "pre_35345"

    r_55183 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55183", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55183["status"] == PocStatus.LIKELY_VULNERABLE
    assert r_55183["details"]["patch_fingerprint"] == "pre_35345"


def test_rsc_dec2025_assessor_pr35345_marker_differential_is_low_confidence_on_plain_errors(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=200, body="ok", headers={"content-type": "text/plain"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="baseline", headers={"content-type": "text/plain"}),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # Force a differential that matches the baseline but does not look like a distinct decode signature.
        if server_ref_marker == "h":
            return rsc_response(status_code=500, body="baseline", headers={"content-type": "text/plain"})
        return rsc_response(status_code=500, body="other", headers={"content-type": "text/plain"})

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    base_url = "http://example"
    detect_context = make_detect_context(
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    r_55184 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.LIKELY_VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "pre_35345"
    assert r_55184["details"]["patch_fingerprint_confidence"] == "medium"

    r_67779 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-67779", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.NOT_APPLICABLE
    assert r_67779["details"]["patch_fingerprint"] == "pre_35345"
    assert r_67779["details"]["patch_fingerprint_confidence"] == "medium"


def test_rsc_dec2025_assessor_post_35345_pre_35351_mapping(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=200, body="ok", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed."),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # post-PR#35345: $h supported, $F unsupported
        if server_ref_marker == "F":
            return rsc_response(status_code=500, body="Connection closed.")
        return rsc_response(status_code=500, body="Args shape error")

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        # No cycle signal + no boundary => classify post_35345_pre_35351
        return rsc_response(status_code=500, body="Connection closed.")

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_promise_chain_probe", _chain_stub)

    base_url = "http://example"
    detect_context = make_detect_context(
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    r_55184 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.NOT_VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "post_35345_pre_35351"

    r_67779 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-67779", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.LIKELY_VULNERABLE
    assert r_67779["details"]["patch_fingerprint"] == "post_35345_pre_35351"

    r_55183 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55183", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55183["status"] == PocStatus.NOT_VULNERABLE
    assert r_55183["details"]["patch_fingerprint"] == "post_35345_pre_35351"


def test_rsc_dec2025_assessor_post_35345_unknown_when_chain_is_status_only(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=200, body="ok", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed."),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # post-PR#35345: $h supported, $F unsupported
        if server_ref_marker == "F":
            return rsc_response(status_code=500, body="Connection closed.")
        return rsc_response(status_code=500, body="Args shape error")

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        return rsc_response(status_code=404, body="")

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_promise_chain_probe", _chain_stub)

    base_url = "http://example"
    detect_context = make_detect_context(
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    r_67779 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-67779", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.INCONCLUSIVE
    assert r_67779["details"]["patch_fingerprint"] == "post_35345_unknown"


def test_rsc_dec2025_assessor_post_35351_mapping_waku_threshold(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="ok", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"}),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # post-PR#35345: $h supported, $F unsupported
        if server_ref_marker == "F":
            return rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"})
        return rsc_response(status_code=500, body="Args shape error", headers={"content-type": "text/plain"})

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        if chain_depth < 1000:
            return rsc_response(status_code=500, body='{"digest":"aaaaaa"}', headers={"content-type": "text/plain"})
        return rsc_response(status_code=500, body='{"digest":"bbbbbb"}', headers={"content-type": "text/plain"})

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_promise_chain_probe", _chain_stub)

    base_url = "http://example"
    detect_context = make_detect_context(
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    r_55184 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.NOT_VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "post_35351"

    r_67779 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-67779", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.LIKELY_NOT_VULNERABLE
    assert r_67779["details"]["patch_fingerprint"] == "post_35351"


def test_rsc_dec2025_assessor_post_35351_mapping(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=200, body="ok", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed."),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        if server_ref_marker == "F":
            return rsc_response(status_code=500, body="Connection closed.")
        return rsc_response(status_code=500, body="Args shape error")

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        if chain_depth in {990, 1000, 1010}:
            return rsc_response(status_code=400, body="Cannot have cyclic thenables.")
        raise AssertionError(f"unexpected chain depth: {chain_depth}")

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_promise_chain_probe", _chain_stub)

    base_url = "http://example"
    detect_context = make_detect_context(
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    r_55184 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.NOT_VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "post_35351"

    r_67779 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-67779", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.NOT_VULNERABLE
    assert r_67779["details"]["patch_fingerprint"] == "post_35351"

    r_55183 = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55183", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55183["status"] == PocStatus.NOT_VULNERABLE
    assert r_55183["details"]["patch_fingerprint"] == "post_35351"


def test_rsc_dec2025_assessor_nextjs_fingerprints_without_action_id_discovery(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.discover_nextjs_server_reference_marker",
        lambda *_args, **_kwargs: None,
    )

    def _unexpected_entrypoint(*_args, **_kwargs):
        raise AssertionError("entrypoint discovery should not run when random-only probing succeeds")

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.discover_nextjs_action_entrypoint_cached",
        _unexpected_entrypoint,
    )

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=200, body="ok", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"}),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # pre-PR#35345: $h unsupported, $F supported
        if server_ref_marker == "h":
            return rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"})
        return rsc_response(status_code=500, body="Args shape error", headers={"content-type": "text/plain"})

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    base_url = "http://example"
    detect_context = make_detect_context(
        tags=["nextjs-app-router"],
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    result = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert result["status"] == PocStatus.VULNERABLE
    assert result["details"]["patch_fingerprint"] == "pre_35345"

    evidence = result.get("raw_data", {}).get("evidence") or {}
    assert evidence.get("nextjs_action_id_policy") == "random_only"
    assert "nextjs_server_ref_marker" in evidence


def test_rsc_dec2025_assessor_nextjs_retries_with_discovered_action_id(monkeypatch):
    discovered_id = "40echo"
    discovered_url = "http://example/app"
    calls = {"discover": 0}

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.discover_nextjs_server_reference_marker",
        lambda *_args, **_kwargs: None,
    )

    def _discover_stub(*_args, **_kwargs):
        calls["discover"] += 1
        return ActionResolution(
            endpoints=[ActionEndpoint(url=discovered_url)],
            entrypoint_url=discovered_url,
            discovery_method="test",
            has_actions=True,
            action_id=discovered_id,
        )

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.discover_nextjs_action_entrypoint_cached",
        _discover_stub,
    )

    def _control_stub(_endpoint: str, *, action_id: str | None, **_kwargs):
        if action_id == discovered_id:
            return rsc_response(status_code=200, body="ok", headers={"content-type": "text/x-component"})
        return rsc_response(status_code=200, body="<html>dev overlay</html>", headers={"content-type": "text/html", "vary": "RSC"})

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe", _control_stub)
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"}),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # pre-PR#35345: $h unsupported, $F supported
        if server_ref_marker == "h":
            return rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"})
        return rsc_response(status_code=500, body="Args shape error", headers={"content-type": "text/plain"})

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    base_url = "http://example"
    detect_context = make_detect_context(
        tags=["nextjs-app-router"],
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    result = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert result["status"] == PocStatus.VULNERABLE
    assert result["details"]["patch_fingerprint"] == "pre_35345"
    assert calls["discover"] == 1

    evidence = result.get("raw_data", {}).get("evidence") or {}
    assert evidence.get("nextjs_action_id_policy") == "random_then_entrypoint"
    assert evidence.get("nextjs_action_entrypoint_url") == discovered_url


def test_rsc_dec2025_assessor_nextjs_marker_hint_h_overrides_pre_35345_differential(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.discover_nextjs_server_reference_marker",
        lambda *_args, **_kwargs: "h",
    )

    def _unexpected_entrypoint(*_args, **_kwargs):
        raise AssertionError("entrypoint discovery should not run when probing succeeds")

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.discover_nextjs_action_entrypoint_cached",
        _unexpected_entrypoint,
    )

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_safe_control_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=200, body="ok", headers={"content-type": "text/x-component"}),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_missing_chunk_probe",
        lambda *_args, **_kwargs: rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"}),
    )

    def _marker_stub(_endpoint: str, *, server_ref_marker: str, **_kwargs):
        # pre-PR#35345-looking differential: $h matches conn_sig
        if server_ref_marker == "h":
            return rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"})
        return rsc_response(status_code=500, body="Args shape error", headers={"content-type": "text/plain"})

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_server_reference_marker_root_probe",
        _marker_stub,
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        assert chain_depth in {990, 1000, 1010}
        return rsc_response(status_code=500, body="Connection closed.", headers={"content-type": "text/plain"})

    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025_probes.send_dec2025_nextjs_promise_chain_root_probe",
        _chain_stub,
    )

    base_url = "http://example"
    detect_context = make_detect_context(
        tags=["nextjs-app-router"],
        invocation_endpoints=[base_url],
        invocation_enabled=True,
        invocation_confidence="high",
    )

    result = ReactServerComponentsDec2025Assessor(RscDec2025Spec(cve_id="CVE-2025-55184", title="t")).evaluate(base_url, {}, detect_context=detect_context)
    assert result["status"] == PocStatus.NOT_VULNERABLE
    assert result["details"]["patch_fingerprint"] == "post_35345_pre_35351"

    evidence = result.get("raw_data", {}).get("evidence") or {}
    assert evidence.get("pr35345_marker_method") == "nextjs_hint_h_override_h_is_conn_f_not"
