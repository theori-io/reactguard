from reactguard.models.poc import PocStatus
from reactguard.vulnerability_detection.assessors import (
    ExpoAssessor,
    GenericRSCAssessor,
    NextJSAssessor,
    ReactRouterAssessor,
    ReactServerComponentsDec2025Assessor,
    RscDec2025Spec,
    WakuAssessor,
)


def test_nextjs_assessor_out_of_scope_version():
    assessor = NextJSAssessor()
    detected_versions = {"next_version": "13.3.0", "next_version_confidence": "high"}
    result = assessor.evaluate("http://example", detected_versions, detect_context={"signals": {}, "tags": []})
    assert result["status"] == PocStatus.NOT_VULNERABLE
    assert result["details"]["not_affected"] is True


def test_nextjs_assessor_react18_not_vulnerable(monkeypatch):
    assessor = NextJSAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.ActionProbeRunner.run",
        lambda *_args, **__: (
            [{"status_code": 500, "body": "err", "headers": {}, "body_snippet": "err"}] * 3,
            {"status_code": 200, "body": "ok", "headers": {}, "body_snippet": "ok"},
        ),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.MultiActionAnalyzer.analyze",
        lambda *_args, **__: {"status": PocStatus.LIKELY_NOT_VULNERABLE, "details": {"confidence": "medium"}, "raw_data": {}},
    )
    detected_versions = {"react_version": "18.2.0", "react_version_confidence": "high"}
    result = assessor.evaluate("http://example", detected_versions, detect_context={"signals": {}, "tags": []})
    assert result["status"] in {PocStatus.LIKELY_NOT_VULNERABLE, PocStatus.NOT_VULNERABLE}


def test_nextjs_assessor_uses_analysis(monkeypatch):
    assessor = NextJSAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.ActionProbeRunner.run",
        lambda *_args, **__: (
            [{"status_code": 200, "body": "0:[", "headers": {"content-type": "text/x-component"}, "body_snippet": "0:["}] * 3,
            {"status_code": 200, "body": "ok", "headers": {}, "body_snippet": "ok"},
        ),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.nextjs.MultiActionAnalyzer.analyze",
        lambda *_args, **__: {"status": PocStatus.VULNERABLE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detected_versions = {"next_version": "16.0.5"}
    result = assessor.evaluate(
        "http://example",
        detected_versions,
        detect_context={"signals": {"rsc_endpoint_found": True, "server_actions_enabled": True}, "tags": ["nextjs-app-router"]},
    )
    assert result["status"] == PocStatus.VULNERABLE
    assert result["details"]["detected_versions"] == detected_versions


def test_react_router_assessor_not_applicable_without_actions():
    assessor = ReactRouterAssessor()
    detected_versions = {}
    detect_context = {"signals": {"server_actions_enabled": False, "rsc_endpoint_found": False}, "tags": []}
    result = assessor.evaluate("http://example", detected_versions, detect_context=detect_context)
    assert result["status"] == PocStatus.NOT_VULNERABLE
    assert result["details"]["not_affected"] is True


def test_expo_assessor_short_circuits_without_actions():
    assessor = ExpoAssessor()
    detected_versions = {}
    detect_context = {"signals": {"rsc_endpoint_found": False, "server_actions_enabled": False}, "tags": []}
    result = assessor.evaluate("http://example", detected_versions, detect_context=detect_context)
    assert result["status"] == PocStatus.NOT_VULNERABLE
    assert result["details"]["not_affected"] is True


def test_generic_rsc_assessor_delegates_to_multi_action(monkeypatch):
    assessor = GenericRSCAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.generic_rsc.ActionProbeRunner.run",
        lambda *_args, **__: (
            [{"status_code": 500, "body": "err", "headers": {}, "body_snippet": "err"}] * 3,
            {"status_code": 200, "body": "ok", "headers": {}, "body_snippet": "ok"},
        ),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.generic_rsc.MultiActionAnalyzer.analyze",
        lambda *_args, **__: {"status": PocStatus.INCONCLUSIVE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detected_versions = {"react_version": "19.1.0"}
    result = assessor.evaluate("http://example", detected_versions, detect_context={"signals": {"server_actions_enabled": True}})
    assert result["status"] == PocStatus.INCONCLUSIVE
    assert result["details"]["detected_versions"] == detected_versions


def test_waku_assessor_requires_actions(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.waku.crawl_same_origin_html", lambda *_args, **_kwargs: [])
    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.waku.probe_waku_server_actions", lambda *_, **__: (False, 0, []))
    result = assessor.evaluate("http://example", {}, detect_context={"signals": {}})
    assert result["status"] == PocStatus.INCONCLUSIVE
    assert result["details"]["surface_detected"] is False


def test_waku_assessor_reports_probe_error(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.probe_waku_server_actions",
        lambda *_, **__: (False, 0, [], {"error_category": "TIMEOUT", "error_message": "boom"}),
    )
    result = assessor.evaluate("http://example", {}, detect_context={"signals": {}})
    assert result["status"] == PocStatus.INCONCLUSIVE
    assert result["details"]["error_category"] == "TIMEOUT"
    assert "timeout" in result["details"]["reason"].lower()


def test_waku_assessor_delegates_to_analysis(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.probe_waku_server_actions",
        lambda *_, **__: (True, 1, [("/RSC/F/abc/action.txt", "doThing")]),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.send_waku_probe",
        lambda *_, **__: {"ok": True, "status_code": 200, "body": "0:[", "headers": {"content-type": "text/x-component"}, "body_snippet": "0:["},
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.analyze_waku_results",
        lambda *_, **__: {"status": PocStatus.VULNERABLE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detected_versions = {"react_version": "19.1.0"}
    result = assessor.evaluate("http://example", detected_versions, detect_context={"signals": {}})
    assert result["status"] == PocStatus.VULNERABLE
    assert result["details"]["detected_versions"] == detected_versions


def test_waku_assessor_uses_detected_action_endpoints(monkeypatch):
    assessor = WakuAssessor()
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.probe_waku_server_actions",
        lambda *_, **__: (_ for _ in ()).throw(AssertionError("probe_waku_server_actions should not run when endpoints are provided")),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.crawl_same_origin_html",
        lambda *_, **__: (_ for _ in ()).throw(AssertionError("crawl should not run when endpoints are provided")),
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.send_waku_probe",
        lambda *_, **__: {"ok": True, "status_code": 200, "headers": {"content-type": "text/x-component"}, "body": "0:[", "body_snippet": "0:["},
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.waku.analyze_waku_results",
        lambda *_, **__: {"status": PocStatus.VULNERABLE, "details": {"cve_id": "CVE-2025-55182"}, "raw_data": {}},
    )
    detect_context = {"signals": {}, "server_action_endpoints": ["http://example/RSC/F/abcdef1234567890/doThing.txt"]}
    result = assessor.evaluate("http://example", {}, detect_context=detect_context)
    assert result["status"] == PocStatus.VULNERABLE


def test_rsc_dec2025_assessor_pre_35345_mapping(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_decode_control_probe",
        lambda *_args, **_kwargs: {"status_code": 200, "body": "ok"},
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_server_reference_marker_probe",
        lambda *_args, **_kwargs: {"status_code": 400, "body": "Connection closed."},
    )

    def _unexpected_chain(*_args, **_kwargs):
        raise AssertionError("promise chain probe should not run for pre_35345 targets")

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_promise_chain_probe", _unexpected_chain)

    base_url = "http://example"
    detect_context = {"server_action_endpoints": [base_url], "server_actions_enabled": True, "server_actions_confidence": "high"}

    r_55184 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-55184", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "pre_35345"

    r_67779 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-67779", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.NOT_APPLICABLE
    assert r_67779["details"]["patch_fingerprint"] == "pre_35345"

    r_55183 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-55183", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55183["status"] == PocStatus.LIKELY_VULNERABLE
    assert r_55183["details"]["patch_fingerprint"] == "pre_35345"


def test_rsc_dec2025_assessor_post_35345_pre_35351_mapping(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_decode_control_probe",
        lambda *_args, **_kwargs: {"status_code": 200, "body": "ok"},
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_server_reference_marker_probe",
        lambda *_args, **_kwargs: {"status_code": 200, "body": "ok"},
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        # In the incomplete-fix bracket, the 1000 vs 1001 probe should behave the same.
        assert chain_depth in {999, 1000, 1001}
        return {"status_code": 200, "body": "ok"}

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_promise_chain_probe", _chain_stub)

    base_url = "http://example"
    detect_context = {"server_action_endpoints": [base_url], "server_actions_enabled": True, "server_actions_confidence": "high"}

    r_55184 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-55184", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.NOT_VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "post_35345_pre_35351"

    r_67779 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-67779", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.VULNERABLE
    assert r_67779["details"]["patch_fingerprint"] == "post_35345_pre_35351"

    r_55183 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-55183", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55183["status"] == PocStatus.NOT_VULNERABLE
    assert r_55183["details"]["patch_fingerprint"] == "post_35345_pre_35351"


def test_rsc_dec2025_assessor_post_35351_mapping_waku_threshold(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_decode_control_probe",
        lambda *_args, **_kwargs: {"status_code": 500, "headers": {"content-type": "text/plain"}, "body": "ok"},
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_server_reference_marker_probe",
        lambda *_args, **_kwargs: {"status_code": 500, "headers": {"content-type": "text/plain"}, "body": "Cannot read properties of null (reading 'get')"},
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        if chain_depth == 999:
            return {"status_code": 500, "headers": {"content-type": "text/plain"}, "body": "Cannot read properties of undefined (reading 'get')"}
        if chain_depth in {1000, 1001}:
            return {"status_code": 500, "headers": {"content-type": "text/plain"}, "body": "Internal Server Error"}
        raise AssertionError(f"unexpected chain depth: {chain_depth}")

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_promise_chain_probe", _chain_stub)

    base_url = "http://example"
    detect_context = {"server_action_endpoints": [base_url], "server_actions_enabled": True, "server_actions_confidence": "high"}

    r_55184 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-55184", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.NOT_VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "post_35351"

    r_67779 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-67779", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.NOT_VULNERABLE
    assert r_67779["details"]["patch_fingerprint"] == "post_35351"


def test_rsc_dec2025_assessor_post_35351_mapping(monkeypatch):
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_decode_control_probe",
        lambda *_args, **_kwargs: {"status_code": 200, "body": "ok"},
    )
    monkeypatch.setattr(
        "reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_server_reference_marker_probe",
        lambda *_args, **_kwargs: {"status_code": 200, "body": "ok"},
    )

    def _chain_stub(_endpoint: str, *, chain_depth: int, **_kwargs):
        if chain_depth == 1000:
            return {"status_code": 200, "body": "ok"}
        if chain_depth == 1001:
            return {"status_code": 400, "body": "Cannot have cyclic thenables."}
        raise AssertionError(f"unexpected chain depth: {chain_depth}")

    monkeypatch.setattr("reactguard.vulnerability_detection.assessors.rsc_dec2025.send_rsc_promise_chain_probe", _chain_stub)

    base_url = "http://example"
    detect_context = {"server_action_endpoints": [base_url], "server_actions_enabled": True, "server_actions_confidence": "high"}

    r_55184 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-55184", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55184["status"] == PocStatus.NOT_VULNERABLE
    assert r_55184["details"]["patch_fingerprint"] == "post_35351"

    r_67779 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-67779", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_67779["status"] == PocStatus.NOT_VULNERABLE
    assert r_67779["details"]["patch_fingerprint"] == "post_35351"

    r_55183 = ReactServerComponentsDec2025Assessor(
        RscDec2025Spec(cve_id="CVE-2025-55183", title="t"),
    ).evaluate(base_url, {}, detect_context=detect_context)
    assert r_55183["status"] == PocStatus.NOT_VULNERABLE
    assert r_55183["details"]["patch_fingerprint"] == "post_35351"
